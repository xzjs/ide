Sk.builtinFiles={"files": {"src/builtin/this.py": "s = \"\"\"Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint \"\".join([d.get(c, c) for c in s])\n", "src/builtin/sys.js": "var $builtinmodule = function (name) {\n    var i;\n    var sys = {};\n\n    var args = [];\n    var argv = Sk.getSysArgv();\n    for (i = 0; i < argv.length; ++i) {\n        args.push(new Sk.builtin.str(argv[i]));\n    }\n    sys.argv = new Sk.builtins[\"list\"](args);\n\n    sys.copyright = Sk.builtin[\"str\"](\"Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n\");\n\n    sys.maxint = new Sk.builtin.int_(Math.pow(2,53)-1);\n\n    /*  The largest positive integer supported by the platform\u2019s Py_ssize_t type,\n     *  and thus the maximum size lists, strings, dicts, and many other containers can have.\n     *\n     *  In skulpt this is the same as maxint, due to the underlying implementation in javascript\n     */\n    sys.maxsize = new Sk.builtin.int_(Math.pow(2,53)-1);\n\n    sys.modules = Sk.sysmodules;\n\n    sys.path = Sk.realsyspath;\n\n    sys.getExecutionLimit = new Sk.builtin.func(function () {\n        if (Sk.execLimit === null) {\n            return Sk.builtin.none.none$;\n        }\n        return new Sk.builtin.int_(Sk.execLimit);\n    });\n\n    sys.setExecutionLimit = new Sk.builtin.func(function (t) {\n        if (Sk.execLimit === null) {\n            throw new Sk.builtin.NotImplementedError(\"Execution limiting is not enabled\");\n        }\n        if (t !== undefined) {\n            Sk.execLimit = Sk.builtin.asnum$(t);\n        }\n    });\n\n    sys.resetTimeout = new Sk.builtin.func(function () {\n        Sk.execStart = new Date();\n    });\n\n    sys.getYieldLimit = new Sk.builtin.func(function () {\n        if (Sk.yieldLimit === null) {\n            return Sk.builtin.none.none$;\n        }\n        return new Sk.builtin.int_(Sk.yieldLimit);\n    });\n\n    sys.setYieldLimit = new Sk.builtin.func(function (t) {\n        if (Sk.yieldLimit === null) {\n            throw new Sk.builtin.NotImplementedError(\"Yielding is not enabled\");\n        }\n        if (t !== undefined) {\n            Sk.yieldLimit = Sk.builtin.asnum$(t);\n        }\n    });\n\n    sys.debug = new Sk.builtin.func(function () {\n        return Sk.builtin.none.none$;\n    });\n\n    sys.__stdout__ = new Sk.builtin.file(new Sk.builtin.str(\"/dev/stdout\"), new Sk.builtin.str(\"w\"));\n    sys.__stdin__ = new Sk.builtin.file(new Sk.builtin.str(\"/dev/stdin\"), new Sk.builtin.str(\"r\"));\n\n    sys.stdout = sys.__stdout__;\n    sys.stdin = sys.__stdin__;\n    \n    sys.exc_info = new Sk.builtin.func(function () {\n        var type = Sk.err.ob$type;\n        var value = Sk.builtin.none.none$;\n        var traceback = new Sk.builtin.traceback(Sk.err);\n        //print(traceback.tp$setattr)\n        //traceback.tp$setattr('tb_lineno', traceback.tb_lineno);\n        var vals = [type, Sk.err, traceback];\n        return new Sk.builtin.tuple(vals);\n    });\n\n    return sys;\n};\n", "src/lib/zipfile.py": "raise NotImplementedError(\"zipfile is not yet implemented in Skulpt\")\n", "src/lib/shutil.py": "raise NotImplementedError(\"shutil is not yet implemented in Skulpt\")\n", "src/lib/tempfile.py": "raise NotImplementedError(\"tempfile is not yet implemented in Skulpt\")\n", "src/lib/Queue.py": "raise NotImplementedError(\"Queue is not yet implemented in Skulpt\")\n", "src/lib/macpath.py": "raise NotImplementedError(\"macpath is not yet implemented in Skulpt\")\n", "src/lib/pkgutil.py": "raise NotImplementedError(\"pkgutil is not yet implemented in Skulpt\")\n", "src/lib/asyncore.py": "raise NotImplementedError(\"asyncore is not yet implemented in Skulpt\")\n", "src/lib/__phello__.foo.py": "raise NotImplementedError(\"__phello__.foo is not yet implemented in Skulpt\")\n", "src/lib/sndhdr.py": "raise NotImplementedError(\"sndhdr is not yet implemented in Skulpt\")\n", "src/lib/rlcompleter.py": "raise NotImplementedError(\"rlcompleter is not yet implemented in Skulpt\")\n", "src/lib/gzip.py": "raise NotImplementedError(\"gzip is not yet implemented in Skulpt\")\n", "src/lib/user.py": "raise NotImplementedError(\"user is not yet implemented in Skulpt\")\n", "src/lib/urllib2.py": "raise NotImplementedError(\"urllib2 is not yet implemented in Skulpt\")\n", "src/lib/trace.py": "raise NotImplementedError(\"trace is not yet implemented in Skulpt\")\n", "src/lib/webbrowser.py": "raise NotImplementedError(\"webbrowser is not yet implemented in Skulpt\")\n", "src/lib/nntplib.py": "raise NotImplementedError(\"nntplib is not yet implemented in Skulpt\")\n", "src/lib/DocXMLRPCServer.py": "raise NotImplementedError(\"DocXMLRPCServer is not yet implemented in Skulpt\")\n", "src/lib/UserString.py": "raise NotImplementedError(\"UserString is not yet implemented in Skulpt\")\n", "src/lib/dircache.py": "raise NotImplementedError(\"dircache is not yet implemented in Skulpt\")\n", "src/lib/dis.py": "raise NotImplementedError(\"dis is not yet implemented in Skulpt\")\n", "src/lib/formatter.py": "raise NotImplementedError(\"formatter is not yet implemented in Skulpt\")\n", "src/lib/bdb.py": "raise NotImplementedError(\"bdb is not yet implemented in Skulpt\")\n", "src/lib/cmd.py": "raise NotImplementedError(\"cmd is not yet implemented in Skulpt\")\n", "src/lib/tty.py": "raise NotImplementedError(\"tty is not yet implemented in Skulpt\")\n", "src/lib/tabnanny.py": "raise NotImplementedError(\"tabnanny is not yet implemented in Skulpt\")\n", "src/lib/cProfile.py": "raise NotImplementedError(\"cProfile is not yet implemented in Skulpt\")\n", "src/lib/token.py": "raise NotImplementedError(\"token is not yet implemented in Skulpt\")\n", "src/lib/textwrap.py": "raise NotImplementedError(\"textwrap is not yet implemented in Skulpt\")\n", "src/lib/base64.py": "raise NotImplementedError(\"base64 is not yet implemented in Skulpt\")\n", "src/lib/random.js": "/*\n I've wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace\n so it's better encapsulated. Now you can have multiple random number generators\n and they won't stomp all over eachother's state.\n\n If you want to use this as a substitute for Math.random(), use the random()\n method like so:\n\n var m = new MersenneTwister();\n var randomNumber = m.random();\n\n You can also call the other genrand_{foo}() methods on the instance.\n\n If you want to use a specific seed in order to get a repeatable random\n sequence, pass an integer into the constructor:\n\n var m = new MersenneTwister(123);\n\n and that will always produce the same random sequence.\n\n Sean McCullough (banksean@gmail.com)\n */\n\n/* \n A C-program for MT19937, with initialization improved 2002/1/26.\n Coded by Takuji Nishimura and Makoto Matsumoto.\n\n Before using, initialize the state by using init_genrand(seed)\n or init_by_array(init_key, key_length).\n\n Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions\n are met:\n\n 1. Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in the\n documentation and/or other materials provided with the distribution.\n\n 3. The names of its contributors may not be used to endorse or promote\n products derived from this software without specific prior written\n permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n Any feedback is very welcome.\n http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n */\n\nvar MersenneTwister = function (seed) {\n    if (seed == undefined) {\n        seed = new Date().getTime();\n    }\n    /* Period parameters */\n    this.N = 624;\n    this.M = 397;\n    this.MATRIX_A = 0x9908b0df;\n    /* constant vector a */\n    this.UPPER_MASK = 0x80000000;\n    /* most significant w-r bits */\n    this.LOWER_MASK = 0x7fffffff;\n    /* least significant r bits */\n\n    this.mt = new Array(this.N);\n    /* the array for the state vector */\n    this.mti = this.N + 1;\n    /* mti==N+1 means mt[N] is not initialized */\n\n    this.init_genrand(seed);\n}\n\n/* initializes mt[N] with a seed */\nMersenneTwister.prototype.init_genrand = function (s) {\n    this.mt[0] = s >>> 0;\n    for (this.mti = 1; this.mti < this.N; this.mti++) {\n        var s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);\n        this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)\n            + this.mti;\n        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n        /* In the previous versions, MSBs of the seed affect   */\n        /* only MSBs of the array mt[].                        */\n        /* 2002/01/09 modified by Makoto Matsumoto             */\n        this.mt[this.mti] >>>= 0;\n        /* for >32 bit machines */\n    }\n}\n\n/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\nMersenneTwister.prototype.init_by_array = function (init_key, key_length) {\n    var i, j, k;\n    this.init_genrand(19650218);\n    i = 1;\n    j = 0;\n    k = (this.N > key_length ? this.N : key_length);\n    for (; k; k--) {\n        var s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30)\n        this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))\n            + init_key[j] + j;\n        /* non linear */\n        this.mt[i] >>>= 0;\n        /* for WORDSIZE > 32 machines */\n        i++;\n        j++;\n        if (i >= this.N) {\n            this.mt[0] = this.mt[this.N - 1];\n            i = 1;\n        }\n        if (j >= key_length) {\n            j = 0;\n        }\n    }\n    for (k = this.N - 1; k; k--) {\n        var s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);\n        this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))\n            - i;\n        /* non linear */\n        this.mt[i] >>>= 0;\n        /* for WORDSIZE > 32 machines */\n        i++;\n        if (i >= this.N) {\n            this.mt[0] = this.mt[this.N - 1];\n            i = 1;\n        }\n    }\n\n    this.mt[0] = 0x80000000;\n    /* MSB is 1; assuring non-zero initial array */\n}\n\n/* generates a random number on [0,0xffffffff]-interval */\nMersenneTwister.prototype.genrand_int32 = function () {\n    var y;\n    var mag01 = new Array(0x0, this.MATRIX_A);\n    /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n    if (this.mti >= this.N) { /* generate N words at one time */\n        var kk;\n\n        if (this.mti == this.N + 1)   /* if init_genrand() has not been called, */\n        {\n            this.init_genrand(5489);\n        }\n        /* a default initial seed is used */\n\n        for (kk = 0; kk < this.N - this.M; kk++) {\n            y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);\n            this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n        }\n        for (; kk < this.N - 1; kk++) {\n            y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);\n            this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n        }\n        y = (this.mt[this.N - 1] & this.UPPER_MASK) | (this.mt[0] & this.LOWER_MASK);\n        this.mt[this.N - 1] = this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n        this.mti = 0;\n    }\n\n    y = this.mt[this.mti++];\n\n    /* Tempering */\n    y ^= (y >>> 11);\n    y ^= (y << 7) & 0x9d2c5680;\n    y ^= (y << 15) & 0xefc60000;\n    y ^= (y >>> 18);\n\n    return y >>> 0;\n}\n\n/* generates a random number on [0,0x7fffffff]-interval */\nMersenneTwister.prototype.genrand_int31 = function () {\n    return (this.genrand_int32() >>> 1);\n}\n\n/* generates a random number on [0,1]-real-interval */\nMersenneTwister.prototype.genrand_real1 = function () {\n    return this.genrand_int32() * (1.0 / 4294967295.0);\n    /* divided by 2^32-1 */\n}\n\n/* generates a random number on [0,1)-real-interval */\nMersenneTwister.prototype.random = function () {\n    return this.genrand_int32() * (1.0 / 4294967296.0);\n    /* divided by 2^32 */\n}\n\n/* generates a random number on (0,1)-real-interval */\nMersenneTwister.prototype.genrand_real3 = function () {\n    return (this.genrand_int32() + 0.5) * (1.0 / 4294967296.0);\n    /* divided by 2^32 */\n}\n\n/* generates a random number on [0,1) with 53-bit resolution*/\nMersenneTwister.prototype.genrand_res53 = function () {\n    var a = this.genrand_int32() >>> 5, b = this.genrand_int32() >>> 6;\n    return(a * 67108864.0 + b) * (1.0 / 9007199254740992.0);\n}\n\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\n\n\nvar $builtinmodule = function (name) {\n\n    var mod = {};\n\n    var myGenerator = new MersenneTwister();\n    var nextNormalSample = undefined;\n\n    mod.seed = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"seed\", arguments, 0, 1);\n        x = Sk.builtin.asnum$(x);\n\n        if (arguments.length > 0) {\n            myGenerator = new MersenneTwister(x);\n        }\n        else {\n            myGenerator = new MersenneTwister();\n        }\n\n        return Sk.builtin.none.none$;\n    });\n\n    mod.random = new Sk.builtin.func(function () {\n        Sk.builtin.pyCheckArgs(\"random\", arguments, 0, 0);\n\n        return new Sk.builtin.float_(myGenerator.genrand_res53());\n    });\n\n    var toInt = function (num) {\n        return num | 0;\n    };\n\n    var randrange = function (start, stop, step) {\n        // Ported from CPython 2.7\n        var width, n, ret;\n\n        if (!Sk.builtin.checkInt(start)) {\n            throw new Sk.builtin.ValueError(\"non-integer first argument for randrange()\");\n        }\n        ;\n\n        if (stop === undefined) {\n            // Random in [0, start)\n            ret = toInt(myGenerator.genrand_res53() * start);\n            return new Sk.builtin.int_(ret);\n        }\n        ;\n\n        if (!Sk.builtin.checkInt(stop)) {\n            throw new Sk.builtin.ValueError(\"non-integer stop for randrange()\");\n        }\n        ;\n\n        if (step === undefined) {\n            step = 1;\n        }\n        ;\n\n        width = stop - start;\n\n        if ((step == 1) && (width > 0)) {\n            // Random in [start, stop), must use toInt on product for correct results with negative ranges\n            ret = start + toInt(myGenerator.genrand_res53() * width);\n            return new Sk.builtin.int_(ret);\n        }\n        ;\n\n        if (step == 1) {\n            throw new Sk.builtin.ValueError(\"empty range for randrange() (\" + start + \", \" + stop + \", \" + width + \")\");\n        }\n        ;\n\n        if (!Sk.builtin.checkInt(step)) {\n            throw new Sk.builtin.ValueError(\"non-integer step for randrange()\");\n        }\n        ;\n\n        if (step > 0) {\n            n = toInt((width + step - 1) / step);\n        } else if (step < 0) {\n            n = toInt((width + step + 1) / step);\n        } else {\n            throw new Sk.builtin.ValueError(\"zero step for randrange()\");\n        }\n        ;\n\n        if (n <= 0) {\n            throw new Sk.builtin.ValueError(\"empty range for randrange()\");\n        }\n        ;\n\n        // Random in range(start, stop, step)\n        ret = start + (step * toInt(myGenerator.genrand_res53() * n));\n        return new Sk.builtin.int_(ret);\n    };\n\n    mod.randint = new Sk.builtin.func(function (a, b) {\n        Sk.builtin.pyCheckArgs(\"randint\", arguments, 2, 2);\n\n        a = Sk.builtin.asnum$(a);\n        b = Sk.builtin.asnum$(b);\n        return randrange(a, b + 1);\n    });\n\n    mod.randrange = new Sk.builtin.func(function (start, stop, step) {\n        Sk.builtin.pyCheckArgs(\"randrange\", arguments, 1, 3);\n\n        start = Sk.builtin.asnum$(start);\n        stop = Sk.builtin.asnum$(stop);\n        step = Sk.builtin.asnum$(step);\n        return randrange(start, stop, step);\n    });\n  \n    mod.uniform = new Sk.builtin.func(function (a, b) {\n        Sk.builtin.pyCheckArgs(\"uniform\", arguments, 2, 2);\n\n        a = Sk.builtin.asnum$(a);\n        b = Sk.builtin.asnum$(b);\n        var rnd = myGenerator.genrand_res53();\n        c = a + rnd * (b - a)\n        return new Sk.builtin.float_(c);\n    });\n\n    mod.triangular = new Sk.builtin.func(function (low, high, mode) {\n        Sk.builtin.pyCheckArgs(\"triangular\", arguments, 2, 3);\n        Sk.builtin.pyCheckType(\"low\", \"number\", Sk.builtin.checkNumber(low));\n        Sk.builtin.pyCheckType(\"high\", \"number\", Sk.builtin.checkNumber(high));\n\n        var rnd, sample, swap;\n\n        low = Sk.builtin.asnum$(low);\n        high = Sk.builtin.asnum$(high);\n        if (low > high) {\n            swap = low;\n            low = high;\n            high = swap;\n        }\n        if ((mode === undefined) || (mode instanceof Sk.builtin.none)) {\n            mode = (high - low)/2.0;\n        } else {\n            Sk.builtin.pyCheckType(\"mode\", \"number\", Sk.builtin.checkNumber(mode));\n            mode = Sk.builtin.asnum$(mode);\n        }\n\n        // https://en.wikipedia.org/wiki/Triangular_distribution\n        rnd = myGenerator.genrand_res53();\n        if (rnd < (mode - low)/(high - low)) {\n            sample = low + Math.sqrt(rnd * (high - low) * (mode - low));\n        } else {\n            sample = high - Math.sqrt((1 - rnd) * (high - low) * (high - mode));\n        }\n\n        return new Sk.builtin.float_(sample);\n    });\n\n    var normalSample = function(mu, sigma) {\n        var r1, r2, u, v, s;\n\n        // Box-Muller transform\n        // (https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform)\n        // generates two independent samples from a Gaussian\n        // distribution. Return one of them and store the another one\n        // and return it next time.\n\n        if (nextNormalSample !== undefined) {\n            s = nextNormalSample;\n            nextNormalSample = undefined;\n        } else {\n            r1 = myGenerator.genrand_res53();\n            r2 = myGenerator.genrand_res53();\n            u = Math.sqrt(-2*Math.log(r1));\n            v = 2*Math.PI*r2;\n            s = u * Math.cos(v);\n            nextNormalSample = u * Math.sin(v);\n        }\n\n        return mu + sigma*s;\n    };\n    \n    mod.gauss = new Sk.builtin.func(function (mu, sigma) {\n        Sk.builtin.pyCheckArgs(\"gauss\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"mu\", \"number\", Sk.builtin.checkNumber(mu));\n        Sk.builtin.pyCheckType(\"sigma\", \"number\", Sk.builtin.checkNumber(sigma));\n\n        mu = Sk.builtin.asnum$(mu);\n        sigma = Sk.builtin.asnum$(sigma);\n\n        return new Sk.builtin.float_(normalSample(mu, sigma));\n    });\n\n    // CPython uses a different (slower but thread-safe) algorithm for\n    // normalvariate. We use the same algorithm for normalvariate and\n    // gauss.\n    mod.normalvariate = mod.gauss;\n\n    mod.lognormvariate = new Sk.builtin.func(function (mu, sigma) {\n        Sk.builtin.pyCheckArgs(\"lognormvariate\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"mu\", \"number\", Sk.builtin.checkNumber(mu));\n        Sk.builtin.pyCheckType(\"sigma\", \"number\", Sk.builtin.checkNumber(sigma));\n\n        mu = Sk.builtin.asnum$(mu);\n        sigma = Sk.builtin.asnum$(sigma);\n\n        return new Sk.builtin.float_(Math.exp(normalSample(mu, sigma)));\n    });\n\n    mod.expovariate = new Sk.builtin.func(function (lambd) {\n        Sk.builtin.pyCheckArgs(\"expovariate\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"lambd\", \"number\", Sk.builtin.checkNumber(lambd));\n\n        lambd = Sk.builtin.asnum$(lambd);\n\n        var rnd = myGenerator.genrand_res53();\n        return new Sk.builtin.float_(-Math.log(rnd)/lambd);\n    });\n\n    mod.choice = new Sk.builtin.func(function (seq) {\n        Sk.builtin.pyCheckArgs(\"choice\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"seq\", \"sequence\", Sk.builtin.checkSequence(seq));\n\n        if (seq.sq$length !== undefined) {\n            var r = toInt(myGenerator.genrand_res53() * seq.sq$length());\n            return seq.mp$subscript(r);\n        } else {\n            throw new Sk.builtin.TypeError(\"object has no length\");\n        }\n    });\n\n    mod.shuffle = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"shuffle\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"sequence\", Sk.builtin.checkSequence(x));\n\n        if (x.sq$length !== undefined) {\n            if (x.mp$ass_subscript !== undefined) {\n                for (var i = x.sq$length() - 1; i > 0; i -= 1) {\n                    var r = toInt(myGenerator.genrand_res53() * (i + 1));\n                    var tmp = x.mp$subscript(r);\n                    x.mp$ass_subscript(r, x.mp$subscript(i));\n                    x.mp$ass_subscript(i, tmp);\n                }\n                ;\n            } else {\n                throw new Sk.builtin.TypeError(\"object is immutable\");\n            }\n            ;\n        } else {\n            throw new Sk.builtin.TypeError(\"object has no length\");\n        }\n        ;\n\n        return Sk.builtin.none.none$;\n    });\n\n    mod.sample = new Sk.builtin.func(function (population, k) {\n        var i, j, iter, elem, reservoir;\n\n        Sk.builtin.pyCheckArgs(\"sample\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"population\", \"iterable\", Sk.builtin.checkIterable(population));\n        Sk.builtin.pyCheckType(\"k\", \"integer\", Sk.builtin.checkInt(k));\n        k = Sk.builtin.asnum$(k);\n        \n        // \"Algorithm R\" in\n        // https://en.wikipedia.org/wiki/Reservoir_sampling\n        //\n        // This algorithm guarantees that each element has\n        // equal probability of being included in the\n        // resulting list. See the Wikipedia page for a proof.\n        //\n        // This requires no extra space but the runtime is\n        // proportional to len(population). CPython implements a fast\n        // path for the case when k is much smaller than\n        // len(population). A similar optimization could be\n        // implemented here.\n        reservoir = [];\n        iter = Sk.abstr.iter(population);\n        for (i = 0, elem = iter.tp$iternext();\n             elem !== undefined;\n             i++, elem = iter.tp$iternext()) {\n            j = Math.floor(myGenerator.genrand_res53() * (i + 1));\n            if (i < k) {\n                // Fill the reservoir\n                if (j < i) {\n                    // Shuffle the existing elements to ensure that\n                    // subslices are valid random samples\n                    reservoir[i] = reservoir[j];\n                }\n                reservoir[j] = elem;\n            } else {\n                // Replace elements with a probability that decreases\n                // the further we get\n                if (j < k) {\n                    reservoir[j] = elem;\n                }\n            }\n        }\n        \n        if (i < k) {\n            throw new Sk.builtin.ValueError(\"sample larger than population\");\n        }\n\n        return Sk.builtin.list(reservoir);\n    });\n\n    return mod;\n}\n", "src/lib/Bastion.py": "raise NotImplementedError(\"Bastion is not yet implemented in Skulpt\")\n", "src/lib/HTMLParser.py": "raise NotImplementedError(\"HTMLParser is not yet implemented in Skulpt\")\n", "src/lib/sre_constants.py": "raise NotImplementedError(\"sre_constants is not yet implemented in Skulpt\")\n", "src/lib/cgitb.py": "raise NotImplementedError(\"cgitb is not yet implemented in Skulpt\")\n", "src/lib/statvfs.py": "raise NotImplementedError(\"statvfs is not yet implemented in Skulpt\")\n", "src/lib/macurl2path.py": "raise NotImplementedError(\"macurl2path is not yet implemented in Skulpt\")\n", "src/lib/StringIO.py": "r\"\"\"File-like objects that read from or write to a string buffer.\n\nThis implements (nearly) all stdio methods.\n\nf = StringIO()      # ready for writing\nf = StringIO(buf)   # ready for reading\nf.close()           # explicitly release resources held\nflag = f.isatty()   # always false\npos = f.tell()      # get current position\nf.seek(pos)         # set current position\nf.seek(pos, mode)   # mode 0: absolute; 1: relative; 2: relative to EOF\nbuf = f.read()      # read until EOF\nbuf = f.read(n)     # read up to n bytes\nbuf = f.readline()  # read until end of line ('\\n') or EOF\nlist = f.readlines()# list of f.readline() results until EOF\nf.truncate([size])  # truncate file at to at most size (default: current pos)\nf.write(buf)        # write at current position\nf.writelines(list)  # for line in list: f.write(line)\nf.getvalue()        # return whole file's contents as a string\n\nNotes:\n- Using a real file is often faster (but less convenient).\n- There's also a much faster implementation in C, called cStringIO, but\n  it's not subclassable.\n- fileno() is left unimplemented so that code which uses it triggers\n  an exception early.\n- Seeking far beyond EOF and then writing will insert real null\n  bytes that occupy space in the buffer.\n- There's a simple test set (see end of this file).\n\"\"\"\n\n__all__ = [\"StringIO\"]\n\ndef _complain_ifclosed(closed):\n    if closed:\n        raise ValueError, \"I/O operation on closed file\"\n\nclass StringIO:\n    \"\"\"class StringIO([buffer])\n\n    When a StringIO object is created, it can be initialized to an existing\n    string by passing the string to the constructor. If no string is given,\n    the StringIO will start empty.\n\n    The StringIO object can accept either Unicode or 8-bit strings, but\n    mixing the two may take some care. If both are used, 8-bit strings that\n    cannot be interpreted as 7-bit ASCII (that use the 8th bit) will cause\n    a UnicodeError to be raised when getvalue() is called.\n    \"\"\"\n    def __init__(self, buf = ''):\n        # Force self.buf to be a string or unicode\n        if not isinstance(buf, str):\n            buf = str(buf)\n        self.buf = buf\n        self.len = len(buf)\n        self.buflist = []\n        self.pos = 0\n        self.closed = False\n        self.softspace = 0\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        \"\"\"A file object is its own iterator, for example iter(f) returns f\n        (unless f is closed). When a file is used as an iterator, typically\n        in a for loop (for example, for line in f: print line), the next()\n        method is called repeatedly. This method returns the next input line,\n        or raises StopIteration when EOF is hit.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        r = self.readline()\n        if not r:\n            raise StopIteration\n        return r\n\n    def close(self):\n        \"\"\"Free the memory buffer.\n        \"\"\"\n        if not self.closed:\n            self.closed = True\n            self.buf = None\n            self.pos = None\n\n    def isatty(self):\n        \"\"\"Returns False because StringIO objects are not connected to a\n        tty-like device.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        return False\n\n    def seek(self, pos, mode = 0):\n        \"\"\"Set the file's current position.\n\n        The mode argument is optional and defaults to 0 (absolute file\n        positioning); other values are 1 (seek relative to the current\n        position) and 2 (seek relative to the file's end).\n\n        There is no return value.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        if mode == 1:\n            pos += self.pos\n        elif mode == 2:\n            pos += self.len\n        self.pos = max(0, pos)\n\n    def tell(self):\n        \"\"\"Return the file's current position.\"\"\"\n        _complain_ifclosed(self.closed)\n        return self.pos\n\n    def read(self, n = -1):\n        \"\"\"Read at most size bytes from the file\n        (less if the read hits EOF before obtaining size bytes).\n\n        If the size argument is negative or omitted, read all data until EOF\n        is reached. The bytes are returned as a string object. An empty\n        string is returned when EOF is encountered immediately.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        if n is None or n < 0:\n            newpos = self.len\n        else:\n            newpos = min(self.pos+n, self.len)\n        r = self.buf[self.pos:newpos]\n        self.pos = newpos\n        return r\n\n    def readline(self, length=None):\n        r\"\"\"Read one entire line from the file.\n\n        A trailing newline character is kept in the string (but may be absent\n        when a file ends with an incomplete line). If the size argument is\n        present and non-negative, it is a maximum byte count (including the\n        trailing newline) and an incomplete line may be returned.\n\n        An empty string is returned only when EOF is encountered immediately.\n\n        Note: Unlike stdio's fgets(), the returned string contains null\n        characters ('\\0') if they occurred in the input.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        i = self.buf.find('\\n', self.pos)\n        if i < 0:\n            newpos = self.len\n        else:\n            newpos = i+1\n        if length is not None and length >= 0:\n            if self.pos + length < newpos:\n                newpos = self.pos + length\n        r = self.buf[self.pos:newpos]\n        self.pos = newpos\n        return r\n\n    def readlines(self, sizehint = 0):\n        \"\"\"Read until EOF using readline() and return a list containing the\n        lines thus read.\n\n        If the optional sizehint argument is present, instead of reading up\n        to EOF, whole lines totalling approximately sizehint bytes (or more\n        to accommodate a final whole line).\n        \"\"\"\n        total = 0\n        lines = []\n        line = self.readline()\n        while line:\n            lines.append(line)\n            total += len(line)\n            if 0 < sizehint <= total:\n                break\n            line = self.readline()\n        return lines\n\n    def truncate(self, size=None):\n        \"\"\"Truncate the file's size.\n\n        If the optional size argument is present, the file is truncated to\n        (at most) that size. The size defaults to the current position.\n        The current file position is not changed unless the position\n        is beyond the new file size.\n\n        If the specified size exceeds the file's current size, the\n        file remains unchanged.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if size is None:\n            size = self.pos\n        elif size < 0:\n            raise IOError(22, \"Negative size not allowed\")\n        elif size < self.pos:\n            self.pos = size\n        self.buf = self.getvalue()[:size]\n        self.len = size\n\n    def write(self, s):\n        \"\"\"Write a string to the file.\n\n        There is no return value.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if not s: return\n        # Force s to be a string or unicode\n        if not isinstance(s, str):\n            s = str(s)\n        spos = self.pos\n        slen = self.len\n        if spos == slen:\n            self.buflist.append(s)\n            self.len = self.pos = spos + len(s)\n            return\n        if spos > slen:\n            self.buflist.append('\\0'*(spos - slen))\n            slen = spos\n        newpos = spos + len(s)\n        if spos < slen:\n            if self.buflist:\n                self.buf += ''.join(self.buflist)\n            self.buflist = [self.buf[:spos], s, self.buf[newpos:]]\n            self.buf = ''\n            if newpos > slen:\n                slen = newpos\n        else:\n            self.buflist.append(s)\n            slen = newpos\n        self.len = slen\n        self.pos = newpos\n\n    def writelines(self, iterable):\n        \"\"\"Write a sequence of strings to the file. The sequence can be any\n        iterable object producing strings, typically a list of strings. There\n        is no return value.\n\n        (The name is intended to match readlines(); writelines() does not add\n        line separators.)\n        \"\"\"\n        write = self.write\n        for line in iterable:\n            write(line)\n\n    def flush(self):\n        \"\"\"Flush the internal buffer\n        \"\"\"\n        _complain_ifclosed(self.closed)\n\n    def getvalue(self):\n        \"\"\"\n        Retrieve the entire contents of the \"file\" at any time before\n        the StringIO object's close() method is called.\n\n        The StringIO object can accept either Unicode or 8-bit strings,\n        but mixing the two may take some care. If both are used, 8-bit\n        strings that cannot be interpreted as 7-bit ASCII (that use the\n        8th bit) will cause a UnicodeError to be raised when getvalue()\n        is called.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        return self.buf\n", "src/lib/htmllib.py": "raise NotImplementedError(\"htmllib is not yet implemented in Skulpt\")\n", "src/lib/_threading_local.py": "raise NotImplementedError(\"_threading_local is not yet implemented in Skulpt\")\n", "src/lib/pyclbr.py": "raise NotImplementedError(\"pyclbr is not yet implemented in Skulpt\")\n", "src/lib/gettext.py": "raise NotImplementedError(\"gettext is not yet implemented in Skulpt\")\n", "src/lib/operator.js": "/*\n *  __author__: Isaac Dontje Lindell (i@isaacdontjelindell.com)\n *\n *  Implementation of the Python operator module.\n */\n\nvar $builtinmodule = function (name) {\n    var mod = {};\n\n    mod.lt = new Sk.builtin.func(function (a, b) {\n        return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'Lt'));\n    });\n    mod.__lt__ = mod.lt;\n\n    mod.le = new Sk.builtin.func(function (a, b) {\n        return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'LtE'));\n    });\n    mod.__le__ = mod.le;\n\n    mod.eq = new Sk.builtin.func(function (a, b) {\n        return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'Eq'));\n    });\n    mod.__eq__ = mod.eq;\n\n    mod.ne = new Sk.builtin.func(function (a, b) {\n        return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'NotEq'));\n    });\n    mod.__ne__ = mod.ne;\n\n    mod.ge = new Sk.builtin.func(function (a, b) {\n        return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'GtE'));\n    });\n    mod.__ge__ = mod.ge;\n\n    mod.gt = new Sk.builtin.func(function (a, b) {\n        return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'Gt'));\n    });\n    mod.__gt__ = mod.gt;\n\n    mod.not_ = new Sk.builtin.func(function (obj) {\n        throw new Sk.builtin.NotImplementedError(\"operator.not_() is not yet implemented in Skulpt\");\n    });\n\n    mod.truth = new Sk.builtin.func(function (obj) {\n        return Sk.builtin.bool(obj);\n    });\n\n    mod.is_ = new Sk.builtin.func(function (a, b) {\n        return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'Is'));\n    });\n\n    mod.is_not = new Sk.builtin.func(function (a, b) {\n        return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'IsNot'));\n    });\n\n    mod.abs = new Sk.builtin.func(function (obj) {\n        return Sk.misceval.callsim(Sk.builtin.abs, obj);\n    });\n    mod.__abs__ = mod.abs;\n\n    // The documentation says that operator.add() is defined for a and b numbers, but\n    // CPython (2.6) allows a and b to be other types (e.g. str)\n    mod.add = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.objectAdd(a, b);\n    });\n    mod.__add__ = mod.add;\n\n    mod.and_ = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.binary_op_(a, b, \"BitAnd\");\n    });\n    mod.__and__ = mod.and_;\n\n    mod.div = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.binary_op_(a, b, \"Div\");\n    });\n    mod.__div__ = mod.div;\n\n    mod.floordiv = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.binary_op_(a, b, \"FloorDiv\");\n    });\n    mod.__floordiv__ = mod.floordiv;\n\n    mod.index = new Sk.builtin.func(function (a) {\n        return new Sk.builtin.int_(Sk.misceval.asIndex(a));\n    });\n    mod.__index__ = mod.index;\n\n    // Note: Sk.abstr.numberUnaryOp(obj, 'Invert') looks for the function nb$invert() on obj.\n    // However, it doesn't look like that function has been implemented for any existing object types.\n    // I've gone ahead and created this function for completeness' sake, but expect any use of it to\n    // result in an error.\n    mod.inv = new Sk.builtin.func(function (obj) {\n        return Sk.abstr.numberUnaryOp(obj, 'Invert');\n    });\n    mod.__inv__ = mod.inv;\n    mod.invert = mod.inv;\n    mod.__invert__ = mod.inv;\n\n    mod.lshift = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.binary_op_(a, b, \"LShift\");\n    });\n    mod.__lshift__ = mod.lshift;\n\n    mod.mod = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.binary_op_(a, b, \"Mod\");\n    });\n    mod.__mod__ = mod.mod;\n\n    mod.divmod = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.binary_op_(a, b, \"DivMod\");\n    });\n    mod.__divmod__ = mod.divmod;\n\n    mod.mul = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.binary_op_(a, b, \"Mult\");\n    });\n    mod.__mul__ = mod.mul;\n\n    mod.neg = new Sk.builtin.func(function (obj) {\n        return Sk.abstr.objectNegative(obj);\n    });\n    mod.__neg__ = mod.neg;\n\n    mod.or_ = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.binary_op_(a, b, \"BitOr\");\n    });\n    mod.__or__ = mod.or_;\n\n    mod.pos = new Sk.builtin.func(function (obj) {\n        return Sk.abstr.objectPositive(obj);\n    });\n    mod.__pos__ = mod.pos;\n\n    mod.pow = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.binary_op_(a, b, \"Pow\");\n    });\n    mod.__pow__ = mod.pow;\n\n    mod.rshift = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.binary_op_(a, b, \"RShift\");\n    });\n    mod.__rshift__ = mod.rshift;\n\n    mod.sub = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.binary_op_(a, b, \"Sub\");\n    });\n    mod.__sub__ = mod.sub;\n\n    mod.truediv = mod.div;\n    mod.__truediv__ = mod.div;\n\n    mod.xor = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.binary_op_(a, b, \"BitXor\");\n    });\n    mod.__xor__ = mod.xor;\n\n    mod.concat = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.sequenceConcat(a, b);\n    });\n    mod.__concat__ = mod.concat;\n\n    mod.contains = new Sk.builtin.func(function (a, b) {\n        return Sk.builtin.bool(Sk.abstr.sequenceContains(a, b));\n    });\n    mod.__contains__ = mod.contains;\n\n    mod.countOf = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.sequenceGetCountOf(a, b);\n    });\n\n    mod.delitem = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.sequenceDelItem(a, b);\n    });\n    mod.__delitem__ = mod.delitem;\n\n    mod.getitem = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.sequenceGetItem(a, b);\n    });\n    mod.__getitem__ = mod.getitem;\n\n    mod.indexOf = new Sk.builtin.func(function (a, b) {\n        return Sk.abstr.sequenceGetIndexOf(a, b);\n    });\n\n    mod.setitem = new Sk.builtin.func(function (a, b, c) {\n        return Sk.abstr.sequenceSetItem(a, b, c);\n    });\n    mod.__setitem__ = mod.setitem;\n\n    return mod;\n};\n", "src/lib/wave.py": "raise NotImplementedError(\"wave is not yet implemented in Skulpt\")\n", "src/lib/rfc822.py": "raise NotImplementedError(\"rfc822 is not yet implemented in Skulpt\")\n", "src/lib/weakref.py": "raise NotImplementedError(\"weakref is not yet implemented in Skulpt\")\n", "src/lib/bisect.py": "raise NotImplementedError(\"bisect is not yet implemented in Skulpt\")\n", "src/lib/opcode.py": "raise NotImplementedError(\"opcode is not yet implemented in Skulpt\")\n", "src/lib/netrc.py": "raise NotImplementedError(\"netrc is not yet implemented in Skulpt\")\n", "src/lib/heapq.py": "raise NotImplementedError(\"heapq is not yet implemented in Skulpt\")\n", "src/lib/functools.py": "raise NotImplementedError(\"functools is not yet implemented in Skulpt\")\n", "src/lib/multifile.py": "raise NotImplementedError(\"multifile is not yet implemented in Skulpt\")\n", "src/lib/modulefinder.py": "raise NotImplementedError(\"modulefinder is not yet implemented in Skulpt\")\n", "src/lib/hashlib.py": "raise NotImplementedError(\"hashlib is not yet implemented in Skulpt\")\n", "src/lib/markupbase.py": "raise NotImplementedError(\"markupbase is not yet implemented in Skulpt\")\n", "src/lib/cgi.py": "raise NotImplementedError(\"cgi is not yet implemented in Skulpt\")\n", "src/lib/codeop.py": "raise NotImplementedError(\"codeop is not yet implemented in Skulpt\")\n", "src/lib/fnmatch.py": "raise NotImplementedError(\"fnmatch is not yet implemented in Skulpt\")\n", "src/lib/traceback.py": "raise NotImplementedError(\"traceback is not yet implemented in Skulpt\")\n", "src/lib/rexec.py": "raise NotImplementedError(\"rexec is not yet implemented in Skulpt\")\n", "src/lib/nturl2path.py": "raise NotImplementedError(\"nturl2path is not yet implemented in Skulpt\")\n", "src/lib/warnings.py": "raise NotImplementedError(\"warnings is not yet implemented in Skulpt\")\n", "src/lib/SimpleHTTPServer.py": "raise NotImplementedError(\"SimpleHTTPServer is not yet implemented in Skulpt\")\n", "src/lib/subprocess.py": "raise NotImplementedError(\"subprocess is not yet implemented in Skulpt\")\n", "src/lib/SimpleXMLRPCServer.py": "raise NotImplementedError(\"SimpleXMLRPCServer is not yet implemented in Skulpt\")\n", "src/lib/imputil.py": "raise NotImplementedError(\"imputil is not yet implemented in Skulpt\")\n", "src/lib/time.js": "/*\n implementation of the Python time package.\n\n notes:\n - struct_time is a structseq but structseq does not implement methods: 'n_fields', 'n_sequence_fields', 'n_unnamed_fields' yet\n\n ['__doc__', '__file__', '__name__', '__package__', 'accept2dyear', 'altzone', 'asctime', 'clock', 'ctime', 'daylight', 'gmtime', 'localtime', 'mktime', 'sleep', 'strftime', 'strptime', 'struct_time', 'time', 'timezone', 'tzname', 'tzset']\n */\n\nvar $builtinmodule = function (name) {\n    var mod = {};\n\n    mod.__file__ = \"/src/lib/time/__init__.js\";\n\n    mod.__package__ = Sk.builtin.none.none$;\n\n    var struct_time_fields = {\n        \"tm_year\": \"year, for example, 1993\", \n        \"tm_mon\": \"month of year, range [1, 12]\", \n        \"tm_mday\": \"day of month, range [1, 31]\", \n        \"tm_hour\": \"hours, range [0, 23]\", \n        \"tm_min\": \"minutes, range [0, 59]\", \n        \"tm_sec\": \"seconds, range [0, 61]\", \n        \"tm_wday\": \"day of week, range [0, 6], Monday is 0\", \n        \"tm_yday\": \"day of year, range [1, 366]\", \n        \"tm_isdst\": \"1 if summer time is in effect, 0 if not, and -1 if unknown\"\n    };\n\n    var struct_time_f = Sk.builtin.make_structseq('time', 'struct_time', struct_time_fields);\n\n    mod.struct_time = struct_time_f;\n\n    function check_struct_time(t) {\n        if (!(t instanceof struct_time_f)) {\n            throw new Sk.builtin.TypeError(\"Required argument 'struct_time' must be of type: 'struct_time'\");\n        }\n        var i;\n        var len = t.v.length;\n        var obj = t.v;\n        for (i = 0; i < len; ++i) {\n            if (!Sk.builtin.checkInt(obj[i])) {\n                throw new Sk.builtin.TypeError(\"struct_time may only contain integers\");\n            }\n        }\n        return true;\n    }\n\n    mod.time = new Sk.builtin.func(function () {\n        Sk.builtin.pyCheckArgs(\"time\", arguments, 0, 0);\n        var res = Date.now();\n        if (this.performance && this.performance.now)\n        {\n            res = res + performance.now() % 1;\n        }\n        return Sk.builtin.assk$(res / 1000, undefined);\n    });\n\n    // This is an experimental implementation of time.sleep(), using suspensions\n    mod.sleep = new Sk.builtin.func(function(delay) {\n        Sk.builtin.pyCheckArgs(\"sleep\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"delay\", \"float\", Sk.builtin.checkNumber(delay));\n\n        return new Sk.misceval.promiseToSuspension(new Promise(function(resolve) {\n            Sk.setTimeout(function() {\n                resolve(Sk.builtin.none.none$);\n            }, Sk.ffi.remapToJs(delay)*1000);\n        }));\n    });\n\n    function padLeft(str, l, c) {\n        var _str = str.toString();\n        return Array(l - _str.length + 1).join(c || \" \") + _str;\n    }\n\n    function isLeapYear(year) {\n        if((year & 3) != 0) return false;\n        return ((year % 100) != 0 || (year % 400) == 0);\n    }\n\n    function getDayOfYear(date,utc) {\n        utc = utc || false;\n        var dayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        var mn = utc ? date.getUTCMonth() : date.getMonth();\n        var dn = utc ? date.getUTCDate() : date.getDate();\n        var dayOfYear = dayCount[mn] + dn;\n        if(mn > 1 && isLeapYear(utc ? date.getUTCFullYear() : date.getFullYear())) dayOfYear++;\n        return dayOfYear;\n    }\n\n    function stdTimezoneOffset() {\n        var jan = new Date(2002, 0, 1);\n        var jul = new Date(2002, 6, 1);\n        return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n    }\n\n    function altTimezoneOffset() {\n        var jan = new Date(2002, 0, 1);\n        var jul = new Date(2002, 6, 1);\n        return Math.min(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n    }    \n\n    function dst(date) {\n        return date.getTimezoneOffset() < stdTimezoneOffset();\n    }\n\n    function timeZoneName(date) {\n        var i = /\\((.*)\\)/.exec(date.toString());\n        return i ? i[1] : \"UTC\";\n    }\n\n    function timeZoneNames() {\n        var jan = new Date(2002, 0, 1);\n        var jul = new Date(2002, 6, 1);     \n        if (dst(jan)) {\n            return [Sk.builtin.str(timeZoneName(jul)), Sk.builtin.str(timeZoneName(jan))];\n        } else {\n            return [Sk.builtin.str(timeZoneName(jan)), Sk.builtin.str(timeZoneName(jul))];\n        }\n    }\n\n    function date_to_struct_time(date, utc) {\n        utc = utc || false;\n        // y, m, d, hh, mm, ss, weekday, jday, dst\n        return new struct_time_f(\n            [\n                Sk.builtin.assk$(utc ? date.getUTCFullYear() : date.getFullYear()), \n                Sk.builtin.assk$((utc ? date.getUTCMonth() : date.getMonth()) + 1), // want January == 1\n                Sk.builtin.assk$(utc ? date.getUTCDate() : date.getDate()), \n                Sk.builtin.assk$(utc ? date.getUTCHours() : date.getHours()), \n                Sk.builtin.assk$(utc ? date.getUTCMinutes() : date.getMinutes()), \n                Sk.builtin.assk$(utc ? date.getUTCSeconds() : date.getSeconds()), \n                Sk.builtin.assk$(((utc ? date.getUTCDay() : date.getDay()) + 6) % 7), // Want Monday == 0\n                Sk.builtin.assk$(getDayOfYear(date, utc)), // Want January, 1 == 1\n                Sk.builtin.assk$(utc ? 0 : (dst(date) ? 1 : 0)) // 1 for DST /0 for non-DST /-1 for unknown\n            ]\n        );\n    }\n\n    function localtime_f(secs) {\n        Sk.builtin.pyCheckArgs(\"localtime\", arguments, 0, 1);\n        var d = new Date();\n        if (secs) {\n            Sk.builtin.pyCheckType(\"secs\", \"number\", Sk.builtin.checkNumber(secs));\n            var seconds = Sk.builtin.asnum$(secs);\n            d.setTime(seconds * 1000);\n        }\n        return date_to_struct_time(d);\n    }\n\n    mod.localtime = new Sk.builtin.func(localtime_f);\n\n    mod.gmtime = new Sk.builtin.func(function(secs) {\n        Sk.builtin.pyCheckArgs(\"localtime\", arguments, 0, 1);\n        var d = new Date();\n        if (secs) {\n            Sk.builtin.pyCheckType(\"secs\", \"number\", Sk.builtin.checkNumber(secs));\n            var seconds = Sk.builtin.asnum$(secs);\n            d.setTime(seconds * 1000);\n        }\n        return date_to_struct_time(d, true);\n    });\n\n    var monthnames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n    var daynames = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"];\n\n    function asctime_f(time) {\n        if (!time || Sk.builtin.checkNone(time))\n        {\n            time = localtime_f();\n        } else if (!(time instanceof struct_time_f)) {\n            time = new struct_time_f(time);\n        }\n        if (time instanceof Sk.builtin.tuple && time.v.length == 9)\n        {\n            // todo: test validity??\n            var parts = [];\n            parts.push(daynames[Sk.builtin.asnum$(time.v[6])]);\n            parts.push(monthnames[Sk.builtin.asnum$(time.v[1])-1]);  \n            parts.push(padLeft(Sk.builtin.asnum$(time.v[2]).toString(), 2, '0'));\n            parts.push(\n                padLeft(Sk.builtin.asnum$(time.v[3]).toString(), 2, '0') + \":\" +\n                padLeft(Sk.builtin.asnum$(time.v[4]).toString(), 2, '0') + \":\" +\n                padLeft(Sk.builtin.asnum$(time.v[5]).toString(), 2, '0')\n            );\n            parts.push(padLeft(Sk.builtin.asnum$(time.v[0]).toString(), 4, '0'));\n\n            return Sk.builtin.str(parts.join(\" \"));\n        }\n    }\n\n    mod.asctime = new Sk.builtin.func(asctime_f);\n\n    mod.ctime = new Sk.builtin.func(function(secs) {\n        return asctime_f(localtime_f(secs));\n    });\n\n    function mktime_f(time) {\n        if (time instanceof Sk.builtin.tuple && time.v.length == 9)\n        {\n            var d = new Date(Sk.builtin.asnum$(time.v[0]),\n                             Sk.builtin.asnum$(time.v[1])-1,\n                             Sk.builtin.asnum$(time.v[2]),\n                             Sk.builtin.asnum$(time.v[3]),\n                             Sk.builtin.asnum$(time.v[4]),\n                             Sk.builtin.asnum$(time.v[5]));\n            return Sk.builtin.assk$(d.getTime() / 1000, undefined);\n        } else {\n            throw new Sk.builtin.TypeError(\"mktime() requires a struct_time or 9-tuple\");\n        }\n    }\n\n    mod.mktime = new Sk.builtin.func(mktime_f);\n\n    /*\n    The offset of the local (non-DST) timezone, in seconds west of UTC (negative in most of Western Europe, \n    positive in the US, zero in the UK).\n    */\n    mod.timezone = new Sk.builtin.int_(stdTimezoneOffset() * 60);\n\n    /*\n    The offset of the local DST timezone, in seconds west of UTC, if one is defined. This is negative if the\n    local DST timezone is east of UTC (as in Western Europe, including the UK). Only use this if daylight is nonzero.\n    */\n    mod.altzone = new Sk.builtin.int_(altTimezoneOffset() * 60);\n\n    /*\n    Nonzero if a DST timezone is defined.\n    */\n    mod.daylight = new Sk.builtin.int_(dst(new Date()) ? 1 : 0);\n\n    /*\n    A tuple of two strings: the first is the name of the local non-DST timezone, the second is the name of the local \n    DST timezone. If no DST timezone is defined, the second string should not be used.\n    */\n    mod.tzname = Sk.builtin.tuple(timeZoneNames());\n\n    mod.accept2dyear = Sk.builtin.assk$(1, Sk.builtin.nmber.int$);\n\n    mod.clock = new Sk.builtin.func(function() {\n        var res = 0.0;\n        if (this.performance && this.performance.now)\n        {\n            res = performance.now() / 1000;\n        } else {\n            res = new Date().getTime() / 1000;\n        }\n        return new Sk.builtin.float_(res);\n    });\n\n    function strftime_f(format, t) {\n        var jsFormat;\n\n        Sk.builtin.pyCheckArgs(\"strftime\", arguments, 1, 2);\n        if (!Sk.builtin.checkString(format)) {\n            throw new Sk.builtin.TypeError(\"format must be a string\");\n        }\n        if (!t)\n        {\n            t = localtime_f();\n        } else if (!(t instanceof struct_time_f)) {\n            t = new struct_time_f(t);\n        }\n\n        check_struct_time(t);\n        \n        jsFormat = Sk.ffi.remapToJs(format);\n\n        return Sk.ffi.remapToPy(strftime(jsFormat, new Date(mktime_f(t).v*1000)));\n    }\n\n    mod.strftime = new Sk.builtin.func(strftime_f);\n\n    function tzset_f()\n    {\n        throw new Sk.builtin.NotImplementedError(\"time.tzset() is not yet implemented\");\n        Sk.builtin.pyCheckArgs(\"tzset\", arguments, 0, 0);\n    }\n\n    mod.tzset = new Sk.builtin.func(tzset_f);\n\n    function strptime_f(s, format)\n    {\n        Sk.builtin.pyCheckArgs(\"strptime\", arguments, 1, 2);\n        Sk.builtin.pyCheckType(\"string\", \"string\", Sk.builtin.checkString(s));\n        if (format !== undefined) {\n            Sk.builtin.pyCheckType(\"format\", \"string\", Sk.builtin.checkString(format));\n        } else {\n            format = new Sk.builtin.str(\"%a %b %d %H:%M:%S %Y\");\n        }\n\n        return date_to_struct_time(strptime(Sk.ffi.remapToJs(s), Sk.ffi.remapToJs(format), true));\n    }\n\n    mod.strptime = new Sk.builtin.func(strptime_f);\n\n    return mod;\n};\n", "src/lib/profile.py": "raise NotImplementedError(\"profile is not yet implemented in Skulpt\")\n", "src/lib/imghdr.py": "raise NotImplementedError(\"imghdr is not yet implemented in Skulpt\")\n", "src/lib/mimetools.py": "raise NotImplementedError(\"mimetools is not yet implemented in Skulpt\")\n", "src/lib/this.py": "raise NotImplementedError(\"this is not yet implemented in Skulpt\")\n", "src/lib/filecmp.py": "raise NotImplementedError(\"filecmp is not yet implemented in Skulpt\")\n", "src/lib/codecs.py": "raise NotImplementedError(\"codecs is not yet implemented in Skulpt\")\n", "src/lib/uu.py": "raise NotImplementedError(\"uu is not yet implemented in Skulpt\")\n", "src/lib/io.py": "raise NotImplementedError(\"io is not yet implemented in Skulpt\")\n", "src/lib/MimeWriter.py": "raise NotImplementedError(\"MimeWriter is not yet implemented in Skulpt\")\n", "src/lib/code.py": "raise NotImplementedError(\"code is not yet implemented in Skulpt\")\n", "src/lib/fileinput.py": "raise NotImplementedError(\"fileinput is not yet implemented in Skulpt\")\n", "src/lib/os.py": "raise NotImplementedError(\"os is not yet implemented in Skulpt\")\n", "src/lib/difflib.py": "raise NotImplementedError(\"difflib is not yet implemented in Skulpt\")\n", "src/lib/pydoc.py": "raise NotImplementedError(\"pydoc is not yet implemented in Skulpt\")\n", "src/lib/symbol.py": "raise NotImplementedError(\"symbol is not yet implemented in Skulpt\")\n", "src/lib/pydoc_topics.py": "raise NotImplementedError(\"pydoc_topics is not yet implemented in Skulpt\")\n", "src/lib/atexit.py": "raise NotImplementedError(\"atexit is not yet implemented in Skulpt\")\n", "src/lib/sgmllib.py": "raise NotImplementedError(\"sgmllib is not yet implemented in Skulpt\")\n", "src/lib/decimal.py": "raise NotImplementedError(\"decimal is not yet implemented in Skulpt\")\n", "src/lib/SocketServer.py": "raise NotImplementedError(\"SocketServer is not yet implemented in Skulpt\")\n", "src/lib/copy.py": "\"\"\"\nThis file was modified from CPython.\nCopyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n2011, 2012, 2013, 2014, 2015 Python Software Foundation; All Rights Reserved\n\"\"\"\nimport types\nclass Error(Exception):\n    pass\nerror = Error \nclass _EmptyClass:\n    pass\n\ndef copy(x):\n    cls = type(x)\n    if callable(x):\n        return x\n    copier = getattr(cls, \"__copy__\", None)\n    if copier:\n        return copier(x)\n    if cls in (type(None), int, float, bool, long, str, tuple, type):\n        return x\n    if (cls == list) or (cls == dict) or (cls == set) or (cls == slice):\n        return cls(x)\n    try:\n        getstate = getattr(x, \"__getstate__\", None)\n        setstate = getattr(x, \"__setstate__\", None)\n        initargs = getattr(x, \"__getinitargs__\", None)\n    except:\n        reductor = False\n    if getstate or setstate or initargs:\n        raise NotImplementedError(\"Skulpt does not yet support copying with user-defined __getstate__, __setstate__ or __getinitargs__()\")\n    reductor = getattr(x, \"__reduce_ex__\", None)\n    if reductor:\n        rv = reductor(4)\n    else:\n        reductor = getattr(x, \"__reduce__\", None)\n        if reductor:\n            rv = reductor()\n        elif str(cls)[1:6] == \"class\":\n            copier = _copy_inst\n            return copier(x)\n        else:\n            raise Error(\"un(shallow)copyable object of type %s\" % cls)\n    if isinstance(rv, str):\n        return x\n    return _reconstruct(x, rv, 0)\n\ndef _copy_inst(x):\n    if hasattr(x, '__copy__'):\n        return x.__copy__()\n    if hasattr(x, '__getinitargs__'):\n        args = x.__getinitargs__()\n        y = x.__class__(*args)\n    else:\n        y = _EmptyClass()\n        y.__class__ = x.__class__\n    if hasattr(x, '__getstate__'):\n        state = x.__getstate__()\n    else:\n        state = x.__dict__\n    if hasattr(y, '__setstate__'):\n        y.__setstate__(state)\n    else:\n        y.__dict__.update(state)\n    return y\n\nd = _deepcopy_dispatch = {}\n\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    if memo is None:\n        memo = {}\n    idx = id(x)\n    y = memo.get(idx, _nil)\n    if y is not _nil:\n        return y\n    cls = type(x)\n    try:\n        getstate = getattr(x, \"__getstate__\", None)\n        setstate = getattr(x, \"__setstate__\", None)\n        initargs = getattr(x, \"__getinitargs__\", None)\n    except:\n        reductor = False\n    if getstate or setstate or initargs:\n        raise NotImplementedError(\"Skulpt does not yet support copying with user-defined __getstate__, __setstate__ or __getinitargs__()\")\n    copier = _deepcopy_dispatch.get(cls)\n    if copier:\n        y = copier(x, memo)\n    elif str(cls)[1:6] == \"class\":\n        copier = _deepcopy_dispatch[\"InstanceType\"]\n        y = copier(x, memo)\n    else:\n        try:\n            issc = issubclass(cls, type)\n        except TypeError: # cls is not a class (old Boost; see SF #502085)\n            issc = 0\n        if issc:\n            y = _deepcopy_atomic(x, memo)\n        else:\n            copier = getattr(x, \"__deepcopy__\", None)\n            if copier:\n                y = copier(memo)\n            else:\n                reductor = getattr(x, \"__reduce_ex__\", None)\n                if reductor:\n                    rv = reductor(2)\n                else:\n                    reductor = getattr(x, \"__reduce__\", None)\n                    if reductor:\n                        rv = reductor()\n                    else:\n                        raise Error(\n                            \"un(deep)copyable object of type %s\" % cls)\n                y = _reconstruct(x, rv, 1, memo)\n    memo[idx] = y\n    _keep_alive(x, memo) # Make sure x lives at least as long as d\n    return y\n\ndef _deepcopy_atomic(x, memo):\n    return x\nd[type(None)] = _deepcopy_atomic\n# d[type(Ellipsis)] = _deepcopy_atomic\nd[type(NotImplemented)] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\n# d[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\n# try:\n# d[types.CodeType] = _deepcopy_atomic\n# except AttributeError:\n#   pass\nd[type] = _deepcopy_atomic\n# d[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\n# d[weakref.ref] = _deepcopy_atomic\n\ndef _deepcopy_list(x, memo):\n    y = []\n    memo[id(x)] = y\n    for a in x:\n        y.append(deepcopy(a, memo))\n    return y\nd[list] = _deepcopy_list\n\ndef _deepcopy_set(x, memo):\n    result = set([])  # make empty set\n    memo[id(x)] = result  # register this set in the memo for loop checking\n    for a in x:   # go through elements of set\n        result.add(deepcopy(a, memo))  # add the copied elements into the new set\n    return result # return the new set\nd[set] = _deepcopy_set\n\ndef _deepcopy_tuple(x, memo):\n    y = [deepcopy(a, memo) for a in x]\n    # We're not going to put the tuple in the memo, but it's still important we\n    # check for it, in case the tuple contains recursive mutable structures.\n    try:\n        return memo[id(x)]\n    except KeyError:\n        pass\n    for k, j in zip(x, y):\n        if k is not j:\n            y = tuple(y)\n            break\n    else:\n        y = x\n    return y\nd[tuple] = _deepcopy_tuple\n\ndef _deepcopy_dict(x, memo):\n    y = {}\n    memo[id(x)] = y\n    for key, value in x.items():\n        y[deepcopy(key, memo)] = deepcopy(value, memo)\n    return y\nd[dict] = _deepcopy_dict\n\ndef _deepcopy_method(x, memo): # Copy instance methods\n    y = type(x)(x.im_func, deepcopy(x.im_self, memo), x.im_class);\n    return y\nd[types.MethodType] = _deepcopy_method\n\ndef _deepcopy_inst(x, memo):\n    if hasattr(x, '__deepcopy__'):\n         return x.__deepcopy__(memo)\n    if hasattr(x, '__getinitargs__'):\n        args = x.__getinitargs__()\n        args = deepcopy(args, memo)\n        y = x.__class__(*args)\n    else:\n        y = _EmptyClass()\n        y.__class__ = x.__class__\n    memo[id(x)] = y\n    if hasattr(x, '__getstate__'):\n        state = x.__getstate__()\n    else:\n        state = x.__dict__\n    state = deepcopy(state, memo)\n    if hasattr(y, '__setstate__'):\n        y.__setstate__(state)\n    else:\n        y.__dict__.update(state)\n        return y\nd[\"InstanceType\"] = _deepcopy_inst\n\ndef _keep_alive(x, memo):\n    \"\"\"Keeps a reference to the object x in the memo.\n    Because we remember objects by their id, we have\n    to assure that possibly temporary objects are kept\n    alive by referencing them.\n    We store a reference at the id of the memo, which should\n    normally not be used unless someone tries to deepcopy\n    the memo itself...\n    \"\"\"\n    try:\n        memo[id(memo)].append(x)\n    except KeyError:\n        # aha, this is the first one :-)\n        memo[id(memo)]=[x]\n\ndef _reconstruct(x, info, deep, memo=None):\n    if isinstance(info, str):\n        return x\n    assert isinstance(info, tuple)\n    if memo is None:\n        memo = {}\n    n = len(info)\n    assert n in (2, 3, 4, 5)\n    callable, args = info[:2]\n    if n > 2:\n        state = info[2]\n    else:\n        state = None\n    if n > 3:\n        listiter = info[3]\n    else:\n        listiter = None\n    if n > 4:\n        dictiter = info[4]\n    else:\n        dictiter = None\n    if deep:\n        args = deepcopy(args, memo)\n    y = callable(*args)\n    memo[id(x)] = y\n\n    if state is not None:\n        if deep:\n            state = deepcopy(state, memo)\n        if hasattr(y, '__setstate__'):\n            y.__setstate__(state)\n        else:\n            if isinstance(state, tuple) and len(state) == 2:\n                state, slotstate = state\n            else:\n                slotstate = None\n            if state is not None:\n                y.__dict__.update(state)\n            if slotstate is not None:\n                for key, value in slotstate.items():\n                    setattr(y, key, value)\n\n    if listiter is not None:\n        for item in listiter:\n            if deep:\n                item = deepcopy(item, memo)\n            y.append(item)\n    if dictiter is not None:\n        for key, value in dictiter:\n            if deep:\n                key = deepcopy(key, memo)\n                value = deepcopy(value, memo)\n            y[key] = value\n    return y\n\ndel d\n\ndel types\n\n# Helper for instance creation without calling __init__\nclass _EmptyClass:\n    pass", "src/lib/genericpath.py": "raise NotImplementedError(\"genericpath is not yet implemented in Skulpt\")\n", "src/lib/linecache.py": "raise NotImplementedError(\"linecache is not yet implemented in Skulpt\")\n", "src/lib/audiodev.py": "raise NotImplementedError(\"audiodev is not yet implemented in Skulpt\")\n", "src/lib/types.py": "\"\"\"\nThis file was modified from CPython.\nCopyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n2011, 2012, 2013, 2014, 2015 Python Software Foundation; All Rights Reserved\n\"\"\"\n\"\"\"Define names for all type symbols known in the standard interpreter.\nTypes that are part of optional modules (e.g. array) are not listed.\n\"\"\"\nimport sys\n\n# Iterators in Python aren't a matter of type but of protocol.  A large\n# and changing number of builtin types implement *some* flavor of\n# iterator.  Don't check the type!  Use hasattr to check for both\n# \"__iter__\" and \"next\" attributes instead.\n\nNoneType = type(None)\nTypeType = type\nObjectType = object\nIntType = int\nLongType = long\nFloatType = float\nBooleanType = bool\ntry:\n    ComplexType = complex\nexcept NameError:\n    pass\nStringType = str\n\n# StringTypes is already outdated.  Instead of writing \"type(x) in\n# types.StringTypes\", you should use \"isinstance(x, basestring)\".  But\n# we keep around for compatibility with Python 2.2.\ntry:\n    UnicodeType = unicode\n    StringTypes = (StringType, UnicodeType)\nexcept NameError:\n    StringTypes = (StringType,)\n\nBufferType = buffer\n\nTupleType = tuple\nListType = list\nDictType = DictionaryType = dict\n\ndef _f(): pass\nFunctionType = type(_f)\nLambdaType = type(lambda: None)         # Same as FunctionType\nCodeType = type(_f.func_code)\n\ndef _g():\n    yield 1\nGeneratorType = type(_g())\n\nclass _C:\n    def _m(self): pass\nClassType = type(_C)\nUnboundMethodType = type(_C._m)         # Same as MethodType\n_x = _C()\nInstanceType = type(_x)\nMethodType = type(_x._m)\nBuiltinFunctionType = type(len)\nBuiltinMethodType = type([].append)     # Same as BuiltinFunctionType\n\nModuleType = type(sys)\nFileType = file\nXRangeType = xrange\n\n# try:\n#     raise TypeError\n# except TypeError:\n#     tb = sys.exc_info()[2]\n#     TracebackType = type(tb)\n#     FrameType = type(tb.tb_frame)\n#     del tb\n\nSliceType = slice\n# EllipsisType = type(Ellipsis)\n\n# DictProxyType = type(TypeType.__dict__)\nNotImplementedType = type(NotImplemented)\n\n# For Jython, the following two types are identical\n# GetSetDescriptorType = type(FunctionType.func_code)\n# MemberDescriptorType = type(FunctionType.func_globals)\n\ndel sys, _f, _g, _C, _x                           # Not for export\n__all__ = list(n for n in globals() if n[:1] != '_')\n", "src/lib/cory.py": "alpha = 0", "src/lib/sre.py": "raise NotImplementedError(\"sre is not yet implemented in Skulpt\")\n", "src/lib/mimetypes.py": "raise NotImplementedError(\"mimetypes is not yet implemented in Skulpt\")\n", "src/lib/xdrlib.py": "raise NotImplementedError(\"xdrlib is not yet implemented in Skulpt\")\n", "src/lib/colorsys.py": "raise NotImplementedError(\"colorsys is not yet implemented in Skulpt\")\n", "src/lib/UserList.py": "raise NotImplementedError(\"UserList is not yet implemented in Skulpt\")\n", "src/lib/numbers.py": "raise NotImplementedError(\"numbers is not yet implemented in Skulpt\")\n", "src/lib/_strptime.py": "raise NotImplementedError(\"_strptime is not yet implemented in Skulpt\")\n", "src/lib/_abcoll.py": "raise NotImplementedError(\"_abcoll is not yet implemented in Skulpt\")\n", "src/lib/dummy_threading.py": "raise NotImplementedError(\"dummy_threading is not yet implemented in Skulpt\")\n", "src/lib/anydbm.py": "raise NotImplementedError(\"anydbm is not yet implemented in Skulpt\")\n", "src/lib/ftplib.py": "raise NotImplementedError(\"ftplib is not yet implemented in Skulpt\")\n", "src/lib/chunk.py": "raise NotImplementedError(\"chunk is not yet implemented in Skulpt\")\n", "src/lib/mimify.py": "raise NotImplementedError(\"mimify is not yet implemented in Skulpt\")\n", "src/lib/optparse.py": "raise NotImplementedError(\"optparse is not yet implemented in Skulpt\")\n", "src/lib/pdb.py": "raise NotImplementedError(\"pdb is not yet implemented in Skulpt\")\n", "src/lib/repr.py": "raise NotImplementedError(\"repr is not yet implemented in Skulpt\")\n", "src/lib/Cookie.py": "raise NotImplementedError(\"Cookie is not yet implemented in Skulpt\")\n", "src/lib/threading.py": "raise NotImplementedError(\"threading is not yet implemented in Skulpt\")\n", "src/lib/platform.py": "raise NotImplementedError(\"platform is not yet implemented in Skulpt\")\n", "src/lib/pstats.py": "raise NotImplementedError(\"pstats is not yet implemented in Skulpt\")\n", "src/lib/glob.py": "raise NotImplementedError(\"glob is not yet implemented in Skulpt\")\n", "src/lib/urlparse.py": "raise NotImplementedError(\"urlparse is not yet implemented in Skulpt\")\n", "src/lib/copy_reg.py": "raise NotImplementedError(\"copy_reg is not yet implemented in Skulpt\")\n", "src/lib/quopri.py": "raise NotImplementedError(\"quopri is not yet implemented in Skulpt\")\n", "src/lib/symtable.py": "raise NotImplementedError(\"symtable is not yet implemented in Skulpt\")\n", "src/lib/fpformat.py": "raise NotImplementedError(\"fpformat is not yet implemented in Skulpt\")\n", "src/lib/pprint.py": "import json\n\ndef pprint(obj, indent=1):\n    print(json.dumps(obj))", "src/lib/_MozillaCookieJar.py": "raise NotImplementedError(\"_MozillaCookieJar is not yet implemented in Skulpt\")\n", "src/lib/calendar.py": "raise NotImplementedError(\"calendar is not yet implemented in Skulpt\")\n", "src/lib/inspect.py": "raise NotImplementedError(\"inspect is not yet implemented in Skulpt\")\n", "src/lib/poplib.py": "raise NotImplementedError(\"poplib is not yet implemented in Skulpt\")\n", "src/lib/binhex.py": "raise NotImplementedError(\"binhex is not yet implemented in Skulpt\")\n", "src/lib/plistlib.py": "raise NotImplementedError(\"plistlib is not yet implemented in Skulpt\")\n", "src/lib/pickletools.py": "raise NotImplementedError(\"pickletools is not yet implemented in Skulpt\")\n", "src/lib/pipes.py": "raise NotImplementedError(\"pipes is not yet implemented in Skulpt\")\n", "src/lib/site.py": "raise NotImplementedError(\"site is not yet implemented in Skulpt\")\n", "src/lib/string.js": "/*\n *  __author__: Isaac Dontje Lindell (i@isaacdontjelindell.com)\n *\n *  Implementation of the Python string module.\n */\n\n\nvar $builtinmodule = function (name) {\n    var mod = {};\n\n    mod.ascii_lowercase = Sk.builtin.str('abcdefghijklmnopqrstuvwxyz');\n    mod.ascii_uppercase = Sk.builtin.str('ABCDEFGHIJKLMNOPQRSTUVWXYZ');\n    mod.ascii_letters = Sk.builtin.str(mod.ascii_lowercase.v + mod.ascii_uppercase.v);\n\n    mod.lowercase = Sk.builtin.str('abcdefghijklmnopqrstuvwxyz');\n    mod.uppercase = Sk.builtin.str('ABCDEFGHIJKLMNOPQRSTUVWXYZ');\n    mod.letters = Sk.builtin.str(mod.lowercase.v + mod.uppercase.v);\n\n    mod.digits = Sk.builtin.str('0123456789', Sk.builtin.str);\n    mod.hexdigits = Sk.builtin.str('0123456789abcdefABCDEF');\n    mod.octdigits = Sk.builtin.str('01234567');\n\n    mod.punctuation = Sk.builtin.str('!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~');\n    mod.whitespace = Sk.builtin.str('\\t\\n\\x0b\\x0c\\r ');\n\n    /* Note: The docs for string.printable say that it's the concatenation of string.digits,\n     * string.letters, string.punctuation, and string.whitespace. The CPython interpreter\n     * outputs the whitespace characters in one order when string.whitespace is used, and a\n     * slightly different order when string.printable is used. I've elected to follow the\n     * behavior of CPython here rather than the spec. */\n    mod.printable = Sk.builtin.str(mod.digits.v + mod.letters.v + mod.punctuation.v + \" \\t\\n\\r\\x0b\\x0c\");\n\n\n    mod.split = new Sk.builtin.func(function (s, sep, maxsplit) {\n        return Sk.misceval.callsim(Sk.builtin.str.prototype['split'], s, sep, maxsplit);\n    });\n\n    /* Return a copy of word with only its first character capitalized. */\n    mod.capitalize = new Sk.builtin.func(function (word) {\n        return Sk.misceval.callsim(Sk.builtin.str.prototype['capitalize'], word);\n    });\n\n    /* Concatenate a list or tuple of words with intervening occurrences\n     * of sep. The default value for sep is a single space character. */\n    mod.join = new Sk.builtin.func(function (words, sep) {\n        if (sep === undefined) {\n            sep = Sk.builtin.str(' ');\n        }\n        return Sk.misceval.callsim(Sk.builtin.str.prototype['join'], sep, words);\n    });\n\n\n    /* Split the argument into words using split(), capitalize each word\n     * using capitalize(), and join the capitalized words using join().\n     * Note that this replaces runs of whitespace characters by a single\n     * space, and removes leading and trailing whitespace. */\n    mod.capwords = new Sk.builtin.func(function (s, sep) {\n        Sk.builtin.pyCheckArgs('capwords', arguments, 1, 2);\n        if (!Sk.builtin.checkString(s)) {\n            throw new Sk.builtin.TypeError(\"s must be a string\");\n        }\n        if (sep === undefined) {\n            sep = Sk.builtin.str(' ');\n        }\n        if (!Sk.builtin.checkString(sep)) {\n            throw new Sk.builtin.TypeError(\"sep must be a string\");\n        }\n\n        var words = Sk.misceval.callsim(mod.split, s, sep);\n        var capWords = [];\n        for (var i = 0; i < words.v.length; i++) {\n            var word = Sk.builtin.list.prototype['list_subscript_'].call(words, i);\n            var cap = Sk.misceval.callsim(mod.capitalize, word);\n            capWords.push(cap);\n        }\n\n        return Sk.misceval.callsim(mod.join, new Sk.builtin.list(capWords), sep);\n    });\n\n\n    return mod;\n};\n", "src/lib/telnetlib.py": "raise NotImplementedError(\"telnetlib is not yet implemented in Skulpt\")\n", "src/lib/_LWPCookieJar.py": "raise NotImplementedError(\"_LWPCookieJar is not yet implemented in Skulpt\")\n", "src/lib/processing.js": "/*\n  Skulpt Processing\n\n  Testing/debugging:\n\n  ProcessingJS from Skulpt:\n  Sk.misceval.callsim(Sk.globals.processing.$d.PShapeSVG, \n      new Sk.builtin.str(\"string\"), \n      new Sk.builtin.str(\"bot1.svg\"))\n\n  ProcessingJS direct:\n  p = Processing.instances[0]\n  p.PShapeSVG(\"string\", \"bot1.svg\")\n*/\n\nvar $builtinmodule = function (name) {\n    var imageClass;\n    var colorClass;\n    var screenClass;\n    var environmentClass;\n    var keyboardClass;\n    var mouseClass;\n    var vectorClass\n\n    var mod = {};\n    var imList = [];\n    var looping = true;\n    var instance = null;\n\n    // We need this to store a reference to the actual processing object which is not created\n    // until the run function is called.  Even then the processing object is passed by the\n    // processing-js sytem as a parameter to the sketchProc function.  Why not set it to None here\n    //\n\n    // See:  http://processingjs.org/reference/\n\n    mod.processing = null;\n    mod.p = null;\n\n    mod.X = new Sk.builtin.int_(0);\n    mod.Y = new Sk.builtin.int_(1);\n    mod.Z = new Sk.builtin.int_(2);\n\n    mod.R = new Sk.builtin.int_( 3);\n    mod.G = new Sk.builtin.int_( 4);\n    mod.B = new Sk.builtin.int_( 5);\n    mod.A = new Sk.builtin.int_( 6);\n    \n    mod.U = new Sk.builtin.int_( 7);\n    mod.V = new Sk.builtin.int_( 8);\n    \n    mod.NX = new Sk.builtin.int_( 9);\n    mod.NY = new Sk.builtin.int_( 10);\n    mod.NZ = new Sk.builtin.int_( 11);\n    \n    mod.EDGE = new Sk.builtin.int_( 12);\n    \n    // Stroke\n    mod.SR = new Sk.builtin.int_( 13);\n    mod.SG = new Sk.builtin.int_( 14);\n    mod.SB = new Sk.builtin.int_( 15);\n    mod.SA = new Sk.builtin.int_( 16);\n    \n    mod.SW = new Sk.builtin.int_( 17);\n    \n    // Transformations (2D and 3D)\n    mod.TX = new Sk.builtin.int_( 18);\n    mod.TY = new Sk.builtin.int_( 19);\n    mod.TZ = new Sk.builtin.int_( 20);\n    \n    mod.VX = new Sk.builtin.int_( 21);\n    mod.VY = new Sk.builtin.int_( 22);\n    mod.VZ = new Sk.builtin.int_( 23);\n    mod.VW = new Sk.builtin.int_( 24);\n    \n    // Material properties\n    mod.AR = new Sk.builtin.int_( 25);\n    mod.AG = new Sk.builtin.int_( 26);\n    mod.AB = new Sk.builtin.int_( 27);\n    \n    mod.DR = new Sk.builtin.int_( 3);\n    mod.DG = new Sk.builtin.int_( 4);\n    mod.DB = new Sk.builtin.int_( 5);\n    mod.DA = new Sk.builtin.int_( 6);\n    \n    mod.SPR = new Sk.builtin.int_( 28);\n    mod.SPG = new Sk.builtin.int_( 29);\n    mod.SPB = new Sk.builtin.int_( 30);\n    \n    mod.SHINE = new Sk.builtin.int_( 31);\n    \n    mod.ER = new Sk.builtin.int_( 32);\n    mod.EG = new Sk.builtin.int_( 33);\n    mod.EB = new Sk.builtin.int_( 34);\n    \n    mod.BEEN_LIT = new Sk.builtin.int_( 35);\n    \n    mod.VERTEX_FIELD_COUNT = new Sk.builtin.int_( 36);\n    \n    // Shape drawing modes\n    mod.CENTER = new Sk.builtin.int_(3);\n    mod.RADIUS = new Sk.builtin.int_(2);\n    mod.CORNERS = new Sk.builtin.int_(1);\n    mod.CORNER = new Sk.builtin.int_(0);\n    mod.DIAMETER = new Sk.builtin.int_(3);\n    \n    // Text vertical alignment modes\n    // Default vertical alignment for text placement\n    mod.BASELINE = new Sk.builtin.int_( 0);\n    // Align text to the top\n    mod.TOP = new Sk.builtin.int_(      101);\n    // Align text from the bottom, using the baseline\n    mod.BOTTOM = new Sk.builtin.int_(   102);\n    \n    // UV Texture coordinate modes\n    mod.NORMAL = new Sk.builtin.int_(     1);\n    mod.NORMALIZED = new Sk.builtin.int_( 1);\n    mod.IMAGE = new Sk.builtin.int_(      2);\n    \n    // Text placement modes\n    mod.MODEL = new Sk.builtin.int_( 4);\n    mod.SHAPE = new Sk.builtin.int_( 5);\n    \n    // Lighting modes\n    mod.AMBIENT = new Sk.builtin.int_(     0);\n    mod.DIRECTIONAL = new Sk.builtin.int_( 1);\n    //POINT:     2, Shared with Shape constant\n    mod.SPOT = new Sk.builtin.int_(        3);\n\n    // Color modes\n    mod.RGB = new Sk.builtin.int_(1);\n    mod.ARGB = new Sk.builtin.int_(2);\n    mod.HSB = new Sk.builtin.int_(3);\n    mod.ALPHA = new Sk.builtin.int_(4);\n    mod.CMYK = new Sk.builtin.int_(5);\n    \n    // Image file types\n    mod.TIFF = new Sk.builtin.int_(0);\n    mod.TARGA = new Sk.builtin.int_(1);\n    mod.JPEG = new Sk.builtin.int_(2);\n    mod.GIF = new Sk.builtin.int_(3);\n\n    // Stroke modes\n    mod.MITER = new Sk.builtin.str(\"miter\");\n    mod.BEVEL = new Sk.builtin.str(\"bevel\");\n    mod.ROUND = new Sk.builtin.str(\"round\");\n    mod.SQUARE = new Sk.builtin.str(\"butt\");\n    mod.PROJECT = new Sk.builtin.str(\"square\");\n\n    // Renderer modes\n    mod.P2D = new Sk.builtin.int_(1);\n    mod.JAVA2D = new Sk.builtin.int_(1);\n    mod.WEBGL = new Sk.builtin.int_(2);\n    mod.P3D = new Sk.builtin.int_(2);\n    mod.OPENGL = new Sk.builtin.int_(2);\n    mod.PDF = new Sk.builtin.int_(0);\n    mod.DXF  = new Sk.builtin.int_(0);\n\n    // Platform IDs\n    mod.OTHER = new Sk.builtin.int_(   0);\n    mod.WINDOWS = new Sk.builtin.int_( 1);\n    mod.MAXOSX = new Sk.builtin.int_(  2);\n    mod.LINUX = new Sk.builtin.int_(   3);\n    \n    mod.EPSILON = new Sk.builtin.float_( 0.0001);\n\n    mod.MAX_FLOAT = new Sk.builtin.float_(  3.4028235e+38);\n    mod.MIN_FLOAT = new Sk.builtin.float_( -3.4028235e+38);\n    mod.MAX_INT = new Sk.builtin.int_(    2147483647);\n    mod.MIN_INT = new Sk.builtin.int_(   -2147483648);\n    \n    // Constants\n    mod.HALF_PI = new Sk.builtin.float_(Math.PI / 2.0);\n    mod.THIRD_PI = new Sk.builtin.float_(Math.PI / 3.0);\n    mod.PI = new Sk.builtin.float_(Math.PI);\n    mod.TWO_PI = new Sk.builtin.float_(Math.PI * 2.0);\n    mod.TAU = new Sk.builtin.float_(Math.PI * 2.0);\n    mod.QUARTER_PI = new Sk.builtin.float_(Math.PI / 4.0);\n\n    mod.DEG_TO_RAD = new Sk.builtin.float_( Math.PI / 180);\n    mod.RAD_TO_DEG = new Sk.builtin.float_( 180 / Math.PI);\n\n    mod.WHITESPACE = Sk.builtin.str(\" \\t\\n\\r\\f\\u00A0\");\n    // Shape modes\n    mod.POINT = new Sk.builtin.int_(2);\n    mod.POINTS = new Sk.builtin.int_(2);\n    mod.LINE = new Sk.builtin.int_(4);\n    mod.LINES = new Sk.builtin.int_(4);\n    mod.TRIANGLE = new Sk.builtin.int_(8);\n    mod.TRIANGLES = new Sk.builtin.int_(9);\n    mod.TRIANGLE_FAN = new Sk.builtin.int_(11);\n    mod.TRIANGLE_STRIP = new Sk.builtin.int_(10);\n    mod.QUAD = new Sk.builtin.int_(16);\n    mod.QUADS = new Sk.builtin.int_(16);\n    mod.QUAD_STRIP = new Sk.builtin.int_(17);\n    mod.POLYGON = new Sk.builtin.int_(20);\n\n    mod.PATH = new Sk.builtin.int_(21);\n    mod.RECT = new Sk.builtin.int_(30);\n    mod.ELLIPSE = new Sk.builtin.int_(31);\n    mod.ARC = new Sk.builtin.int_(32);\n    mod.SPHERE = new Sk.builtin.int_(40);\n    mod.BOX = new Sk.builtin.int_(41);\n\n    mod.GROUP = new Sk.builtin.int_(          0);\n    mod.PRIMITIVE = new Sk.builtin.int_(      1);\n    //PATH:         21, // shared with Shape PATH\n    mod.GEOMETRY = new Sk.builtin.int_(       3);\n    \n    // Shape Vertex\n    mod.VERTEX = new Sk.builtin.int_(        0);\n    mod.BEZIER_VERTEX = new Sk.builtin.int_( 1);\n    mod.CURVE_VERTEX = new Sk.builtin.int_(  2);\n    mod.BREAK = new Sk.builtin.int_(         3);\n    mod.CLOSESHAPE = new Sk.builtin.int_(    4);\n    \n    // Blend modes\n    mod.REPLACE    = new Sk.builtin.int_(0);\n    mod.BLEND      = new Sk.builtin.int_(1 << 0);\n    mod.ADD        = new Sk.builtin.int_(1 << 1);\n    mod.SUBTRACT   = new Sk.builtin.int_(1 << 2);\n    mod.LIGHTEST   = new Sk.builtin.int_(1 << 3);\n    mod.DARKEST    = new Sk.builtin.int_(1 << 4);\n    mod.DIFFERENCE = new Sk.builtin.int_(1 << 5);\n    mod.EXCLUSION  = new Sk.builtin.int_(1 << 6);\n    mod.MULTIPLY   = new Sk.builtin.int_(1 << 7);\n    mod.SCREEN     = new Sk.builtin.int_(1 << 8);\n    mod.OVERLAY    = new Sk.builtin.int_(1 << 9);\n    mod.HARD_LIGHT = new Sk.builtin.int_(1 << 10);\n    mod.SOFT_LIGHT = new Sk.builtin.int_(1 << 11);\n    mod.DODGE      = new Sk.builtin.int_(1 << 12);\n    mod.BURN       = new Sk.builtin.int_(1 << 13);\n\n    // Color component bit masks\n    mod.ALPHA_MASK = new Sk.builtin.int_( 0xff000000);\n    mod.RED_MASK = new Sk.builtin.int_(   0x00ff0000);\n    mod.GREEN_MASK = new Sk.builtin.int_( 0x0000ff00);\n    mod.BLUE_MASK = new Sk.builtin.int_(  0x000000ff);\n    \n    // Projection matrices\n    mod.CUSTOM = new Sk.builtin.int_(       0);\n    mod.ORTHOGRAPHIC = new Sk.builtin.int_( 2);\n    mod.PERSPECTIVE = new Sk.builtin.int_(  3);\n    \n    // Cursors\n    mod.ARROW = new Sk.builtin.str(\"default\");\n    mod.CROSS = new Sk.builtin.str(\"crosshair\");\n    mod.HAND = new Sk.builtin.str(\"pointer\");\n    mod.MOVE = new Sk.builtin.str(\"move\");\n    mod.TEXT = new Sk.builtin.str(\"text\");\n    mod.WAIT = new Sk.builtin.str(\"wait\");\n    mod.NOCURSOR = Sk.builtin.assk$(\"url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto\", Sk.builtin.nmber.str);\n\n    // Hints\n    mod.DISABLE_OPENGL_2X_SMOOTH = new Sk.builtin.int_(1);\n    mod.ENABLE_OPENGL_2X_SMOOTH = new Sk.builtin.int_(-1);\n    mod.ENABLE_OPENGL_4X_SMOOTH = new Sk.builtin.int_(2);\n    mod.ENABLE_NATIVE_FONTS = new Sk.builtin.int_(3);\n    mod.DISABLE_DEPTH_TEST = new Sk.builtin.int_(4);\n    mod.ENABLE_DEPTH_TEST = new Sk.builtin.int_(-4);\n    mod.ENABLE_DEPTH_SORT = new Sk.builtin.int_(5);\n    mod.DISABLE_DEPTH_SORT = new Sk.builtin.int_(-5);\n    mod.DISABLE_OPENGL_ERROR_REPORT = new Sk.builtin.int_(6);\n    mod.ENABLE_OPENGL_ERROR_REPORT = new Sk.builtin.int_(-6);\n    mod.ENABLE_ACCURATE_TEXTURES = new Sk.builtin.int_(7);\n    mod.DISABLE_ACCURATE_TEXTURES = new Sk.builtin.int_(-7);\n    mod.HINT_COUNT = new Sk.builtin.int_(10);\n\n    // Shape closing modes\n    mod.OPEN =  new Sk.builtin.int_(1);\n    mod.CLOSE = new Sk.builtin.int_(2);\n\n    // Filter/convert types\n    mod.BLUR = new Sk.builtin.int_(11);\n    mod.GRAY = new Sk.builtin.int_(12);\n    mod.INVERT = new Sk.builtin.int_(13);\n    mod.OPAQUE = new Sk.builtin.int_(14);\n    mod.POSTERIZE = new Sk.builtin.int_(15);\n    mod.THRESHOLD = new Sk.builtin.int_(16);\n    mod.ERODE = new Sk.builtin.int_(17);\n    mod.DILATE = new Sk.builtin.int_(18);\n\n    // Both key and keyCode will be equal to these values\n    mod.BACKSPACE = new Sk.builtin.int_( 8);\n    mod.TAB = new Sk.builtin.int_(9);\n    mod.ENTER = new Sk.builtin.int_(10);\n    mod.RETURN = new Sk.builtin.int_(13);\n    mod.ESC = new Sk.builtin.int_(27);\n    mod.DELETE = new Sk.builtin.int_(127);\n    mod.CODED = new Sk.builtin.int_(0xffff);\n\n    // p.key will be CODED and p.keyCode will be this value\n    mod.SHIFT = new Sk.builtin.int_(16);\n    mod.CONTROL = new Sk.builtin.int_(17);\n    mod.ALT = new Sk.builtin.int_(18);\n    mod.CAPSLK = new Sk.builtin.int_(20);\n    mod.PGUP = new Sk.builtin.int_(33);\n    mod.PGDN = new Sk.builtin.int_(34);\n    mod.END = new Sk.builtin.int_(35);\n    mod.HOME = new Sk.builtin.int_(36);\n    mod.LEFT = new Sk.builtin.int_(37);\n    mod.UP = new Sk.builtin.int_(38);\n    mod.RIGHT = new Sk.builtin.int_(39);\n    mod.DOWN = new Sk.builtin.int_(40);\n    mod.F1 = new Sk.builtin.int_(112);\n    mod.F2 = new Sk.builtin.int_(113);\n    mod.F3 = new Sk.builtin.int_(114);\n    mod.F4 = new Sk.builtin.int_(115);\n    mod.F5 = new Sk.builtin.int_(116);\n    mod.F6 = new Sk.builtin.int_(117);\n    mod.F7 = new Sk.builtin.int_(118);\n    mod.F8 = new Sk.builtin.int_(119);\n    mod.F9 = new Sk.builtin.int_(120);\n    mod.F10 = new Sk.builtin.int_(121);\n    mod.F11 = new Sk.builtin.int_(122);\n    mod.F12 = new Sk.builtin.int_(123);\n    mod.NUMLK = new Sk.builtin.int_(144);\n    mod.META = new Sk.builtin.int_(157);\n    mod.INSERT = new Sk.builtin.int_(155);\n\n    // PJS defined constants\n    mod.SINCOS_LENGTH = new Sk.builtin.int_(720);\n    mod.PRECISIONB = new Sk.builtin.int_(15);\n    mod.PRECISIONF = new Sk.builtin.int_(1 << 15);\n    mod.PREC_MAXVAL = new Sk.builtin.int_((1 << 15) - 1);\n    mod.PREC_ALPHA_SHIFT = new Sk.builtin.int_(24 - 15);\n    mod.PREC_RED_SHIFT = new Sk.builtin.int_(16 - 15);\n    mod.NORMAL_MODE_AUTO = new Sk.builtin.int_(0);\n    mod.NORMAL_MODE_SHAPE = new Sk.builtin.int_(1);\n    mod.NORMAL_MODE_VERTEX = new Sk.builtin.int_(2);\n    mod.MAX_LIGHTS = new Sk.builtin.int_(8);\n\n    // 2D - Primitives\n    mod.line = new Sk.builtin.func(function (x1, y1, x2, y2) {\n        mod.processing.line(x1.v, y1.v, x2.v, y2.v);\n    });\n\n    mod.ellipse = new Sk.builtin.func(function (x, y, r1, r2) {\n        mod.processing.ellipse(x.v, y.v, r1.v, r2.v);\n\n    });\n\n    mod.text = new Sk.builtin.func(function (theText, x, y) {\n        mod.processing.text(theText.v, x.v, y.v);\n    });\n\n    mod.point = new Sk.builtin.func(function (x1, y1) {\n        mod.processing.point(x1.v, y1.v);\n    });\n\n    mod.arc = new Sk.builtin.func(function (x, y, width, height, start, stop) {\n        mod.processing.arc(x.v, y.v, width.v, height.v, start.v, stop.v);\n    });\n\n    mod.quad = new Sk.builtin.func(function (x1, y1, x2, y2, x3, y3, x4, y4) {\n        mod.processing.quad(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v, x4.v, y4.v);\n    });\n\n    mod.rect = new Sk.builtin.func(function (x, y, width, height, radius) {\n        var rad;\n        if (typeof(radius) === \"undefined\") {\n            mod.processing.rect(x.v, y.v, width.v, height.v);\n        } else {\n            mod.processing.rect(x.v, y.v, width.v, height.v, radius.v);\n        }\n    });\n\n    mod.triangle = new Sk.builtin.func(function (x1, y1, x2, y2, x3, y3) {\n        mod.processing.triangle(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v);\n    });\n\n    mod.bezier = new Sk.builtin.func(function (x1, y1, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n        if (typeof(a7) === \"undefined\") {\n\t    // bezier(x1, y1, cx1, cy1, cx2, cy2,  x2,  y2);\n            mod.processing.bezier(x1.v, y1.v, a1.v, a2.v, a3.v, a4.v, a5.v, a6.v);\n\t} else {\n\t    // bezier(x1, y1,  z1, cx1, cy1, cz1, cx2, cy2, cz2, x2, y2, z2);\n            mod.processing.bezier(x1.v, y1.v, a1.v, a2.v, a3.v, a4.v, a5.v, a6.v, a7.v, a8.v, a9.v, a10.v);\n\t}\n    });\n\n    mod.alpha = new Sk.builtin.func(function (r, g, b) {\n        // r will be either:\n        //      a number in which case the fill will be grayscale\n        //      a color object\n        // g, and b may be undefined.  If they hold values it will\n        // be assumed that we have an r,g,b color tuple\n        if (typeof(g) === \"undefined\") {\n            return new Sk.builtin.float_(mod.processing.alpha(r.v));\n        } else if (typeof(b) === \"undefined\") {\n            return new Sk.builtin.float_(mod.processing.alpha(r.v, g.v));\n        } else {\n            return new Sk.builtin.float_(mod.processing.alpha(r.v, g.v, b.v));\n\t}\n    });\n\n    mod.ambient = new Sk.builtin.func(function (r, g, b) {\n\t// ambient(gray)\n\t// ambient(red, green blue)\n        // r will be either:\n        //      a number in which case the fill will be grayscale\n        //      a color object\n        // g, and b may be undefined.  If they hold values it will\n        // be assumed that we have an r,g,b color tuple\n        if (typeof(g) === \"undefined\") {\n            mod.processing.ambient(r.v);\n        } else if (typeof(b) === \"undefined\") {\n            mod.processing.ambient(r.v, g.v);\n        } else {\n            mod.processing.ambient(r.v, g.v, b.v);\n\t}\n    });\n\n    mod.ambientLight = new Sk.builtin.func(function (v1, v2, v3, x, y, z) {\n\t// ambientLight(v1,v2,v3)\n\t// ambientLight(v1,v2,v3,x,y,z)\n        if (typeof(x) === \"undefined\") {\n            mod.processing.ambientLight(v1.v, v2.v, v3.v);\n        } else if (typeof(y) === \"undefined\") {\n            mod.processing.ambientLight(v1.v, v2.v, v3.v, x.v);\n        } else if (typeof(z) === \"undefined\") {\n            mod.processing.ambientLight(v1.v, v2.v, v3.v, x.v, y.v);\n        } else {\n            mod.processing.ambientLight(v1.v, v2.v, v3.v, x.v, y.v, z.v);\n\t}\n    });\n\n    mod.beginCamera = new Sk.builtin.func(function () {\n\tmod.processing.beginCamera();\n    });\n\n    mod.beginShape = new Sk.builtin.func(function (mode) {\n        if (typeof(mode) === \"undefined\") {\n            mode = mod.POLYGON;\n        }\n        mod.processing.beginShape(mode.v);\n    });\n\n    mod.bezierDetail = new Sk.builtin.func(function (resolution) {\n\t// Sets the resolution at which Beziers display. The default\n\t// value is 20. This function is only useful when using the\n\t// P3D or OPENGL renderer as the default (JAVA2D) renderer\n\t// does not use this information.\n        if (typeof(resolution) !== \"undefined\") {\n            resolution = resolution.v;\n        } else {\n            resolution = 20;\n\t}\n        mod.processing.bezierDetail(resolution);\n    });\n\n    mod.bezierPoint = new Sk.builtin.func(function (a,b,c,d,t) {\n        mod.processing.bezierPoint(a.v,b.v,c.v,d.v,t.v);\n    });\n\n    mod.bezierTangent = new Sk.builtin.func(function (a,b,c,d,t) {\n\tmod.processing.bezierTangent(a.v,b.v,c.v,d.v,t.v);\n    });\n\n    mod.bezierVertex = new Sk.builtin.func(function (v1, v2, v3, v4, v5, v6,\n\t\t\t\t\t\t    v7, v8, v9) {\n\t// bezierVertex(cx1, cy1, cx2, cy2,   x,   y)\n\t// bezierVertex(cx1, cy1, cz1, cx2, cy2, cz2, x, y, z)\n        if (typeof(v7) === \"undefined\") {\n\t    mod.processing.bezierVertex(v1.v, v2.v, v3.v, v4.v, v5.v, v6.v);\n\t} else if (typeof(v8) === \"undefined\") {\n\t    mod.processing.bezierVertex(v1.v, v2.v, v3.v, v4.v, v5.v, v6.v,\n\t\t\t\t\tv7.v);\n\t} else if (typeof(v9) === \"undefined\") {\n\t    mod.processing.bezierVertex(v1.v, v2.v, v3.v, v4.v, v5.v, v6.v,\n\t\t\t\t\tv7.v, v8.v);\n\t} else {\n\t    mod.processing.bezierVertex(v1.v, v2.v, v3.v, v4.v, v5.v, v6.v,\n\t\t\t\t\tv7.v, v8.v, v9.v);\n\t}\n    });\n\n    mod.blend = new Sk.builtin.func(function (v1, v2, v3, v4, v5,\n\t\t\t\t\t      v6, v7, v8, v9, v10) {\n\tif (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n\t    // blend(x,     y,width,height,dx,    dy,dwidth,dheight,MODE)\n\t    mod.processing.blend(v1.v, v2.v, v3.v, v4.v, v5.v,\n\t\t\t\t v6.v, v7.v, v8.v, v9.v);\n\t} else {\n\t    // blend(srcImg,x,y,    width, height,dx,dy,    dwidth, dheight,MODE)\n\t    mod.processing.blend(v1.v, v2.v, v3.v, v4.v, v5.v,\n\t\t\t\t v6.v, v7.v, v8.v, v9.v, v10.v);\n\t}\n    });\n\n    mod.blendColor = new Sk.builtin.func(function (c1, c2, mode) {\n\t// blendColor(c1,c2,MODE)\n        var c = Sk.misceval.callsim(mod.color,\n\t\t\t\t    new Sk.builtin.int_(0),\n\t\t\t\t    new Sk.builtin.int_(0),\n\t\t\t\t    new Sk.builtin.int_(0));\n\tc.v = mod.processing.blendColor(c1.v, c2.v, mode.v);\n\treturn c;\n    });\n\n    mod.brightness = new Sk.builtin.func(function (r, g, b) {\n        if (typeof(g) === \"undefined\") {\n\t    return new Sk.builtin.float_(mod.processing.brightness(r.v));\n        } else if (typeof(b) === \"undefined\") {\n\t    return new Sk.builtin.float_(mod.processing.brightness(r.v, g.v));\n        } else {\n\t    return new Sk.builtin.float_(mod.processing.brightness(r.v, g.v, b.v));\n\t}\n    });\n\n    mod.camera = new Sk.builtin.func(function (eyeX, eyeY, eyeZ,\n\t\t\t\t\t       centerX, centerY, centerZ,\n\t\t\t\t\t       upX, upY, upZ) {\n\t// camera()\n\t// camera(eyeX, eyeY, eyeZ,centerX, centerY, centerZ,upX, upY, upZ)\n        if (typeof(eyeX) === \"undefined\") {\n\t    mod.processing.camera();\n\t} else {\n\t    mod.processing.camera(eyeX.v, eyeY.v, eyeZ.v,\n\t\t\t\t  centerX.v, centerY.v, centerZ.v,\n\t\t\t\t  upX.v, upY.v, upZ.v);\n\t}\n    });\n\n    mod.constrain = new Sk.builtin.func(function (value, min, max) {\n\treturn new Sk.builtin.float_(mod.processing.constrain(value.v, min.v, max.v));\n    });\n\n    mod.copy = new Sk.builtin.func(function (v1, v2, v3, v4, v5,\n\t\t\t\t\t      v6, v7, v8, v9) {\n\tif (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n\t    // copy(x,     y,width,height,dx,    dy,dwidth,dheight)\n\t    mod.processing.copy(v1.v, v2.v, v3.v, v4.v, v5.v,\n\t\t\t\tv6.v, v7.v, v8.v);\n\t} else {\n\t    // copy(srcImg,x,y,    width, height,dx,dy,    dwidth, dheight)\n\t    mod.processing.copy(v1.v, v2.v, v3.v, v4.v, v5.v,\n\t\t\t\tv6.v, v7.v, v8.v, v9.v);\n\t}\n    });\n\n    mod.createFont = new Sk.builtin.func(function (name, size, smooth, charset) {\n\t// createFont(name, size)\n\t// createFont(name, size, smooth)\n\t// createFont(name, size, smooth, charset)\n\tvar font = Sk.misceval.callsim(mod.PFont);\n        if (typeof(smooth) === \"undefined\") {\n\t    font.v = mod.processing.createFont(name.v, size.v);\n\t} else if (typeof(charset) === \"undefined\") {\n\t    font.v = mod.processing.createFont(name.v, size.v, smooth.v);\n\t} else {\n\t    font.v = mod.processing.createFont(name.v, size.v, smooth.v, charset.v);\n\t}\n\treturn font;\n    });\n\n    mod.createGraphics = new Sk.builtin.func(function (width, height, renderer, filename) {\n\t// createGraphics(width, height, renderer)\n\t// createGraphics(width, height, renderer, filename)\n\tvar graphics = Sk.misceval.callsim(mod.PGraphics);\n        if (typeof(filename) === \"undefined\") {\n\t    graphics.v = mod.processing.createGraphics(width.v, height.v, renderer.v);\n\t} else {\n\t    graphics.v = mod.processing.createGraphics(width.v, height.v, renderer.v, filename.v);\n\t}\n\treturn graphics;\n    });\n\n    mod.createImage = new Sk.builtin.func(function (width, height, format) {\n\tvar image = Sk.misceval.callsim(mod.PImage);\n\timage.v = mod.processing.createImage(width.v, height.v, format.v);\n\treturn image;\n    });\n\n    mod.cursor = new Sk.builtin.func(function (v, x, y) {\n\t// cursor()\n\t// cursor(MODE)\n\t// cursor(image,x,y)\n        if (typeof(v) === \"undefined\") {\n\t    mod.processing.cursor();\n\t} else if (typeof(x) === \"undefined\") {\n\t    mod.processing.cursor(v.v);\n\t} else if (typeof(y) === \"undefined\") {\n\t    mod.processing.cursor(v.v, x.v);\n\t} else {\n\t    mod.processing.cursor(v.v, x.v, y.v);\n\t}\n    });\n\n    mod.curve = new Sk.builtin.func(function (v1, v2, v3, v4,\n\t\t\t\t\t      v5, v6, v7, v8,\n\t\t\t\t\t      v9, v10, v11, v12) {\n\t// curve(x1, y1, x2, y2, x3, y3, x4, y4);\n\t// curve(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4);\n        if (typeof(v9) === \"undefined\") {\n\t    mod.processing.curve(v1.v, v2.v, v3.v, v4.v,\n\t\t\t\t v5.v, v6.v, v7.v, v8.v);\n\t} else if (typeof(v10) === \"undefined\") {\n\t    mod.processing.curve(v1.v, v2.v, v3.v, v4.v,\n\t\t\t\t v5.v, v6.v, v7.v, v8.v,\n\t\t\t\t v9.v);\n\t} else if (typeof(v11) === \"undefined\") {\n\t    mod.processing.curve(v1.v, v2.v, v3.v, v4.v,\n\t\t\t\t v5.v, v6.v, v7.v, v8.v,\n\t\t\t\t v9.v, v10.v);\n\t} else if (typeof(v12) === \"undefined\") {\n\t    mod.processing.curve(v1.v, v2.v, v3.v, v4.v,\n\t\t\t\t v5.v, v6.v, v7.v, v8.v,\n\t\t\t\t v9.v, v10.v, v11.v);\n\t} else {\n\t    mod.processing.curve(v1.v, v2.v, v3.v, v4.v,\n\t\t\t\t v5.v, v6.v, v7.v, v8.v,\n\t\t\t\t v9.v, v10.v, v11.v, v12.v);\n\t}\n    });\n\n    mod.curveDetail = new Sk.builtin.func(function (detail) {\n\t// curveDetail(detail)\n\tmod.processing.curveDetail(detail.v);\n    });\n\n    mod.curvePoint = new Sk.builtin.func(function (a,b,c,d,t) {\n\t// curvePoint(a,b,c,d,t)\n\tmod.processing.curvePoint(a.v,b.v,c.v,d.v,t.v);\n    });\n\n    mod.curveTangent = new Sk.builtin.func(function (a,b,c,d,t) {\n\t// curveTangent(a,b,c,d,t)\n\tmod.processing.curveTangent(a.v,b.v,c.v,d.v,t.v);\n    });\n\n    mod.curveTightness = new Sk.builtin.func(function (squishy) {\n\t// curveTightness(squishy)\n\tmod.processing.curveTightness(squishy.v);\n    });\n\n    mod.curveVertex = new Sk.builtin.func(function (x, y, z) {\n\t// curveVertex(x, y) \n\t// curveVertex(x, y, z)\n        if (typeof(z) === \"undefined\") {\n\t    mod.processing.curveVertex(x.v, y.v);\n\t} else {\n\t    mod.processing.curveVertex(x.v, y.v, z.v);\n\t}\n    });\n\n    mod.day = new Sk.builtin.func(function () {\n\treturn new Sk.builtin.int_(mod.processing.day());\n    });\n\n    mod.degrees = new Sk.builtin.func(function (angle) {\n\t// degrees(angle)\n\treturn new Sk.builtin.float_(mod.processing.degrees(angle.v));\n    });\n\n    mod.directionalLight = new Sk.builtin.func(function (v1,v2,v3,nx,ny,nz) {\n\t// directionalLight(v1,v2,v3,nx,ny,nz)\n\tmod.processing.directionalLight(v1.v,v2.v,v3.v,nx.v,ny.v,nz.v);\n    });\n\n    mod.dist = new Sk.builtin.func(function (x1, y1, z1, x2, y2, z2) {\n\t// dist(x1, y1, x2, y2)\n\t// dist(x1, y1, z1, x2, y2, z2)\n        if (typeof(y2) === \"undefined\") {\n\t    return new Sk.builtin.float_(mod.processing.dist(x1.v, y1.v, z1.v, x2.v));\n\t} else if (typeof(z2) === \"undefined\") {\n\t    return new Sk.builtin.float_(mod.processing.dist(x1.v, y1.v, z1.v, x2.v, y2.v));\n\t} else {\n\t    return new Sk.builtin.float_(mod.processing.dist(x1.v, y1.v, z1.v, x2.v, y2.v, z2.v));\n\t}\n    });\n\n    mod.emissive = new Sk.builtin.func(function (v1, v2, v3) {\n\t// emissive(gray)\n\t// emissive(color)\n\t// emissive(v1,v2,v3)\n        if (typeof(v2) === \"undefined\") {\n\t    mod.processing.emissive(v1.v);\n\t} else if (typeof(v3) === \"undefined\") {\n\t    mod.processing.emissive(v1.v, v2.v);\n\t} else {\n\t    mod.processing.emissive(v1.v, v2.v, v3.v);\n\t}\n    });\n\n    mod.endCamera = new Sk.builtin.func(function () {\n\t// endCamera()\n\tmod.processing.endCamera();\n    });\n\n    mod.endShape = new Sk.builtin.func(function (mode) {\n\t// endShape()\n\t// endShape(MODE)\n        if (typeof(mode) === \"undefined\") {\n\t    mod.processing.endShape();\n\t} else {\n\t    mod.processing.endShape(mode.v);\n\t}\n    });\n\n    mod.filter = new Sk.builtin.func(function (mode, srcImg) {\n\t// filter(MODE)\n\t// filter(MODE, srcImg)\n        if (typeof(srcImg) === \"undefined\") {\n\t    mod.processing.filter(mode.v);\n\t} else {\n\t    mod.processing.filter(mode.v, srcImg.v);\n\t}\n    });\n\n    mod.frustum = new Sk.builtin.func(function (left, right, bottom, top, near, far) {\n\t// frustum(left, right, bottom,top, near, far)\n\tmod.processing.frustum(left, right, bottom, top, near, far);\n    });\n\n    mod.hint = new Sk.builtin.func(function (item) {\n\t// hint(item)\n\tmod.processing.hint(item);\n    });\n\n    mod.hour = new Sk.builtin.func(function () {\n\treturn new Sk.builtin.int_(mod.processing.hour());\n    });\n\n    mod.hue = new Sk.builtin.func(function (color) {\n\t// hue(color)\n\treturn new Sk.builtin.float_(mod.processing.hue(color.v));\n    });\n\n    mod.imageMode = new Sk.builtin.func(function (mode) {\n\tmod.processing.imageMode(mode.v);\n    });\n\n    mod.lerp = new Sk.builtin.func(function (value1, value2, amt) {\n\t// lerp(value1, value2, amt)\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.lerp(value1.v, value2.v, amt.v));\n    });\n\n    mod.lerpColor = new Sk.builtin.func(function (c1, c2, amt) {\n\t// lerpColor(c1, c2, amt)\n\t// returns color\n        var c = Sk.misceval.callsim(mod.color,\n\t\t\t\t    new Sk.builtin.int_(0),\n\t\t\t\t    new Sk.builtin.int_(0),\n\t\t\t\t    new Sk.builtin.int_(0));\n\tc.v = mod.processing.lerpColor(c1.v, c2.v, amt.v);\n\treturn c;\n    });\n\n    mod.lightFalloff = new Sk.builtin.func(function (constant, linear, quadratic) {\n\t// lightFalloff(constant,linear,quadratic)\n\tmod.processing.lightFalloff(constant.v, linear.v, quadratic.v);\n    });\n\n    mod.lights = new Sk.builtin.func(function () {\n\tmod.processing.lights();\n    });\n\n    mod.lightSpecular = new Sk.builtin.func(function (v1, v2, v3) {\n\t// lightSpecular(v1,v2,v3)\n\tmod.processing.lightSpecular(v1.v, v2.v, v3.v);\n    });\n\n    mod.loadBytes = new Sk.builtin.func(function (filename) {\n\t// loadBytes(filename)\n\t// returns byte[]\n\treturn new Sk.builtin.list(mod.processing.loadBytes(filename.v));\n    });\n\n    mod.loadFont = new Sk.builtin.func(function (fontname) {\n\t// loadFont(fontname)\n\t// returns font\n\tvar font = Sk.misceval.callsim(mod.PFont);\n\tfont.v = mod.processing.loadFont(fontname.v);\n\treturn font;\n    });\n\n    mod.loadShape = new Sk.builtin.func(function (filename) {\n\t// loadShape(filename)\n\t// returns shape\n\tvar shape = Sk.misceval.callsim(mod.PShapeSVG, \n\t\t\t\t\tnew Sk.builtin.str(\"string\"),\n\t\t\t\t\tfilename);\n\treturn shape;\n    });\n\n    mod.loadStrings = new Sk.builtin.func(function (filename) {\n\t// loadStrings(filename)\n\t// returns string []\n\treturn new Sk.builtin.list(mod.processing.loadStrings(filename.v));\n    });\n\n    mod.mag = new Sk.builtin.func(function (a, b, c) {\n\t// mag(a,b)\n\t// mag(a,b,c)\n\t// returns magnitude as float\n        if (typeof(c) === \"undefined\") {\n\t    return new Sk.builtin.float_(mod.processing.mag(a.v, b.v));\n        } else {\n\t    return new Sk.builtin.float_(mod.processing.mag(a.v, b.v, c.v));\n\t}\n    });\n\n    mod.map = new Sk.builtin.func(function (value,low1,high1,low2,high2) {\n\t// map(value,low1,high1,low2,high2)\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.map(value.v,low1.v,high1.v,\n\t\t\t\t\t\t   low2.v,high2.v));\n    });\n\n    mod.millis = new Sk.builtin.func(function () {\n\treturn new Sk.builtin.int_(mod.processing.millis());\n    });\n\n    mod.minute = new Sk.builtin.func(function () {\n\treturn new Sk.builtin.int_(mod.processing.minute());\n    });\n\n    mod.modelX = new Sk.builtin.func(function (x, y, z) {\n\t// modelX(x,y,z)\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.modelX(x.v, y.v, z.v));\n    });\n\n    mod.modelY = new Sk.builtin.func(function (x, y, z) {\n\t// modelY(x,y,z)\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.modelY(x.v, y.v, z.v));\n    });\n\n    mod.modelZ = new Sk.builtin.func(function (x, y, z) {\n\t// modelZ(x,y,z)\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.modelZ(x.v, y.v, z.v));\n    });\n\n    mod.month = new Sk.builtin.func(function () {\n\treturn new Sk.builtin.int_(mod.processing.month());\n    });\n\n    mod.noCursor = new Sk.builtin.func(function () {\n\tmod.processing.noCursor();\n    });\n\n    mod.noise = new Sk.builtin.func(function (x, y, z) {\n\t// noise(x)\n\t// noise(x, y)\n\t// noise(x, y, z)\n\t// returns float\n        if (typeof(y) === \"undefined\") {\n\t    return new Sk.builtin.float_(mod.processing.noise(x.v));\n        } else if (typeof(z) === \"undefined\") {\n\t    return new Sk.builtin.float_(mod.processing.noise(x.v, y.v));\n        } else {\n\t    return new Sk.builtin.float_(mod.processing.noise(x.v, y.v, z.v));\n\t}\n    });\n\n    mod.noiseDetail = new Sk.builtin.func(function (octaves, falloff) {\n\t// noiseDetail(octaves);\n\t// noiseDetail(octaves,falloff);\n\tmod.processing.noiseDetail(octaves.v, falloff.v);\n    });\n\n    mod.noiseSeed = new Sk.builtin.func(function (value) {\n\t// noiseSeed(value); int\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.noiseSeed(value.v));\n    });\n\n    mod.noLights = new Sk.builtin.func(function () {\n\tmod.processing.noLights();\n    });\n\n    mod.norm = new Sk.builtin.func(function (value, low, high) {\n\t// norm(value, low, high)\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.norm(value.v, low.v, high.v));\n    });\n\n    mod.normal = new Sk.builtin.func(function (nx, ny, nz) {\n\t// normal(nx,ny,nz)\n\t// returns None\n\tmod.processing.normal(nx.v, ny.v, nz.v);\n    });\n\n    mod.noTint = new Sk.builtin.func(function () {\n\tmod.processing.noTint();\n    });\n\n    mod.ortho = new Sk.builtin.func(function (left, right, bottom, top, near, far) {\n\t// ortho(left, right, bottom,top, near,far)\n\t// returns None\n\tmod.processing.ortho(left.v, right.v, bottom.v, top.v, near.v, far.v);\n    });\n\n    mod.perspective = new Sk.builtin.func(function (fov, aspect, zNear, zFar) {\n\t// perspective()\n\t// perspective(fov, aspect, zNear, zFar)\n\t// returns None\n        if (typeof(fov) === \"undefined\") {\n\t    mod.processing.perspective();\n        } else if (typeof(aspect) === \"undefined\") {\n\t    mod.processing.perspective(fov.v);\n        } else if (typeof(zNear) === \"undefined\") {\n\t    mod.processing.perspective(fov.v, aspect.v);\n        } else if (typeof(zFar) === \"undefined\") {\n\t    mod.processing.perspective(fov.v, aspect.v, zNear.v);\n        } else {\n\t    mod.processing.perspective(fov.v, aspect.v, zNear.v, zFar.v);\n\t}\n    });\n\n    mod.pointLight = new Sk.builtin.func(function (v1,v2,v3,nx,ny,nz) {\n\t// pointLight(v1,v2,v3,nx,ny,nz)\n\t// returns None\n\tmod.processing.pointLight(v1.v,v2.v,v3.v,nx.v,ny.v,nz.v);\n    });\n\n    mod.printCamera = new Sk.builtin.func(function () {\n\t// printCamera()\n\t// returns None\n\tmod.processing.printCamera();\n    });\n\n    mod.println = new Sk.builtin.func(function (data) {\n\t// println(data)\n\tmod.processing.println(data.v);\n    });\n\n    mod.printProjection = new Sk.builtin.func(function () {\n\t// printProjection()\n\t// returns None\n\tmod.processing.printProjection();\n    });\n\n    mod.radians = new Sk.builtin.func(function (angle) {\n\t// radians(angle)\n\t// returns int or float\n\treturn new Sk.builtin.float_(mod.processing.radians(angle.v));\n    });\n\n    mod.randomSeed = new Sk.builtin.func(function (value) {\n\t// noiseSeed(value);\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.randomSeed(value.v));\n    });\n\n    mod.random = new Sk.builtin.func(function (v1, v2) {\n\t// random();\n\t// random(high);\n\t// random(low, high);\n\t// returns float\n        if (typeof(v1) === \"undefined\") {\n\t    return new Sk.builtin.float_(mod.processing.random());\n        } else if (typeof(v2) === \"undefined\") {\n\t    return new Sk.builtin.float_(mod.processing.random(v1.v));\n        } else {\n\t    return new Sk.builtin.float_(mod.processing.random(v1.v, v2.v));\n\t}\n    });\n\n    mod.requestImage = new Sk.builtin.func(function (filename, extension) {\n\t// requestImage(filename)\n\t// requestImage(filename, extension)\n\tvar image = Sk.misceval.callsim(mod.PImage);\n        if (typeof(extension) === \"undefined\") {\n\t    image.v = mod.processing.requestImage(filename.v);\n        } else {\n\t    image.v = mod.processing.requestImage(filename.v, extension.v);\n\t}\n\treturn image;\n    });\n\n    mod.saturation = new Sk.builtin.func(function (color) {\n\t// saturation(color)\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.saturation(color.v));\n    });\n\n    mod.save = new Sk.builtin.func(function (filename) {\n\t// save(filename)\n\t// returns None\n\tmod.processing.save(filename.v);\n    });\n\n    mod.saveFrame = new Sk.builtin.func(function (filename) {\n\t// saveFrame()\n\t// saveFrame(filename-####.ext)\n\t// returns None\n        if (typeof(filename) === \"undefined\") {\n\t    mod.processing.saveFrame();\n        } else {\n\t    mod.processing.saveFrame(filename.v);\n\t}\n    });\n\n    mod.saveStrings = new Sk.builtin.func(function (filename, strings) {\n\t// saveStrings(filename,strings)\n\tmod.processing.saveStrings(filename.v, strings.v);\n    });\n\n    mod.screenX = new Sk.builtin.func(function (x, y, z) {\n\t// screenX(x,y,z)\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.screenX(x.v, y.v, z.v));\n    });\n\n    mod.screenY = new Sk.builtin.func(function (x, y, z) {\n\t// screenY(x,y,z)\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.screenY(x.v, y.v, z.v));\n    });\n\n    mod.screenZ = new Sk.builtin.func(function (x, y, z) {\n\t// screenZ(x,y,z)\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.screenZ(x.v, y.v, z.v));\n    });\n\n    mod.second = new Sk.builtin.func(function () {\n\treturn new Sk.builtin.int_(mod.processing.second());\n    });\n\n    mod.shape = new Sk.builtin.func(function (sh, x, y, width, height) {\n\t// shape(sh)\n\t// shape(sh,x,y)\n\t// shape(sh,x,y,width,height)\n\t// returns?\n        if (typeof(x) === \"undefined\") {\n\t    mod.processing.shape(sh.v);\n        } else if (typeof(y) === \"undefined\") {\n\t    mod.processing.shape(sh.v,x.v);\n        } else if (typeof(width) === \"undefined\") {\n\t    mod.processing.shape(sh.v,x.v,y.v);\n        } else if (typeof(height) === \"undefined\") {\n\t    mod.processing.shape(sh.v,x.v,y.v,width.v);\n        } else {\n\t    mod.processing.shape(sh.v,x.v,y.v,width.v,height.v);\n\t}\n    });\n\n    mod.shapeMode = new Sk.builtin.func(function (mode) {\n\t// shapeMode(MODE)\n\tmod.processing.shapeMode(mode.v);\n    });\n\n    mod.shininess = new Sk.builtin.func(function (shine) {\n\t// shininess(shine)\n\t// returns None\n\tmod.processing.shininess(shine.v);\n    });\n\n    mod.specular = new Sk.builtin.func(function (v1,v2,v3) {\n\t// specular(gray)\n\t// specular(color)\n\t// specular(v1,v2,v3)\n        if (typeof(v2) === \"undefined\") {\n\t    mod.processing.specular(v1.v);\n        } else if (typeof(v3) === \"undefined\") {\n\t    mod.processing.specular(v1.v,v2.v);\n        } else {\n\t    mod.processing.specular(v1.v,v2.v,v3.v);\n\t}\n    });\n\n    mod.spotLight = new Sk.builtin.func(function (v1,v2,v3,nx,ny,nz,angle,concentration) {\n\t// spotLight(v1,v2,v3,nx,ny,nz,angle,concentration)\n\t// returns None\n\tmod.processing.spotLight(v1.v,v2.v,v3.v,nx.v,ny.v,nz.v,angle.v,concentration.v);\n    });\n\n    mod.sq = new Sk.builtin.func(function (value) {\n\t// sq(value)\n\t// returns squared number\n\treturn new Sk.builtin.float_(mod.processing.sq(value));\n    });\n\n    mod.status = new Sk.builtin.func(function (text) {\n\t// status(text)\n\tmod.processing.status(text.v);\n    });\n\n    mod.textAlign = new Sk.builtin.func(function (align, yalign) {\n\t// textAlign(ALIGN)\n\t// textAlign(ALIGN, YALIGN)\n\t// returns None\n        if (typeof(yalign) === \"undefined\") {\n\t    mod.processing.textAlign(align.v);\n        } else {\n\t    mod.processing.textAlign(align.v, yalign.v);\n\t}\n    });\n\n    mod.textAscent = new Sk.builtin.func(function () {\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.textAscent());\n    });\n\n    mod.textDescent = new Sk.builtin.func(function () {\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.textDescent());\n    });\n\n    mod.textFont = new Sk.builtin.func(function (font, size) {\n\t// textFont(font)\n\t// textFont(font, size)\n        if (typeof(size) === \"undefined\") {\n\t    mod.processing.textFont(font.v);\n        } else {\n\t    mod.processing.textFont(font.v, size.v);\n\t}\n    });\n\n    mod.textLeading = new Sk.builtin.func(function (dist) {\n\t// textLeading(dist)\n\t// returns None\n\tmod.processing.textLeading(dist.v);\n    });\n\n    mod.textMode = new Sk.builtin.func(function (mode) {\n\t// textMode(MODE)\n\t// returns None\n\tmod.processing.textMode(mode.v);\n    });\n\n    mod.textSize = new Sk.builtin.func(function (size) {\n\t// textSize(size)\n\t// returns None\n\tmod.processing.textSize(size.v);\n    });\n\n    mod.texture = new Sk.builtin.func(function (img) {\n\t// texture(img)\n\t// returns None\n\tmod.processing.texture(img.v);\n    });\n\n    mod.textureMode = new Sk.builtin.func(function (mode) {\n\t// textureMode(MODE)\n\t// returns None\n\tmod.processing.textureMode(mode.v);\n    });\n\n    mod.textWidth = new Sk.builtin.func(function (data) {\n\t// textWidth(data)\n\t// returns float\n\treturn new Sk.builtin.float_(mod.processing.textWidth(data.v));\n    });\n\n    mod.tint = new Sk.builtin.func(function (v1, v2, v3, v4) {\n\t// tint(gray)\n\t// tint(gray, alpha)\n\t// tint(value1, value2, value3)\n\t// tint(value1, value2, value3, alpha)\n\t// tint(color)\n\t// tint(color, alpha)\n\t// tint(hex)\n\t// tint(hex, alpha)\n        if (typeof(v2) === \"undefined\") {\n\t    mod.processing.tint(v1.v);\n        } else if (typeof(v3) === \"undefined\") {\n\t    mod.processing.tint(v1.v, v2.v);\n        } else if (typeof(v4) === \"undefined\") {\n\t    mod.processing.tint(v1.v, v2.v, v3.v);\n        } else {\n\t    mod.processing.tint(v1.v, v2.v, v3.v, v4.v);\n\t}\n    });\n\n    mod.updatePixels = new Sk.builtin.func(function () {\n\t// updatePixels()\n\tmod.processing.updatePixels();\n    });\n\n    mod.vertex = new Sk.builtin.func(function (x, y, z, u, v) {\n\t// vertex(x, y); \n\t// vertex(x, y, z); \n\t// vertex(x, y, u, v); \n\t// vertex(x, y, z, u, v);\n        if (typeof(z) === \"undefined\") {\n\t    mod.processing.vertex(x.v, y.v);\n        } else if (typeof(u) === \"undefined\") {\n\t    mod.processing.vertex(x.v, y.v, z.v);\n        } else if (typeof(v) === \"undefined\") {\n\t    mod.processing.vertex(x.v, y.v, z.v, u.v);\n        } else {\n\t    mod.processing.vertex(x.v, y.v, z.v, u.v, v.v);\n\t}\n    });\n\n    mod.year = new Sk.builtin.func(function () {\n\treturn new Sk.builtin.int_(mod.processing.year());\n    });\n\n    // 3D Primitives\n\n    mod.box = new Sk.builtin.func(function(size) {\n        mod.processing.box(size.v);\n    });\n\n    mod.sphere = new Sk.builtin.func(function(radius) {\n        mod.processing.sphere(radius.v);\n    });\n\n    mod.sphereDetail = new Sk.builtin.func(function(res,vres) {\n        if (typeof(vres) === \"undefined\") {\n            mod.processing.sphereDetail(res.v);\n        }\n        else {\n            mod.processing.sphereDetail(res.v, vres.v);\n        }\n    });\n\n    // Color\n    mod.background = new Sk.builtin.func(function (r, g, b) {\n\n        if (typeof(g) !== \"undefined\") {\n            g = g.v;\n        }\n        if (typeof(b) !== \"undefined\") {\n            b = b.v;\n        }\n\n        mod.processing.background(r.v, g, b);\n\n    });\n\n    mod.fill = new Sk.builtin.func(function (r, g, b, alpha) {\n        // r will be either:\n        //      a number in which case the fill will be grayscale\n        //      a color object\n        // g, and b may be undefined.  If they hold values it will\n        // be assumed that we have an r,g,b color tuple\n        // alpha may also be undefined - if defined, it is the opacity of the fill\n        if (typeof(g) !== \"undefined\") {\n            g = g.v;\n        }\n        if (typeof(b) !== \"undefined\") {\n            b = b.v;\n        }\n        if (typeof(alpha) !== \"undefined\") {\n            alpha = alpha.v;\n        }\n\n        mod.processing.fill(r.v, g, b, alpha);\n\n    });\n\n\n    mod.stroke = new Sk.builtin.func(function (r, g, b, alpha) {\n\n        if (typeof(g) !== \"undefined\") {\n            g = g.v;\n        }\n        if (typeof(b) !== \"undefined\") {\n            b = b.v;\n        }\n        if (typeof(alpha) !== \"undefined\") {\n            alpha = alpha.v;\n        }\n\n        mod.processing.stroke(r.v, g, b, alpha);\n\n    });\n\n    mod.noStroke = new Sk.builtin.func(function () {\n        mod.processing.noStroke();\n    });\n\n\n    mod.colorMode = new Sk.builtin.func(function (mode, maxV, maxG, maxB, maxAlpha) {\n        // mode is one of RGB or HSB\n        // maxV is either the max value for all color elements\n        // or the range for Red/Hue (depending on mode) if maxG and maxB are defined\n        if (typeof(maxV) === \"undefined\") {\n            maxV = 255;\n        }\n        else {\n            maxV = maxV.v;\n        }\n        if (typeof(maxG) !== \"undefined\") {\n            maxG = maxG.v;\n        }\n        if (typeof(maxB) !== \"undefined\") {\n            maxB = maxB.v;\n        }\n        if (typeof(maxAlpha) !== \"undefined\") {\n            maxAlpha = maxAlpha.v;\n        }\n\n        mod.processing.colorMode(mode.v, maxV, maxG, maxB, maxAlpha);\n    });\n\n    mod.noFill = new Sk.builtin.func(function () {\n        mod.processing.noFill();\n    });\n\n\n    // Environment\n\n    mod.loop = new Sk.builtin.func(function () {\n        if (mod.processing === null) {\n            throw new Sk.builtin.Exception(\"loop() should be called after run()\");\n        }\n        looping = true;\n        mod.processing.loop();\n    });\n\n    mod.noLoop = new Sk.builtin.func(function () {\n        if (mod.processing === null) {\n            throw new Sk.builtin.Exception(\"noLoop() should be called after run()\");\n        }\n        looping = false;\n        mod.processing.noLoop();\n    });\n\n    // NOTE: difference with ProcessingJS\n    // frameRate is only a function, not a variable: \n    // use environment.frameRate for value\n    mod.frameRate = new Sk.builtin.func(function (fr) {\n        mod.processing.frameRate(fr.v);\n    });\n\n    // NOTE: difference with ProcessingJS\n    // Use mouse.pressed rather than mousePressed\n\n    // NOTE: difference with ProcessingJS\n    // Use environment.keyPressed rather than keyPressed\n\n    // NOTE: difference with ProcessingJS\n    // Use environment.frameCount \n\n    // NOTE: difference with ProcessingJS\n    // Use environment.frameCount\n    \n    // NOTE: difference with ProcessingJS\n    // Use environment.online\n\n    // NOTE: difference with ProcessingJS\n    // Use environment.focused\n\n    mod.width = new Sk.builtin.int_(100);\n    mod.height = new Sk.builtin.int_(100);\n\n    mod.size = new Sk.builtin.func(function (w, h, mode) {\n        if (typeof(mode) === \"undefined\") {\n            mode = mod.P2D;\n        }\n        mod.processing.size(w.v, h.v, mode.v);\n\tmod.width = new Sk.builtin.int_(mod.processing.width);\n\tmod.height = new Sk.builtin.int_(mod.processing.height);\n    });\n\n    mod.exitp = new Sk.builtin.func(function (h, w) {\n        mod.processing.exit();\n    });\n\n    // NOTE: difference with ProcessingJS\n    // Use mouseX() or mouse.x rather than mouseX\n    mod.mouseX = new Sk.builtin.func(function () {\n        return new Sk.builtin.int_(mod.processing.mouseX);\n    });\n\n    // NOTE: difference with ProcessingJS\n    // Use mouseY() or mouse.y rather than mouseY\n    mod.mouseY = new Sk.builtin.func(function () {\n        return new Sk.builtin.int_(mod.processing.mouseY);\n    });\n\n    // NOTE: difference with ProcessingJS\n    // Use pmouseX() or mouse.px rather than pmouseX\n    mod.pmouseX = new Sk.builtin.func(function () {\n        return new Sk.builtin.int_(mod.processing.pmouseX);\n    });\n\n    // NOTE: difference with ProcessingJS\n    // Use pmouseY() or mouse.py rather than pmouseY\n    mod.pmouseY = new Sk.builtin.func(function () {\n        return new Sk.builtin.int_(mod.processing.pmouseY);\n    });\n\n    // Attributes\n    mod.rectMode = new Sk.builtin.func(function (mode) {\n        mod.processing.rectMode(mode.v);\n    });\n\n    mod.strokeWeight = new Sk.builtin.func(function (wt) {\n        mod.processing.strokeWeight(wt.v);\n\n    });\n\n    mod.smooth = new Sk.builtin.func(function () {\n        mod.processing.smooth();\n    });\n\n    mod.noSmooth = new Sk.builtin.func(function () {\n        mod.processing.noSmooth();\n    });\n\n    mod.ellipseMode = new Sk.builtin.func(function (mode) {\n        mod.processing.ellipseMode(mode.v);\n    });\n\n    mod.strokeCap = new Sk.builtin.func(function (mode) {\n        mod.processing.strokeCap(mode.v);\n    });\n\n    mod.strokeJoin = new Sk.builtin.func(function (mode) {\n        mod.processing.strokeJoin(mode.v);\n    });\n\n\n    // Transforms\n    mod.rotate = new Sk.builtin.func(function (rads) {\n        // rotation in radians\n        mod.processing.rotate(rads.v);\n    });\n\n    mod.rotateX = new Sk.builtin.func(function(rads) {\n        mod.processing.rotateX(rads.v);\n    });\n\n    mod.rotateY = new Sk.builtin.func(function(rads) {\n        mod.processing.rotateY(rads.v);\n    });\n\n    mod.rotateZ = new Sk.builtin.func(function(rads) {\n        mod.processing.rotateZ(rads.v);\n    });\n\n    mod.scale = new Sk.builtin.func(function (sx, sy, sz) {\n        if (typeof(sy) === \"undefined\") {\n            sy = 1.0;\n        } else {\n            sy = sy.v;\n        }\n        if (typeof(sz) === \"undefined\") {\n            sz = 1.0;\n        } else {\n            sz = sz.v;\n        }\n        mod.processing.scale(sx.v, sy, sz);\n    });\n\n    mod.translate = new Sk.builtin.func(function (sx, sy, sz) {\n        if (typeof(sy) === \"undefined\") {\n            sy = 1.0;\n        } else {\n            sy = sy.v;\n        }\n        if (typeof(sz) === \"undefined\") {\n            sz = 1.0;\n        } else {\n            sz = sz.v;\n        }\n        mod.processing.translate(sx.v, sy, sz);\n    });\n\n    mod.popMatrix = new Sk.builtin.func(function() {\n        mod.processing.popMatrix();\n    });\n\n    mod.pushMatrix = new Sk.builtin.func(function() {\n        mod.processing.pushMatrix();\n    });\n\n    mod.applyMatrix = new Sk.builtin.func(function() {\n        var args = Array.prototype.slice.call(arguments, 0, 16),\n            i;\n\n        for (i = 0; i < args.length; i++) {\n            args[i] = typeof(args[i]) === \"undefined\" ? 0.0 : args[i].v;\n        }\n\n        mod.processing.applyMatrix.apply(mod.processing, args);\n    });\n\n    mod.resetMatrix = new Sk.builtin.func(function() {\n        mod.processing.resetMatrix();\n    });\n\n    mod.printMatrix = new Sk.builtin.func(function() {\n        return Sk.ffi.remapToPy(mod.processing.printMatrix());\n    });\n\n    //  //////////////////////////////////////////////////////////////////////\n    //  Run\n    // \n    //  Create the processing context and setup of calls to setup, draw etc.\n    //\n    //\n    //  //////////////////////////////////////////////////////////////////////    \n    mod.run = new Sk.builtin.func(function () {\n        function sketchProc (processing) {\n            mod.processing = processing;\n\n            // processing.setup = function() {\n            //     if Sk.globals[\"setup\"]\n            //         Sk.misceval.callsim(Sk.globals[\"setup\"])\n            // }\n\n\n            // FIXME if no Sk.globals[\"draw\"], then no need for this\n            processing.draw = function () {\n                // if there are pending image loads then just use the natural looping calls to \n                // retry until all the images are loaded.  If noLoop was called in setup then make\n                // sure to revert to that after all the images in hand.\n                var wait = false;\n                for (var i in imList) {\n                    if (imList[i].width === 0) {\n                        wait = true;\n                    }\n                }\n                if (wait === true) {\n                    if (looping === true) {\n                        return;\n                    }\n                    else {\n                        processing.loop();\n                        return;\n                    }\n\n                } else {\n                    if (looping === false) {\n                        processing.noLoop();\n                    }\n                }\n\n                mod.frameCount = processing.frameCount;\n                if (Sk.globals[\"draw\"]) {\n                \ttry {\n                   \t    Sk.misceval.callsim(Sk.globals[\"draw\"]);\n                    }\n                    catch(e) {\n                        Sk.uncaughtException(e);\n                    }\n\t\t\t\t}\n            };\n\n            var callBacks = [\"setup\", \"mouseMoved\", \"mouseClicked\", \"mouseDragged\", \"mouseMoved\", \"mouseOut\",\n                \"mouseOver\", \"mousePressed\", \"mouseReleased\", \"keyPressed\", \"keyReleased\", \"keyTyped\"\n            ];\n            for (var cb in callBacks) {\n                if (Sk.globals[callBacks[cb]]) {\n                    processing[callBacks[cb]] = new Function(\"try {Sk.misceval.callsim(Sk.globals['\" + callBacks[cb] + \"']);} catch(e) {Sk.uncaughtException(e);}\");\n                }\n            }\n        }\n\n        var canvas = document.getElementById(Sk.canvas);\n        if (canvas.tagName !== \"CANVAS\") {\n            var mydiv = canvas;\n            canvas = document.createElement('canvas');\n            while (mydiv.firstChild) {\n                mydiv.removeChild(mydiv.firstChild);\n            }\n            mydiv.appendChild(canvas);\n        }\n        window.$(canvas).show();\n        window.Processing.logger = { log : function(message) {\n            Sk.misceval.print_(message);\n        }};\n        // if a Processing instance already exists it's likely still running, stop it by exiting\n        instance = window.Processing.getInstanceById(Sk.canvas);\n        if (instance) {\n            instance.exit();\n        }\n        mod.p = new window.Processing(canvas, sketchProc);\n\n\n    });\n\n    mouseClass = function ($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function (self, key) {\n\t    key = Sk.ffi.remapToJs(key);\n            if (key === \"x\") {\n                return Sk.builtin.assk$(mod.processing.mouseX);\n            }\n            else if (key === \"y\") {\n                return Sk.builtin.assk$(mod.processing.mouseY);\n            }\n            else if (key === \"px\") {\n                return Sk.builtin.assk$(mod.processing.pmouseX);\n            }\n            else if (key === \"py\") {\n                return Sk.builtin.assk$(mod.processing.pmouseY);\n            }\n            else if (key === \"pressed\") {\n                    return new Sk.builtin.bool(mod.processing.__mousePressed);\n            }\n            else if (key === \"button\") {\n                return Sk.builtin.assk$(mod.processing.mouseButton);\n            }\n        });\n\n    };\n\n\n    mod.Mouse = Sk.misceval.buildClass(mod, mouseClass, \"Mouse\", []);\n\n    mod.mouse = Sk.misceval.callsim(mod.Mouse);\n\n    keyboardClass = function ($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function (self, key) {\n\t    key = Sk.ffi.remapToJs(key);\n            if (key === \"key\") {\n                return new Sk.builtin.str(mod.processing.key.toString());\n            }\n            else if (key === \"keyCode\") {\n                return Sk.builtin.assk$(mod.processing.keyCode);\n            }\n            else if (key === \"keyPressed\") {\n                return new Sk.builtin.str(mod.processing.keyPressed);\n            } // todo bool\n        });\n\n    };\n\n    mod.Keyboard = Sk.misceval.buildClass(mod, keyboardClass, \"Keyboard\", []);\n\n    mod.keyboard = Sk.misceval.callsim(mod.Keyboard);\n\n\n    environmentClass = function ($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function (self, key) {\n\t    key = Sk.ffi.remapToJs(key);\n            if (key === \"frameCount\") {\n                return Sk.builtin.assk$(mod.processing.frameCount);\n            }\n            else if (key === \"frameRate\") {\n                return Sk.builtin.assk$(mod.processing.frameRate);\n            }\n            else if (key === \"height\") {\n                return Sk.builtin.assk$(mod.processing.height);\n            }\n            else if (key === \"width\") {\n                return Sk.builtin.assk$(mod.processing.width);\n            }\n            else if (key === \"online\") {\n                return new Sk.builtin.bool(mod.processing.online);\n            }\n            else if (key === \"focused\") {\n                return new Sk.builtin.bool(mod.processing.focused);\n            }\n        });\n\n    };\n\n    mod.Environment = Sk.misceval.buildClass(mod, environmentClass, \"Environment\", []);\n\n    mod.environment = Sk.misceval.callsim(mod.Environment);\n\n    screenClass = function ($gbl, $loc) {\n\n        $loc.__init__ = new Sk.builtin.func(function (self) {\n            self.pixels = null;\n        });\n\n        $loc.__getattr__ = new Sk.builtin.func(function (self, key) {\n\t    key = Sk.ffi.remapToJs(key);\n            if (key === \"height\") {\n                return Sk.builtin.assk$(mod.processing.height);\n            }\n            else if (key === \"width\") {\n                return Sk.builtin.assk$(mod.processing.width);\n            }\n            else if (key === \"pixels\") {\n                if (self.pixels == null) {\n                    self.pixels = new Sk.builtin.list(mod.processing.pixels.toArray());\n                }\n            }\n            return self.pixels;\n        });\n\n    };\n\n    mod.Screen = Sk.misceval.buildClass(mod, screenClass, \"Screen\", []);\n\n    mod.screen = Sk.misceval.callsim(mod.Screen);\n\n    mod.loadPixels = new Sk.builtin.func(function () {\n        mod.processing.loadPixels();\n    });\n\n\n    colorClass = function ($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function (self, val1, val2, val3, alpha) {\n            if (typeof(val2) !== \"undefined\") {\n                val2 = val2.v;\n            }\n            if (typeof(val3) !== \"undefined\") {\n                val3 = val3.v;\n            }\n            if (typeof(alpha) !== \"undefined\") {\n                alpha = alpha.v;\n            }\n            self.v = mod.processing.color(val1.v, val2, val3, alpha);\n        });\n\n    };\n\n    mod.color = Sk.misceval.buildClass(mod, colorClass, \"color\", []);\n\n    mod.red = new Sk.builtin.func(function (clr) {\n        return new Sk.builtin.int_(mod.processing.red(clr.v));\n    });\n\n    mod.green = new Sk.builtin.func(function (clr) {\n        return new Sk.builtin.int_(mod.processing.green(clr.v));\n    });\n\n    mod.blue = new Sk.builtin.func(function (clr) {\n        return new Sk.builtin.int_(mod.processing.blue(clr.v));\n    });\n\n    // Image class and functions\n    //\n    imageClass = function ($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function (self, arg1, arg2, arg3) {\n\t    // PImage()\n\t    // PImage(img)\n\t    // PImage(width,height)\n\t    // PImage(width,height,format)\n\t    if (typeof(arg1) === \"undefined\") {\n\t\tself.v = new mod.processing.PImage();\n\t    } else if (typeof(arg2) === \"undefined\") {\n\t\tself.v = new mod.processing.PImage(arg1.v);\n\t    } else if (typeof(arg3) === \"undefined\") {\n\t\tself.v = new mod.processing.PImage(arg1.v, arg2.v);\n\t    } else {\n\t\tself.v = new mod.processing.PImage(arg1.v, arg2.v, arg3.v);\n\t    }\n        });\n\n        $loc.__getattr__ = new Sk.builtin.func(function (self, key) {\n\t    key = Sk.ffi.remapToJs(key);\n            if (key === \"width\") {\n                return Sk.builtin.assk$(self.v.width);\n            }\n            if (key === \"height\") {\n                return Sk.builtin.assk$(self.v.height);\n            }\n        });\n\n    };\n\n    mod.loadImage = new Sk.builtin.func(function (imfile) {\n        var i = mod.processing.loadImage(imfile.v);\n        imList.push(i);\n\tvar image = Sk.misceval.callsim(mod.PImage);\n\timage.v = i;\n        return image;\n    });\n\n    mod.image = new Sk.builtin.func(function (im, x, y, w, h) {\n\t// image(img, x, y)\n\t// image(img, x, y, width, height)\n\tif (typeof(w) === \"undefined\") {\n            mod.processing.image(im.v, x.v, y.v);\n\t} else {\n            mod.processing.image(im.v, x.v, y.v, w.v, h.v);\n        }\n    });\n\n    mod.get = new Sk.builtin.func(function (x, y) {\n        var clr = mod.processing.get(x.v, y.v);\n        return Sk.misceval.callsim(mod.color,\n            new Sk.builtin.int_(mod.processing.red(clr)),\n            new Sk.builtin.int_(mod.processing.green(clr)),\n            new Sk.builtin.int_(mod.processing.blue(clr)));\n    });\n\n    mod.set = new Sk.builtin.func(function (x, y, color) {\n        mod.processing.set(x.v, y.v, color.v);\n    });\n\n    // --- classes\n\n    vectorClass = function ($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self, x, y, z) {\n\t    // PVector()\n\t    // PVector(x,y)\n\t    // PVector(x,y,z)\n            if (typeof(x) === \"undefined\") {\n\t\tself.v = new mod.processing.PVector();\n            } else if (typeof(z) === \"undefined\") {\n\t\tself.v = new mod.processing.PVector(x.v, y.v);\n            } else {\n\t\tself.v = new mod.processing.PVector(x.v, y.v, z.v);\n\t    }\n        });\n\n        $loc.__getattr__ = new Sk.builtin.func(function (self, key) {\n\t    key = Sk.ffi.remapToJs(key);\n            if (key === \"x\") {\n                return Sk.builtin.assk$(self.v.x);\n            } else if (key === \"y\") {\n                return Sk.builtin.assk$(self.v.y);\n            } else if (key === \"z\") {\n                return Sk.builtin.assk$(self.v.z);\n\t    }\n\t});\n\t    \n        $loc.get = new Sk.builtin.func(function (self) {\n\t    // get() Gets a copy of the vector\n            var new_vec = Sk.misceval.callsim(mod.PVector);\n\t    new_vec.v = self.v.get();\n\t    return new_vec;\n\t});\n\t\n\t$loc.set = new Sk.builtin.func(function (self, x, y, x) {\n\t    // set() Sets the x, y, z component of the vector\n\t    if (typeof(z) === \"undefined\") {\n\t\tself.v.set(x.v, y.v);\n\t    } else {\n\t\tself.v.set(x.v, y.v, z.v);\n\t    }\n\t});\n\n\t$loc.mag = new Sk.builtin.func(function (self) {\n\t    // mag() Calculates the magnitude (length) of the vector\n\t    // and returns the result as a float\n\t    return Sk.builtin.assk$(self.v.mag());\n\t});\n\n\t$loc.add = new Sk.builtin.func(function (self, vec) {\n\t    // add()\tAdds one vector to another\n            var new_vec = Sk.misceval.callsim(mod.PVector);\n\t    new_vec.v = self.v.add(vec.v);\n\t    return new_vec;\n\t});\n\n\t$loc.sub = new Sk.builtin.func(function (self, vec) {\n\t    // sub()\tSubtracts one vector from another\n            var new_vec = Sk.misceval.callsim(mod.PVector);\n\t    new_vec.v = self.v.sub(vec.v);\n\t    return new_vec;\n\t});\n\n\t$loc.mult = new Sk.builtin.func(function (self, vec) {\n\t    // mult()\tMultiplies the vector by a scalar\n            var new_vec = Sk.misceval.callsim(mod.PVector);\n\t    new_vec.v = self.v.mult(vec.v);\n\t    return new_vec;\n\t});\n\n\t$loc.div = new Sk.builtin.func(function (self, vec) {\n\t    // div()\tDivides the vector by a scalar\n            var new_vec = Sk.misceval.callsim(mod.PVector);\n\t    new_vec.v = self.v.dic(vec.v);\n\t    return new_vec;\n\t});\n\n\t$loc.dist = new Sk.builtin.func(function (self, vec) {\n\t    // dist()\tCalculate the Euclidean distance between two points\n\t    return Sk.builtin.assk$(self.v.dist(vec.v));\n\t});\n\n\t$loc.dot = new Sk.builtin.func(function (self, v1, v2, v3) {\n\t    // dot()\tCalculates the dot product\n\t    // returns float\n\t    // vec.dot(x,y,z)\n\t    // vec.dot(v)\t    \n\t    if (typeof(v2) === 'undefined') {\n\t\treturn Sk.builtin.assk$(self.v.dot(v1.v));\n\t    } else {\n\t\treturn Sk.builtin.assk$(self.v.dot(v1.v, v2.v, v3.v));\n\t    }\n\t});\n\n\t$loc.cross = new Sk.builtin.func(function (self, vec) {\n\t    // cross()\tCalculates the cross product\n            var new_vec = Sk.misceval.callsim(mod.PVector);\n\t    new_vec.v = self.v.cross(vec.v);\n\t    return new_vec;\n\t});\n\n\t$loc.normalize = new Sk.builtin.func(function (self) {\n\t    // normalize()\tNormalizes the vector\n\t    self.v.normalize();\n\t});\n\n\t$loc.limit = new Sk.builtin.func(function (self, value) {\n\t    // limit()\tLimits the magnitude of the vector\n\t    self.v.limit(value.v);\n\t});\n\n\t$loc.angleBetween = new Sk.builtin.func(function (self, vec) {\n\t    // angleBetween()\tCalculates the angle between two vectors\n\t    return Sk.builtin.assk$(self.v.angleBetween(vec.v));\n\t});\n\n\t$loc.array = new Sk.builtin.func(function (self) {\n\t    // array()\t\n\t    return new Sk.builtin.list(self.v.array());\n\t});\n    };\n\n    fontClass = function ($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self, input) {\n\t    // PFont()\n\t    // PFont(input)\n            if (typeof(input) === \"undefined\") {\n\t\tself.v = new mod.processing.PFont();\n            } else {\n\t\tself.v = new mod.processing.PVector(input.v);\n\t    }\n        });\n\n        $loc.list = new Sk.builtin.func(function (self) {\n\t    // font.list()\n\t    return new Sk.builtin.list(self.v.list());\n\t});\n    };\n\n    graphicsClass = function ($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self, x, y, z) {\n\t    // PGraphics()\n\t    // PGraphics(width,height)\n\t    // PGraphics(width,height,applet)\n            if (typeof(x) === \"undefined\") {\n\t\tself.v = new mod.processing.PVector();\n            } else if (typeof(z) === \"undefined\") {\n\t\tself.v = new mod.processing.PVector(x.v, y.v);\n            } else {\n\t\tself.v = new mod.processing.PVector(x.v, y.v, z.v);\n\t    }\n        });\n\n        $loc.beginDraw = new Sk.builtin.func(function (self) {\n\t    self.v.beginDraw();\n\t});\n\n        $loc.endDraw = new Sk.builtin.func(function (self) {\n\t    self.v.endDraw();\n\t});\n    };\n    \n    shapeClass = function ($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self, arg1, arg2, arg3) {\n\t    if (typeof(arg1) === \"undefined\") {\n\t\t// special version for Skulpt\n\t\tself.v = null;\n\t\t// Will fill in manually in getChild()\n\t    } else if (typeof(arg2) === \"undefined\") {\n\t\tself.v = new mod.processing.PShapeSVG(arg1.v);\n\t    } else if (typeof(arg3) === \"undefined\") {\n\t\tself.v = new mod.processing.PShapeSVG(arg1.v, arg2.v);\n\t    } else {\n\t\tself.v = new mod.processing.PShapeSVG(arg1.v, arg2.v, arg3.v);\n\t    }\n        });\n\n        $loc.__getattr__ = new Sk.builtin.func(function (self, key) {\n\t    key = Sk.ffi.remapToJs(key);\n            if (key === \"width\") {\n                return Sk.builtin.assk$(self.v.width);\n            } else if (key === \"height\") {\n                return Sk.builtin.assk$(self.v.height);\n\t    }\n\t});\n\n        $loc.isVisible = new Sk.builtin.func(function (self) {\n\t    // isVisible() Returns a boolean value \"true\" if the image is set to be visible, \"false\" if not\n\t    return new Sk.builtin.bool(self.v.isVisible());\n\t});\n\n        $loc.setVisible = new Sk.builtin.func(function (self, value) {\n\t    // setVisible() Sets the shape to be visible or invisible\n\t    self.v.setVisible(value.v);\n\t});\n\n        $loc.disableStyle = new Sk.builtin.func(function (self) {\n\t    // disableStyle() Disables the shape's style data and uses Processing styles\n\t    self.v.disableStyle();\n\t});\n\n        $loc.enableStyle = new Sk.builtin.func(function (self) {\n\t    // enableStyle() Enables the shape's style data and ignores the Processing styles\n\t    self.v.enableStyle();\n\t});\n\n        $loc.getChild = new Sk.builtin.func(function (self, shape) {\n\t    // getChild() Returns a child element of a shape as a PShapeSVG object\n\t    var child = self.v.getChild(shape.v);\n\t    if (child != null) {\n\t\t// special method for Skulpt:\n\t\tvar new_shape = Sk.misceval.callsim(mod.PShapeSVG);\n\t\t// Now fill in value:\n\t\tnew_shape.v = child;\n\t\treturn new_shape;\n\t    } else {\n\t\treturn null;\n\t    }\n\t});\n\n        $loc.translate = new Sk.builtin.func(function (self, x, y, z) {\n\t    // translate() Displaces the shape\n\t    // sh.translate(x,y)\n\t    // sh.translate(x,y,z)\n            if (typeof(z) === \"undefined\") {\n\t\tself.v.translate(x.v, y.v);\n\t    } else {\n\t\tself.v.translate(x.v, y.v, z.v);\n\t    }\n\t});\n\n        $loc.rotate = new Sk.builtin.func(function (self, angle) {\n\t    // rotate() Rotates the shape\n\t    self.v.rotate(angle.v);\n\t});\n\n        $loc.rotateX = new Sk.builtin.func(function (self, angle) {\n\t    // rotateX() Rotates the shape around the x-axis\n\t    self.v.rotateX(angle.v);\n\t});\n\n        $loc.rotateY = new Sk.builtin.func(function (self) {\n\t    // rotateY() Rotates the shape around the y-axis\n\t    self.v.rotateY(angle.v);\n\t});\n\n        $loc.rotateZ = new Sk.builtin.func(function (self) {\n\t    // rotateZ() Rotates the shape around the z-axis\n\t    self.v.rotateZ(angle.v);\n\t});\n\n        $loc.scale = new Sk.builtin.func(function (self, x, y, z) {\n\t    // scale() Increases and decreases the size of a shape\n\t    // sh.scale(size)\n\t    // sh.scale(x,y)\n\t    // sh.scale(x,y,z)\n            if (typeof(y) === \"undefined\") {\n\t\tself.v.scale(x.v);\n\t    } else if (typeof(z) === \"undefined\") {\n\t\tself.v.scale(x.v, y.v);\n\t    } else {\n\t\tself.v.scale(x.v, y.v, z.v);\n\t    }\n\t});\n    };\n\n    mod.PFont = Sk.misceval.buildClass(mod, fontClass, \"PFont\", []);\n    mod.PGraphics = Sk.misceval.buildClass(mod, graphicsClass, \"PGraphics\", []);\n    mod.PShapeSVG = Sk.misceval.buildClass(mod, shapeClass, \"PShapeSVG\", []);\n    mod.PVector = Sk.misceval.buildClass(mod, vectorClass, \"PVector\", []);\n    mod.PImage = Sk.misceval.buildClass(mod, imageClass, \"PImage\", []);\n\n    return mod;\n};\n", "src/lib/keyword.py": "\n__all__ = [\"iskeyword\", \"kwlist\"]\n\nkwlist = [\n#--start keywords--\n        'and',\n        'as',\n        'assert',\n        'break',\n        'class',\n        'continue',\n        'def',\n        'del',\n        'elif',\n        'else',\n        'except',\n        'exec',\n        'finally',\n        'for',\n        'from',\n        'global',\n        'if',\n        'import',\n        'in',\n        'is',\n        'lambda',\n        'not',\n        'or',\n        'pass',\n        'print',\n        'raise',\n        'return',\n        'try',\n        'while',\n        'with',\n        'yield',\n#--end keywords--\n        ]\n\ndef iskeyword(wd):\n    return wd in kwlist\n\n", "src/lib/ConfigParser.py": "raise NotImplementedError(\"ConfigParser is not yet implemented in Skulpt\")\n", "src/lib/UserDict.py": "raise NotImplementedError(\"UserDict is not yet implemented in Skulpt\")\n", "src/lib/robotparser.py": "raise NotImplementedError(\"robotparser is not yet implemented in Skulpt\")\n", "src/lib/sha.py": "raise NotImplementedError(\"sha is not yet implemented in Skulpt\")\n", "src/lib/math.js": "var $builtinmodule = function (name) {\n    var mod = {};\n    mod.pi = new Sk.builtin.float_(Math.PI);\n    mod.e = new Sk.builtin.float_(Math.E);\n\n    mod.fabs = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"fabs\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        return new Sk.builtin.float_(Math.abs(Sk.builtin.asnum$(x)));\n    });\n\n    mod.asin = new Sk.builtin.func(function (rad) {\n        Sk.builtin.pyCheckArgs(\"asin\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n        return new Sk.builtin.float_(Math.asin(Sk.builtin.asnum$(rad)));\n    });\n\n    mod.acos = new Sk.builtin.func(function (rad) {\n        Sk.builtin.pyCheckArgs(\"acos\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n        return new Sk.builtin.float_(Math.acos(Sk.builtin.asnum$(rad)));\n    });\n\n    mod.atan = new Sk.builtin.func(function (rad) {\n        Sk.builtin.pyCheckArgs(\"atan\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n        return new Sk.builtin.float_(Math.atan(Sk.builtin.asnum$(rad)));\n    });\n\n    mod.atan2 = new Sk.builtin.func(function (y, x) {\n        Sk.builtin.pyCheckArgs(\"atan2\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"y\", \"number\", Sk.builtin.checkNumber(y));\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        return new Sk.builtin.float_(Math.atan2(Sk.builtin.asnum$(y), Sk.builtin.asnum$(x)));\n    });\n\n    mod.sin = new Sk.builtin.func(function (rad) {\n        Sk.builtin.pyCheckArgs(\"sin\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n        return new Sk.builtin.float_(Math.sin(Sk.builtin.asnum$(rad)));\n    });\n\n    mod.cos = new Sk.builtin.func(function (rad) {\n        Sk.builtin.pyCheckArgs(\"cos\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n        return new Sk.builtin.float_(Math.cos(Sk.builtin.asnum$(rad)));\n    });\n\n    mod.tan = new Sk.builtin.func(function (rad) {\n        Sk.builtin.pyCheckArgs(\"tan\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n        return new Sk.builtin.float_(Math.tan(Sk.builtin.asnum$(rad)));\n    });\n\n    mod.asinh = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"asinh\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        x = Sk.builtin.asnum$(x);\n\n        var L = x + Math.sqrt(x * x + 1);\n\n        return new Sk.builtin.float_(Math.log(L));\n    });\n\n    mod.acosh = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"acosh\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        x = Sk.builtin.asnum$(x);\n\n        var L = x + Math.sqrt(x * x - 1);\n\n        return new Sk.builtin.float_(Math.log(L));\n    });\n\n    mod.atanh = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"atanh\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        x = Sk.builtin.asnum$(x);\n\n        var L = (1 + x) / (1 - x);\n\n        return new Sk.builtin.float_(Math.log(L) / 2);\n    });\n\n    mod.sinh = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"sinh\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        x = Sk.builtin.asnum$(x);\n\n        var e = Math.E;\n        var p = Math.pow(e, x);\n        var n = 1 / p;\n        var result = (p - n) / 2;\n\n        return new Sk.builtin.float_(result);\n    });\n\n    mod.cosh = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"cosh\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        x = Sk.builtin.asnum$(x);\n\n        var e = Math.E;\n        var p = Math.pow(e, x);\n        var n = 1 / p;\n        var result = (p + n) / 2;\n\n        return new Sk.builtin.float_(result);\n    });\n\n    mod.tanh = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"tanh\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        x = Sk.builtin.asnum$(x);\n\n        var e = Math.E;\n        var p = Math.pow(e, x);\n        var n = 1 / p;\n        var result = ((p - n) / 2) / ((p + n) / 2);\n\n        return new Sk.builtin.float_(result);\n    });\n\n    mod.ceil = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"ceil\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        return new Sk.builtin.float_(Math.ceil(Sk.builtin.asnum$(x)));\n    });\n\n    // returns y with the sign of x\n    mod.copysign = new Sk.builtin.func(function (x, y) {\n        Sk.builtin.pyCheckArgs(\"ceil\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n        Sk.builtin.pyCheckType(\"y\", \"number\", Sk.builtin.checkNumber(y));\n\n        var _x = Sk.ffi.remapToJs(x);\n        var _y = Sk.ffi.remapToJs(y);\n        var res;\n\n        var isNeg_x = _x < 0;\n        var isNeg_y = _x < 0;\n\n        // special case for floats with negative zero\n        if(Sk.builtin.checkFloat(x)) {\n            if(_x === 0) {\n                isNeg_x = 1/_x === -Infinity ? true : false;\n            }\n        }\n\n        if(Sk.builtin.checkFloat(y)) {\n            if(_y === 0) {\n                isNeg_y = 1/_y === -Infinity ? true : false;\n            }\n        }\n\n        // if both signs are equal, just return _y\n        if((isNeg_x && isNeg_y) || (!isNeg_x && !isNeg_y)) {\n            res = _y;\n        } else if((isNeg_x && !isNeg_y) || (!isNeg_x && isNeg_y)) {\n            // if different, invert sign\n            if(y === 0) {\n                // special case for zero\n                res = isNeg_x ? -0.0 : 0.0;\n            } else {\n                res = _y * -1;\n            }\n        }\n\n        return new Sk.builtin.float_(res);\n    });\n\n    mod.floor = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"floor\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        return new Sk.builtin.float_(Math.floor(Sk.builtin.asnum$(x)));\n    });\n\n    mod.sqrt = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"sqrt\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        return new Sk.builtin.float_(Math.sqrt(Sk.builtin.asnum$(x)));\n    });\n\n    mod.trunc = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"trunc\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        return new Sk.builtin.int_(Sk.builtin.asnum$(x) | 0);\n    });\n\n    mod.log = new Sk.builtin.func(function (x, base) {\n        Sk.builtin.pyCheckArgs(\"log\", arguments, 1, 2);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        if (base === undefined) {\n            return new Sk.builtin.float_(Math.log(Sk.builtin.asnum$(x)));\n        } else {\n            Sk.builtin.pyCheckType(\"base\", \"number\", Sk.builtin.checkNumber(base));\n            var ret = Math.log(Sk.builtin.asnum$(x)) / Math.log(Sk.builtin.asnum$(base));\n            return new Sk.builtin.float_(ret);\n        }\n    });\n\n    mod.log10 = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"log10\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        var ret = Math.log(Sk.builtin.asnum$(x)) / Math.log(10);\n        return new Sk.builtin.float_(ret);\n    });\n\n    /* Return True if x is infinite, and False otherwise. */\n    mod.isinf = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"isinf\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        var _x = Sk.builtin.asnum$(x);\n        if(isFinite(_x) && !isNaN(_x)) {\n            return Sk.builtin.bool.false$;\n        } else {\n            return Sk.builtin.bool.true$\n        }\n    });\n\n    /* Return True if x is a NaN (not a number), and False otherwise. */\n    mod.isnan = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"isnan\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"float\", Sk.builtin.checkFloat(x));\n\n        var _x = Sk.builtin.asnum$(x);\n        if(isNaN(_x)) {\n            return Sk.builtin.bool.true$;\n        } else {\n            return Sk.builtin.bool.false$;\n        }\n    });\n\n    mod.exp = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"exp\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        return new Sk.builtin.float_(Math.exp(Sk.builtin.asnum$(x)));\n    });\n\n    mod.pow = new Sk.builtin.func(function (x, y) {\n        Sk.builtin.pyCheckArgs(\"pow\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n        Sk.builtin.pyCheckType(\"y\", \"number\", Sk.builtin.checkNumber(y));\n\n        return new Sk.builtin.float_(Math.pow(Sk.builtin.asnum$(x), Sk.builtin.asnum$(y)));\n    });\n\n    mod.radians = new Sk.builtin.func(function (deg) {\n        Sk.builtin.pyCheckArgs(\"radians\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"deg\", \"number\", Sk.builtin.checkNumber(deg));\n\n        var ret = Math.PI / 180.0 * Sk.builtin.asnum$(deg);\n        return new Sk.builtin.float_(ret);\n    });\n\n    mod.degrees = new Sk.builtin.func(function (rad) {\n        Sk.builtin.pyCheckArgs(\"degrees\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n        var ret = 180.0 / Math.PI * Sk.builtin.asnum$(rad);\n        return new Sk.builtin.float_(ret);\n    });\n\n    mod.hypot = new Sk.builtin.func(function (x, y) {\n        Sk.builtin.pyCheckArgs(\"hypot\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n        Sk.builtin.pyCheckType(\"y\", \"number\", Sk.builtin.checkNumber(y));\n\n        x = Sk.builtin.asnum$(x);\n        y = Sk.builtin.asnum$(y);\n        return new Sk.builtin.float_(Math.sqrt((x * x) + (y * y)));\n    });\n\n    mod.factorial = new Sk.builtin.func(function (x) {\n        Sk.builtin.pyCheckArgs(\"factorial\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        x = Math.floor(Sk.builtin.asnum$(x));\n        var r = 1;\n        for (var i = 2; i <= x; i++) {\n            r *= i;\n        }\n        return new Sk.builtin.int_(r);\n    });\n\n    return mod;\n}", "src/lib/shlex.py": "raise NotImplementedError(\"shlex is not yet implemented in Skulpt\")\n", "src/lib/CGIHTTPServer.py": "raise NotImplementedError(\"CGIHTTPServer is not yet implemented in Skulpt\")\n", "src/lib/posixpath.py": "raise NotImplementedError(\"posixpath is not yet implemented in Skulpt\")\n", "src/lib/py_compile.py": "raise NotImplementedError(\"py_compile is not yet implemented in Skulpt\")\n", "src/lib/sunaudio.py": "raise NotImplementedError(\"sunaudio is not yet implemented in Skulpt\")\n", "src/lib/stat.py": "raise NotImplementedError(\"stat is not yet implemented in Skulpt\")\n", "src/lib/compileall.py": "raise NotImplementedError(\"compileall is not yet implemented in Skulpt\")\n", "src/lib/csv.py": "raise NotImplementedError(\"csv is not yet implemented in Skulpt\")\n", "src/lib/fractions.py": "raise NotImplementedError(\"fractions is not yet implemented in Skulpt\")\n", "src/lib/sched.py": "raise NotImplementedError(\"sched is not yet implemented in Skulpt\")\n", "src/lib/xmlrpclib.py": "raise NotImplementedError(\"xmlrpclib is not yet implemented in Skulpt\")\n", "src/lib/imaplib.py": "raise NotImplementedError(\"imaplib is not yet implemented in Skulpt\")\n", "src/lib/htmlentitydefs.py": "raise NotImplementedError(\"htmlentitydefs is not yet implemented in Skulpt\")\n", "src/lib/image.js": "var ImageMod; // the single identifier needed in the global scope\nvar $builtinmodule;\n\nif (!ImageMod) {\n    ImageMod = {};\n    ImageMod.canvasLib = [];\n}\n\n$builtinmodule = function (name) {\n    var screen;\n    var pixel;\n    var eImage;\n    var mod = {};\n    var updateCanvasAndSuspend;\n    var initializeImage;\n    var checkPixelRange;\n    var remapImageIdToURL;\n\n    var image = function ($gbl, $loc) {\n        initializeImage = function (self) {\n            self.width = self.image.width;\n            self.height = self.image.height;\n            self.delay = 0;\n            self.updateCount = 0;\n            self.updateInterval = 1;\n            self.lastx = 0;\n            self.lasty = 0;\n            self.canvas = document.createElement(\"canvas\");\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.ctx = self.canvas.getContext(\"2d\");\n            self.ctx.drawImage(self.image, 0, 0);\n            self.imagedata = self.ctx.getImageData(0, 0, self.width, self.height);\n        };\n\n\n        $loc.__init__ = new Sk.builtin.func(function (self, imageId) {\n            var susp;\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            try {\n                self.image = document.getElementById(Sk.ffi.remapToJs(imageId));\n                initializeImage(self);\n            } catch (e) {\n                self.image = null;\n            }\n            if (self.image == null) {\n                susp = new Sk.misceval.Suspension();\n                susp.resume = function () {\n                    // Should the post image get stuff go here??\n                    if (susp.data[\"error\"]) {\n                        throw new Sk.builtin.IOError(susp.data[\"error\"].message);\n                    }\n                };\n                susp.data = {\n                    type: \"Sk.promise\",\n                    promise: new Promise(function (resolve, reject) {\n                            var newImg = new Image();\n                            newImg.crossOrigin = \"\";\n                            newImg.onerror = function () {\n                                reject(Error(\"Failed to load URL: \" + newImg.src));\n                            };\n                            newImg.onload = function () {\n                                self.image = this;\n                                initializeImage(self);\n                                resolve();\n                            };\n                            // look for mapping from imagename to url and possible an image proxy server\n                            newImg.src = remapImageIdToURL(imageId);\n                        }\n                    )\n                };\n                return susp;\n            }\n\n        });\n\n        remapImageIdToURL = function (imageId) {\n            // if imageId starts with http -- OK\n            // if imageId is in Sk.imageMap -- look it up\n            // if imageId is the name of an image file prepend http://host/app/book/_static/\n            // if image proxy server is configured construct url for proxy\n            // return the final URL\n            var url;\n            var ret;\n            ret = Sk.ffi.remapToJs(imageId);\n            url = document.createElement(\"a\");\n            url.href = ret;\n            if (window.location.host !== url.host) {\n                ret = Sk.imageProxy + \"/\" + ret;\n            }\n            return ret;\n        };\n\n        checkPixelRange = function (self, x, y) {\n            if (x < 0 || y < 0 || x >= self.width || y >= self.height) {\n                throw new Sk.builtin.ValueError(\"Pixel index out of range.\");\n            }\n        };\n\n        var setdelay = new Sk.builtin.func(function (self, delay, interval) {\n            var i;\n            Sk.builtin.pyCheckArgs(\"setdelay\", arguments, 2, 3);\n            self.delay = Sk.ffi.remapToJs(delay);\n            i = Sk.builtin.asnum$(interval);\n            if (!i) {\n                self.updateInterval = 1;\n            } else {\n                self.updateInterval = i;\n            }\n        });\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.set_delay = new Sk.builtin.func(setdelay);\n        $loc.setDelay = new Sk.builtin.func(setdelay);\n\n\n        //get a one-dimensional array of pixel objects - Zhu\n        var getpixels = function (self) {\n            var arr = [];//initial array\n            var i;\n            Sk.builtin.pyCheckArgs(\"getpixels\", arguments, 1, 1);\n\n            for (i = 0; i < self.image.height * self.image.width; i++) {\n\n                arr[i] = Sk.misceval.callsim(self.getPixel, self,\n                    i % self.image.width, Math.floor(i / self.image.width));\n            }\n            return new Sk.builtin.tuple(arr);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.get_pixels = new Sk.builtin.func(getpixels);\n        $loc.getPixels = new Sk.builtin.func(getpixels);\n\n\n        var getpixel = function (self, x, y) {\n            var red;\n            var blue;\n            var green;\n            var index;\n            Sk.builtin.pyCheckArgs(\"getpixel\", arguments, 3, 3);\n            x = Sk.builtin.asnum$(x);\n            y = Sk.builtin.asnum$(y);\n            checkPixelRange(self, x, y);\n            index = (y * 4) * self.width + (x * 4);\n            red = self.imagedata.data[index];\n            green = self.imagedata.data[index + 1];\n            blue = self.imagedata.data[index + 2];\n            return Sk.misceval.callsim(mod.Pixel, red, green, blue, x, y);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.get_pixel = new Sk.builtin.func(getpixel);\n        $loc.getPixel = new Sk.builtin.func(getpixel);\n\n\n        updateCanvasAndSuspend = function (self, x, y) {\n            var susp = new Sk.misceval.Suspension();\n            susp.resume = function () {\n                return Sk.builtin.none.none$;\n            };\n            susp.data = {\n                type: \"Sk.promise\",\n                promise: new Promise(function (resolve, reject) {\n                    self.updateCount++;\n                    if ((self.updateCount % self.updateInterval) === 0) {\n                        if (self.lastx + self.updateInterval >= self.width) {\n                            self.lastCtx.putImageData(self.imagedata, self.lastUlx, self.lastUly,\n                                0, self.lasty, self.width, 2);\n                        } else if (self.lasty + self.updateInterval >= self.height) {\n                            self.lastCtx.putImageData(self.imagedata, self.lastUlx, self.lastUly,\n                                self.lastx, 0, 2, self.height);\n                        } else {\n                            self.lastCtx.putImageData(self.imagedata, self.lastUlx, self.lastUly,\n                                Math.min(x, self.lastx),\n                                Math.min(y, self.lasty),\n                                Math.max(Math.abs(x - self.lastx), 1),\n                                Math.max(Math.abs(y - self.lasty), 1));\n                        }\n                        self.lastx = x;\n                        self.lasty = y;\n                        if (self.delay > 0) {\n                            window.setTimeout(resolve, self.delay);\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        resolve();\n                    }\n                })\n            };\n            return susp;\n        };\n\n        var setpixel = function (self, x, y, pix) {\n            var index;\n            Sk.builtin.pyCheckArgs(\"setpixel\", arguments, 4, 4);\n            x = Sk.builtin.asnum$(x);\n            y = Sk.builtin.asnum$(y);\n            checkPixelRange(self, x, y);\n            index = (y * 4) * self.width + (x * 4);\n            self.imagedata.data[index] = Sk.builtin.asnum$(Sk.misceval.callsim(pix.getRed, pix));\n            self.imagedata.data[index + 1] = Sk.builtin.asnum$(Sk.misceval.callsim(pix.getGreen, pix));\n            self.imagedata.data[index + 2] = Sk.builtin.asnum$(Sk.misceval.callsim(pix.getBlue, pix));\n            self.imagedata.data[index + 3] = 255;\n            return updateCanvasAndSuspend(self, x, y);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.set_pixel = new Sk.builtin.func(setpixel);\n        $loc.setPixel = new Sk.builtin.func(setpixel);\n\n\n        // update the image with the pixel at the given count - Zhu\n        var setpixelat = function (self, count, pixel) {\n            var x;\n            var y;\n            var index;\n            Sk.builtin.pyCheckArgs(\"setpixelat\", arguments, 3, 3);\n            count = Sk.builtin.asnum$(count);\n            x = count % self.image.width;\n            y = Math.floor(count / self.image.width);\n            checkPixelRange(self, x, y);\n            index = (y * 4) * self.width + (x * 4);\n            self.imagedata.data[index] = Sk.builtin.asnum$(Sk.misceval.callsim(pixel.getRed, pixel));\n            self.imagedata.data[index + 1] = Sk.builtin.asnum$(Sk.misceval.callsim(pixel.getGreen, pixel));\n            self.imagedata.data[index + 2] = Sk.builtin.asnum$(Sk.misceval.callsim(pixel.getBlue, pixel));\n            self.imagedata.data[index + 3] = 255;\n            return updateCanvasAndSuspend(self, x, y);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.set_pixel_at = new Sk.builtin.func(setpixelat);\n        $loc.setPixelAt = new Sk.builtin.func(setpixelat);\n\n\n        // new updatePixel that uses the saved x and y location in the pixel - Barb Ericson\n        var updatepixel = function (self, pixel) {\n            var x;\n            var y;\n            var index;\n            Sk.builtin.pyCheckArgs(\"updatepixel\", arguments, 2, 2);\n            x = Sk.builtin.asnum$(Sk.misceval.callsim(pixel.getX, pixel));\n            y = Sk.builtin.asnum$(Sk.misceval.callsim(pixel.getY, pixel));\n            checkPixelRange(self, x, y);\n            index = (y * 4) * self.width + (x * 4);\n            self.imagedata.data[index] = Sk.builtin.asnum$(Sk.misceval.callsim(pixel.getRed, pixel));\n            self.imagedata.data[index + 1] = Sk.builtin.asnum$(Sk.misceval.callsim(pixel.getGreen, pixel));\n            self.imagedata.data[index + 2] = Sk.builtin.asnum$(Sk.misceval.callsim(pixel.getBlue, pixel));\n            self.imagedata.data[index + 3] = 255;\n            return updateCanvasAndSuspend(self, x, y);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.update_pixel = new Sk.builtin.func(updatepixel);\n        $loc.updatePixel = new Sk.builtin.func(updatepixel);\n\n\n        var getheight = function (self) {\n            Sk.builtin.pyCheckArgs(\"getheight\", arguments, 1, 1);\n            return new Sk.builtin.int_(self.image.height);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.get_height = new Sk.builtin.func(getheight);\n        $loc.getHeight = new Sk.builtin.func(getheight);\n\n\n        var getwidth = function (self, titlestring) {\n            Sk.builtin.pyCheckArgs(\"getwidth\", arguments, 1, 1);\n            return new Sk.builtin.int_(self.image.width);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.get_width = new Sk.builtin.func(getwidth);\n        $loc.getWidth = new Sk.builtin.func(getwidth);\n\n\n        $loc.draw = new Sk.builtin.func(function (self, win, ulx, uly) {\n            var susp;\n            Sk.builtin.pyCheckArgs(\"draw\", arguments, 2, 4);\n            susp = new Sk.misceval.Suspension();\n            susp.resume = function () {\n                return Sk.builtin.none.none$;\n            };\n            susp.data = {\n                type: \"Sk.promise\",\n                promise: new Promise(function (resolve, reject) {\n                    var can;\n                    var ctx;\n                    win = Sk.builtin.asnum$(win);\n                    ulx = Sk.builtin.asnum$(ulx);\n                    uly = Sk.builtin.asnum$(uly);\n                    can = Sk.misceval.callsim(win.getWin, win);\n                    ctx = can.getContext(\"2d\");\n                    if (!ulx) {\n                        ulx = 0;\n                        uly = 0;\n                    }\n                    self.lastUlx = ulx;\n                    self.lastUly = uly;\n                    self.lastCtx = ctx;  // save a reference to the context of the window the image was last drawn in\n                    //ctx.putImageData(self.imagedata,0,0,0,0,self.imagedata.width,self.imagedata.height);\n                    ctx.putImageData(self.imagedata, ulx, uly);\n\n                    if (self.delay > 0) {\n                        window.setTimeout(resolve, self.delay);\n                    } else {\n                        window.setTimeout(resolve, 200);\n                    }\n                })\n            };\n            return susp;\n\n        });\n\n        // toList\n\n    };\n\n    mod.Image = Sk.misceval.buildClass(mod, image, \"Image\", []);\n\n    eImage = function ($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self, width, height) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 3, 3);\n            self.width = Sk.builtin.asnum$(width);\n            self.height = Sk.builtin.asnum$(height);\n            self.canvas = document.createElement(\"canvas\");\n            self.ctx = self.canvas.getContext(\"2d\");\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.imagedata = self.ctx.getImageData(0, 0, self.width, self.height);\n        });\n\n    };\n\n    mod.EmptyImage = Sk.misceval.buildClass(mod, eImage, \"EmptyImage\", [mod.Image]);\n\n    // create a ListImage object\n\n\n    pixel = function ($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self, r, g, b, x, y) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 4, 6);\n            self.red = Sk.builtin.asnum$(r);\n            self.green = Sk.builtin.asnum$(g);\n            self.blue = Sk.builtin.asnum$(b);\n            self.x = Sk.builtin.asnum$(x);\n            self.y = Sk.builtin.asnum$(y);\n        });\n\n        var getred = function (self) {\n            Sk.builtin.pyCheckArgs(\"getred\", arguments, 1, 1);\n            return Sk.builtin.assk$(self.red);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.get_red = new Sk.builtin.func(getred);\n        $loc.getRed = new Sk.builtin.func(getred);\n\n        var getgreen = function (self) {\n            Sk.builtin.pyCheckArgs(\"getgreen\", arguments, 1, 1);\n            return Sk.builtin.assk$(self.green);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.get_green = new Sk.builtin.func(getgreen);\n        $loc.getGreen = new Sk.builtin.func(getgreen);\n\n        var getblue = function (self) {\n            Sk.builtin.pyCheckArgs(\"getblue\", arguments, 1, 1);\n            return Sk.builtin.assk$(self.blue);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.get_blue = new Sk.builtin.func(getblue);\n        $loc.getBlue = new Sk.builtin.func(getblue);\n\n        var getx = function (self) {\n            Sk.builtin.pyCheckArgs(\"getx\", arguments, 1, 1);\n            return Sk.builtin.assk$(self.x);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.get_x = new Sk.builtin.func(getx);\n        $loc.getX = new Sk.builtin.func(getx);\n\n        var gety = function (self) {\n            Sk.builtin.pyCheckArgs(\"gety\", arguments, 1, 1);\n            return Sk.builtin.assk$(self.y);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.get_y = new Sk.builtin.func(gety);\n        $loc.getY = new Sk.builtin.func(gety);\n\n        var setred = function (self, r) {\n            Sk.builtin.pyCheckArgs(\"setred\", arguments, 2, 2);\n            self.red = Sk.builtin.asnum$(r);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.set_red = new Sk.builtin.func(setred);\n        $loc.setRed = new Sk.builtin.func(setred);\n\n        var setgreen = function (self, g) {\n            Sk.builtin.pyCheckArgs(\"setgreen\", arguments, 2, 2);\n            self.green = Sk.builtin.asnum$(g);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.set_green = new Sk.builtin.func(setgreen);\n        $loc.setGreen = new Sk.builtin.func(setgreen);\n\n        var setblue = function (self, b) {\n            Sk.builtin.pyCheckArgs(\"setblue\", arguments, 2, 2);\n            self.blue = Sk.builtin.asnum$(b);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.set_blue = new Sk.builtin.func(setblue);\n        $loc.setBlue = new Sk.builtin.func(setblue);\n\n        var setx = function (self, x) {\n            Sk.builtin.pyCheckArgs(\"setx\", arguments, 2, 2);\n            self.x = Sk.builtin.asnum$(x);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.set_x = new Sk.builtin.func(setx);\n        $loc.setX = new Sk.builtin.func(setx);\n\n        var sety = function (self, y) {\n            Sk.builtin.pyCheckArgs(\"sety\", arguments, 2, 2);\n            self.y = Sk.builtin.asnum$(y);\n        };\n\n        // alias the function with pep8 compliant snake_case and legacy camelCase\n        $loc.set_y = new Sk.builtin.func(sety);\n        $loc.setY = new Sk.builtin.func(sety);\n\n        $loc.__getitem__ = new Sk.builtin.func(function (self, k) {\n            k = Sk.builtin.asnum$(k);\n            if (k === 0) {\n                return self.red;\n            } else if (k == 1) {\n                return self.green;\n            } else if (k == 2) {\n                return self.blue;\n            }\n        });\n\n        $loc.__str__ = new Sk.builtin.func(function (self) {\n            return \"[\" + self.red + \",\" + self.green + \",\" + self.blue + \"]\";\n        });\n\n        //getColorTuple\n        $loc.getColorTuple = new Sk.builtin.func(function (self, x, y) {\n\n        });\n\n        //setRange -- change from 0..255 to 0.0 .. 1.0\n        $loc.setRange = new Sk.builtin.func(function (self, mx) {\n            self.max = Sk.builtin.asnum$(mx);\n        });\n\n    };\n    mod.Pixel = Sk.misceval.buildClass(mod, pixel, \"Pixel\", []);\n\n\n    screen = function ($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self, width, height) {\n            var currentCanvas;\n            var tmpCan, tmpDiv;\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 1, 3);\n            currentCanvas = ImageMod.canvasLib[Sk.canvas];\n            if (currentCanvas === undefined) {\n                tmpCan = document.createElement(\"canvas\");\n                tmpDiv = document.getElementById(Sk.canvas);\n                self.theScreen = tmpCan;\n                tmpDiv.appendChild(tmpCan);\n                ImageMod.canvasLib[Sk.canvas] = tmpCan;\n                ImageMod.canvasLib[Sk.canvas] = self.theScreen;\n            } else {\n                self.theScreen = currentCanvas;\n                self.theScreen.height = self.theScreen.height;\n            }\n            if (width !== undefined) {\n                self.theScreen.height = height.v;\n                self.theScreen.width = width.v;\n            } else {\n                if (Sk.availableHeight) {\n                    self.theScreen.height = Sk.availableHeight;\n                }\n                if (Sk.availableWidth) {\n                    self.theScreen.width = Sk.availableWidth;\n                }\n            }\n\n            self.theScreen.style.display = \"block\";\n        });\n\n        $loc.getWin = new Sk.builtin.func(function (self) {\n            return self.theScreen;\n        });\n\n        // exitonclick\n        $loc.exitonclick = new Sk.builtin.func(function (self) {\n            var canvas_id = self.theScreen.id;\n            self.theScreen.onclick = function () {\n                document.getElementById(canvas_id).style.display = \"none\";\n                document.getElementById(canvas_id).onclick = null;\n                delete ImageMod.canvasLib[canvas_id];\n            };\n\n        });\n        //getMouse\n    };\n\n    mod.ImageWin = Sk.misceval.buildClass(mod, screen, \"ImageWin\", []);\n\n    return mod;\n};\n", "src/lib/mailbox.py": "raise NotImplementedError(\"mailbox is not yet implemented in Skulpt\")\n", "src/lib/sre_compile.py": "raise NotImplementedError(\"sre_compile is not yet implemented in Skulpt\")\n", "src/lib/re.js": "var $builtinmodule = function (name) {\n    var mod = {};\n\n    var validGroups, convert, getFlags, _split, _findall, matchobj, _search, _match, regexobj;\n\n    // Constants (mostly unsupported)\n    mod.I = 2;\n    mod.IGNORECASE = 2;\n    // mod.L = 4;\n    // mod.LOCALE = 4;\n    mod.M = 8;\n    mod.MULTILINE = 8;\n    // mod.S = 16;\n    // mod.DOTALL = 16;\n    // mod.U = 32;\n    // mod.UNICODE = 32;\n    // mod.X = 64;\n    // mod.VERBOSE = 64;\n\n    validGroups = [\"(?:\", \"(?=\", \"(?!\"];\n\n    convert = function (pattern) {\n        var newpattern;\n        var match;\n        var i;\n\n        // Look for disallowed constructs\n        match = pattern.match(/\\(\\?./g);\n        if (match) {\n            for (i = 0; i < match.length; i++) {\n                if (validGroups.indexOf(match[i]) == -1) {\n                    throw new Sk.builtin.ValueError(\"Disallowed group in pattern: '\"\n                        + match[i] + \"'\");\n                }\n            }\n        }\n\n        newpattern = pattern.replace(\"/\\\\/g\", \"\\\\\\\\\");\n        newpattern = pattern.replace(/([^\\\\]){,(?![^\\[]*\\])/g, \"$1{0,\");\n\n        return newpattern;\n    };\n\n    getFlags = function (flags) {\n        var jsflags = \"g\";\n        if ((flags & mod.IGNORECASE) == mod.IGNORECASE) {\n            jsflags += \"i\";\n        }\n        if ((flags & mod.MULTILINE) == mod.MULTILINE) {\n            jsflags += \"m\";\n        }\n        return jsflags;\n    };\n\n    _split = function (pattern, string, maxsplit, flags) {\n        var pat, str, captured, jsflags, regex;\n        var result, match, index, splits;\n\n        Sk.builtin.pyCheckArgs(\"split\", arguments, 2, 4);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        }\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError(\"string must be a string\");\n        }\n        if (maxsplit === undefined) {\n            maxsplit = 0;\n        }\n        if (!Sk.builtin.checkNumber(maxsplit)) {\n            throw new Sk.builtin.TypeError(\"maxsplit must be a number\");\n        }\n        if (flags === undefined) {\n            flags = 0;\n        }\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        }\n\n        maxsplit = Sk.builtin.asnum$(maxsplit);\n        pat = Sk.ffi.unwrapo(pattern);\n        str = Sk.ffi.unwrapo(string);\n\n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print(\"Pat: \" + pat);\n        //print(\"Str: \" + str);\n\n        captured = !(pat.match(/^\\(.*\\)$/) === null);\n        //print(\"Captured: \", captured);\n\n        jsflags = getFlags(flags);\n        //print(\"Flags: \", jsflags);\n\n        regex = new RegExp(pat, jsflags);\n\n        result = [];\n        match;\n        index = 0;\n        splits = 0;\n        while ((match = regex.exec(str)) != null) {\n            //print(\"Matched '\" + match[0] + \"' at position \" + match.index + \n            //      \"; next search at \" + regex.lastIndex);\n            if (match.index === regex.lastIndex) {\n                // empty match\n                break;\n            }\n            result.push(new Sk.builtin.str(str.substring(index, match.index)));\n            if (captured) {\n                // Add matching pattern, too\n                result.push(new Sk.builtin.str(match[0]));\n            }\n            index = regex.lastIndex;\n            splits += 1;\n            if (maxsplit && (splits >= maxsplit)) {\n                break;\n            }\n        }\n        result.push(new Sk.builtin.str(str.substring(index)));\n\n        return new Sk.builtin.list(result);\n    };\n\n    _split.co_varnames = [\"pattern\", \"string\", \"maxsplit\", \"flags\"];\n    _split.co_numargs = 4;\n    _split.$defaults = [ new Sk.builtin.int_(0), new Sk.builtin.int_(0) ];\n\n    mod.split = new Sk.builtin.func(_split);\n\n    _findall = function (pattern, string, flags) {\n        var pat, str, jsflags, regex, result, match;\n\n        Sk.builtin.pyCheckArgs(\"findall\", arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        }\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError(\"string must be a string\");\n        }\n        if (flags === undefined) {\n            flags = 0;\n        }\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        }\n\n        pat = Sk.ffi.unwrapo(pattern);\n        str = Sk.ffi.unwrapo(string);\n\n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print(\"Pat: \" + pat);\n        //print(\"Str: \" + str);\n\n        jsflags = getFlags(flags);\n        //print(\"Flags: \", jsflags);\n\n        regex = new RegExp(pat, jsflags);\n\n        if (pat.match(/\\$/)) {\n            var newline_at_end = new RegExp(/\\n$/);\n            if (str.match(newline_at_end)) {\n                str = str.slice(0, -1);\n            }\n        }\n\n        result = [];\n        match;\n        while ((match = regex.exec(str)) != null) {\n            //print(\"Matched '\" + match[0] + \"' at position \" + match.index + \n            //      \"; next search at \" + regex.lastIndex);\n            // print(\"match: \" + JSON.stringify(match));\n            if (match.length < 2) {\n                result.push(new Sk.builtin.str(match[0]));\n            } else if (match.length == 2) {\n                result.push(new Sk.builtin.str(match[1]));\n            } else {\n                var groups = [];\n                for (var i = 1; i < match.length; i++) {\n                    groups.push(new Sk.builtin.str(match[i]));\n                }\n                result.push(new Sk.builtin.tuple(groups));\n            }\n            if (match.index === regex.lastIndex) {\n                regex.lastIndex += 1;\n            }\n        }\n\n        return new Sk.builtin.list(result);\n    };\n\n    _findall.co_varnames = [\"pattern\", \"string\", \"flags\"];\n    _findall.co_numargs = 3;\n    _findall.$defaults = [ new Sk.builtin.int_(0) ];\n\n    mod.findall = new Sk.builtin.func(_findall);\n\n\n    matchobj = function ($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self, thematch, pattern, string) {\n            self.thematch = thematch;\n            self.re = pattern;\n            self.string = string;\n        });\n\n        $loc.groups = new Sk.builtin.func(function (self) {\n            var _groups = self.thematch.v.slice(1);\n\n            return new Sk.builtin.tuple(_groups)\n        });\n\n        $loc.group = new Sk.builtin.func(function (self, grpnum) {\n            if (grpnum === undefined) {\n                grpnum = 0;\n            }\n            else {\n                grpnum = Sk.builtin.asnum$(grpnum);\n            }\n            if (grpnum >= self.thematch.v.length) {\n                throw new Sk.builtin.IndexError(\"Index out of range: \" + grpnum);\n            }\n            return self.thematch.v[grpnum];\n        });\n\n    };\n\n    mod.MatchObject = Sk.misceval.buildClass(mod, matchobj, \"MatchObject\", []);\n\n    // Internal function to return a Python list of strings \n    // From a JS regular expression string\n    mod._findre = function (res, string) {\n        res = res.replace(/([^\\\\]){,(?![^\\[]*\\])/g, \"$1{0,\");\n\n        var matches, sitem, retval;\n        var re = eval(res);\n        var patt = new RegExp(\"\\n$\");\n        var str = Sk.ffi.remapToJs(string);\n\n        if (str.match(patt)) {\n            matches = str.slice(0, -1).match(re);\n        }\n        else {\n            matches = str.match(re);\n        }\n        retval = new Sk.builtin.list();\n        if (matches == null) {\n            return retval;\n        }\n        for (var i = 0; i < matches.length; ++i) {\n            sitem = new Sk.builtin.str(matches[i]);\n            retval.v.push(sitem);\n        }\n        return retval;\n    };\n\n\n    // Internal search, shared between search function and RegexObject.search method\n    _search = function (pattern, string, flags) {\n        var mob, res;\n\n        Sk.builtin.pyCheckArgs(\"search\", arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        }\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError(\"string must be a string\");\n        }\n        if (flags === undefined) {\n            flags = 0;\n        }\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        }\n        res = \"/\" + pattern.v.replace(/\\//g, \"\\\\/\") + \"/\";\n        lst = mod._findre(res, string);\n        if (lst.v.length < 1) {\n            return Sk.builtin.none.none$;\n        }\n        mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    };\n\n    _search.co_varnames = [\"pattern\", \"string\", \"flags\"];\n    _search.co_numargs = 3;\n    _search.$defaults = [ new Sk.builtin.int_(0) ];\n\n    mod.search = new Sk.builtin.func(_search);\n\n    _match = function (pattern, string, flags) {\n        var mob, res;\n        Sk.builtin.pyCheckArgs(\"match\", arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        }\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError(\"string must be a string\");\n        }\n        if (flags === undefined) {\n            flags = 0;\n        }\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        }\n        pat = Sk.ffi.remapToJs(pattern);\n        res = \"/^\" + pat.replace(/\\//g, \"\\\\/\") + \"/\";\n        lst = mod._findre(res, string);\n        if (Sk.ffi.remapToJs(lst).length < 1) {\n            return Sk.builtin.none.none$;\n        }\n        mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    };\n\n    _match.co_varnames = [\"pattern\", \"string\", \"flags\"];\n    _match.co_numargs = 3;\n    _match.$defaults = [ new Sk.builtin.int_(0) ];\n\n    mod.match = new Sk.builtin.func(_match);\n\n    regexobj = function ($gbl, $loc) {\n        var _slice, _re_search, _re_match, _re_split, _re_findall, _repr;\n\n        $loc.__init__ = new Sk.builtin.func(function (self, pattern, flags) {\n            self.re = pattern;\n            if (flags === undefined) {\n                self.flags = 0;\n            }\n            else {\n                self.flags = flags;\n            }\n        });\n\n        _repr = new Sk.builtin.func( function (self) {\n            var ret = \"re.compile('\" + Sk.ffi.remapToPy(self.re) + \"')\";\n            return Sk.ffi.remapToPy(ret.substring(0,212));\n    });\n\n        $loc.__str__ = _repr;\n\n        $loc.__repr__ = _repr;\n\n        // Given a string, start, and end position, return sliced string\n        _slice = function(string, pos, endpos) {\n            // Per docs, ^ should match index after newlines.\n            // this matches the first\n            var str = Sk.ffi.remapToJs(string);\n            var start = pos == undefined ? 0 : Sk.ffi.remapToJs(pos);\n            var end = endpos == undefined ? str.length : Sk.ffi.remapToJs(endpos);\n\n            if (start == \"^\") {\n                start = str.indexOf('\\n') + 1;\n            }\n            if (end == Sk.builtin.none.none$) {\n                end = str.length;\n            }\n            return Sk.ffi.remapToPy(str.substring(start, end));\n\n        };\n\n        _re_search = function (self, string, pos, endpos) {\n            Sk.builtin.pyCheckArgs(\"search\", arguments, 2, 4);\n\n            var str = _slice(string, pos, endpos);\n\n            return _search(self.re, str, self.flags);\n        };\n\n        _re_search.co_varnames = [\"self\", \"string\", \"pos\", \"endpos\"];\n        _re_search.co_numargs = 4;\n        _re_search.$defaults = [ new Sk.builtin.int_(0), Sk.builtin.none.none$ ];\n\n        $loc.search = new Sk.builtin.func(_re_search);\n\n        _re_match = function (self, string, pos, endpos) {\n            Sk.builtin.pyCheckArgs(\"match\", arguments, 2, 4);\n\n            var str = _slice(string, pos, endpos);\n            // var str = string;\n\n            return _match(self.re, str, self.flags);\n        };\n\n        _re_match.co_varnames = [\"self\", \"string\", \"pos\", \"endpos\"];\n        _re_match.co_numargs = 4;\n        _re_match.$defaults = [ new Sk.builtin.int_(0), Sk.builtin.none.none$ ];\n\n        $loc.match = new Sk.builtin.func(_re_match);\n\n        _re_split = function (self, string, maxsplit) {\n            Sk.builtin.pyCheckArgs(\"split\", arguments, 2, 3);\n\n            if (maxsplit === undefined) {\n                maxsplit = 0;\n            }\n            if (!Sk.builtin.checkInt(maxsplit)) {\n                throw new Sk.builtin.TypeError(\"maxsplit must be an integer\");\n            }\n\n            return _split(self.re, string, maxsplit, self.flags);\n        };\n\n        _re_split.co_varnames = [\"self\", \"string\", \"maxsplit\"];\n        _re_split.co_numargs = 3;\n        _re_split.$defaults = [ new Sk.builtin.int_(0) ];\n\n        $loc.split = new Sk.builtin.func(_re_split);\n\n        _re_findall = function (self, string, pos, endpos) {\n            Sk.builtin.pyCheckArgs(\"findall\", arguments, 2, 4);\n\n            var str = _slice(string, pos, endpos);\n\n            return _findall(self.re, str, self.flags);\n        };\n\n        _re_findall.co_varnames = [\"self\", \"string\", \"pos\", \"endpos\"];\n        _re_findall.co_numargs = 4;\n        _re_findall.$defaults = [ new Sk.builtin.int_(0), Sk.builtin.none.none$ ];\n\n        $loc.findall = new Sk.builtin.func(_re_findall);\n\n    };\n\n    mod.RegexObject = Sk.misceval.buildClass(mod, regexobj, \"RegexObject\", []);\n    mod.compile = new Sk.builtin.func(function (pattern, flags) {\n        var rob;\n        Sk.builtin.pyCheckArgs(\"compile\", arguments, 1, 2);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        }\n        if (flags === undefined) {\n            flags = 0;\n        }\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        }\n        rob = Sk.misceval.callsim(mod.RegexObject, pattern, flags);\n        return rob;\n    });\n\n    // No need to purge since we don't cache\n    mod.purge = new Sk.builtin.func(function () {});\n\n    return mod;\n};", "src/lib/locale.py": "raise NotImplementedError(\"locale is not yet implemented in Skulpt\")\n", "src/lib/doctest.py": "raise NotImplementedError(\"doctest is not yet implemented in Skulpt\")\n", "src/lib/new.py": "raise NotImplementedError(\"new is not yet implemented in Skulpt\")\n", "src/lib/getpass.py": "raise NotImplementedError(\"getpass is not yet implemented in Skulpt\")\n", "src/lib/dumbdbm.py": "raise NotImplementedError(\"dumbdbm is not yet implemented in Skulpt\")\n", "src/lib/pickle.py": "raise NotImplementedError(\"pickle is not yet implemented in Skulpt\")\n", "src/lib/pty.py": "raise NotImplementedError(\"pty is not yet implemented in Skulpt\")\n", "src/lib/dummy_thread.py": "raise NotImplementedError(\"dummy_thread is not yet implemented in Skulpt\")\n", "src/lib/whichdb.py": "raise NotImplementedError(\"whichdb is not yet implemented in Skulpt\")\n", "src/lib/contextlib.py": "raise NotImplementedError(\"contextlib is not yet implemented in Skulpt\")\n", "src/lib/tifa.py": "'''\nPython Type Inferencer and Flow Analyzer (TIFA)\n \nTIFA uses a number of simplifications of the Python language.\n  * Variables cannot change type\n  * Variables cannot be deleted\n  * Complex types have to be homogenous\n  * No introspection or reflective characteristics\n  * No dunder methods\n  * No closures (maybe?)\n  * You cannot write a variable out of scope\n  * You cannot read a mutable variable out of scope\n  * No multiple inheritance\n  \nAdditionally, it reads the following as issues:\n  * Cannot read a variable without having first written to it.\n  * Cannot rewrite a variable unless it has been read.\n  \nImportant concepts:\n    Issue: A problematic situation in the submitted code that will be reported\n           but may not stop the execution.\n    Error: A situation in execution that terminates the program.\n    Name: A name of a variable\n    Scope: The context of a function, with its own namespaces. Represented\n           internally using numeric IDs (Scope IDs).\n    Scope Chain: A stack of scopes, with the innermost scope on top.\n    Fully Qualified Name: A string representation of a variable and its scope\n                          chain, written using \"/\". For example:\n                          0/1/4/my_variable_name\n    Path: A single path of execution through the control flow; every program\n          has at least one sequential path, but IFs, FORs, WHILEs, etc. can\n          cause multiple paths. Paths are represented using numeric IDs (Path\n          IDs).\n    State: Information about a Name that indicates things like the variable's\n           current type and whether that name has been read, set, or\n           overwritten.\n    Identifier: A wrapper around variables, used to hold their potential\n                non-existence (which is an Issue but not an Error).\n    Type: A symbolic representation of the variable's type.\n    Literal: Sometimes, we need a specialized representation of a literal value\n             to be passed around. This is particularly important for accessing\n             elements in an tuples.\n    Name Map: (Path x Fully Qualified Names) => States\n'''\n\nimport ast\nfrom pprint import pprint\n\ndef _dict_extends(d1, d2):\n    d3 = {}\n    for key, value in d1.items():\n        d3[key] = value\n    for key, value in d2.items():\n        d3[key] = value\n    return d3\n\nclass Type:\n    '''\n    Parent class for all other types, used to provide a common interface.\n    \n    TODO: Handle more complicated object-oriented types and custom types\n    (classes).\n    '''\n    fields = {}\n    immutable = False\n    def clone(self):\n        return self.__class__()\n    def __str__(self):\n        return str(self.__class__.__name__)\n    def clone_mutably(self):\n        if self.immutable:\n            return self.clone()\n        else:\n            return self\n    def index(self, i):\n        return self.clone()\n    def load_attr(self, attr, tifa, callee=None, callee_position=None):\n        if attr in self.fields:\n            return self.fields[attr]\n        # TODO: Handle more kinds of common mistakes\n        if attr == \"append\":\n            tifa.report_issue('Append to non-list', \n                              {'name': tifa.identify_caller(callee), \n                               'position': callee_position, 'type': self})\n        return UnknownType()\n    def is_empty(self):\n        return True\n    \n\nclass UnknownType(Type):\n    '''\n    A special type used to indicate an unknowable type.\n    '''\n\nclass RecursedType(Type):\n    '''\n    A special type used as a placeholder for the result of a\n    recursive call that we have already process. This type will\n    be dominated by any actual types, but will not cause an issue.\n    '''\n\nclass FunctionType(Type):\n    '''\n    \n    Special values for `returns`:\n        identity: Returns the first argument's type\n        element: Returns the first argument's first element's type\n        void: Returns the NoneType\n    '''\n    def __init__(self, definition=None, name=\"*Anonymous\", returns=None):\n        if returns is not None and definition is None:\n            if returns == 'identity':\n                def definition(ti, ty, na, args, ca):\n                    if args:\n                        return args[0].clone()\n                    return UnknownType()\n            elif returns == 'element':\n                def definition(ti, ty, na, args, ca):\n                    if args:\n                        return args[0].index(0)\n                    return UnknownType()\n            elif returns == 'void':\n                def definition(ti, ty, na, args, ca):\n                    return NoneType()\n            else:\n                def definition(ti, ty, na, args, ca):\n                    return returns.clone()\n        self.definition = definition\n        self.name = name\n        \nclass ClassType(Type):\n    def __init__(self, name):\n        self.name = name\n        \nclass NumType(Type):\n    immutable = True\n    def index(self, i):\n        return UnknownType()\n    \nclass NoneType(Type):\n    immutable = True\n    \nclass BoolType(Type):\n    immutable = True\n\nclass TupleType(Type):\n    '''\n    '''\n    def __init__(self, subtypes=None):\n        if subtypes is None:\n            subtypes = []\n        self.subtypes = subtypes\n    def index(self, i):\n        if isinstance(i, LiteralNum):\n            return self.subtypes[i.value].clone()\n        else:\n            return self.subtypes[i].clone()\n    def clone(self):\n        return TupleType([t.clone() for t in self.subtypes])\n    immutable = True\n\nclass ListType(Type):\n    def __init__(self, subtype=None, empty=True):\n        if subtype is None:\n            subtype = UnknownType()\n        self.subtype = subtype\n        self.empty = empty\n    def index(self, i):\n        return self.subtype.clone()\n    def clone(self):\n        return ListType(self.subtype.clone(), self.empty)\n    def load_attr(self, attr, tifa, callee=None, callee_position=None):\n        if attr == 'append':\n            def _append(tifa, function_type, callee, args, position):\n                if args:\n                    if callee:\n                        tifa.append_variable(callee, ListType(args[0].clone()), \n                                             position)\n                    self.empty = False\n                    self.subtype = args[0]\n            return FunctionType(_append, 'append')\n        return Type.load_attr(self, attr, tifa, callee, callee_position)\n    def is_empty(self):\n        return self.empty\n\nclass StrType(Type):\n    def index(self, i):\n        return StrType()\n    fields = _dict_extends(Type.fields, {})\n    immutable = True\n\nStrType.fields.update({\n    # Methods that return strings\n    \"capitalize\": FunctionType(name='capitalize', returns=StrType()),\n    \"center\": FunctionType(name='center', returns=StrType()),\n    \"expandtabs\": FunctionType(name='expandtabs', returns=StrType()),\n    \"join\": FunctionType(name='join', returns=StrType()),\n    \"ljust\": FunctionType(name='ljust', returns=StrType()),\n    \"lower\": FunctionType(name='lower', returns=StrType()),\n    \"lstrip\": FunctionType(name='lstrip', returns=StrType()),\n    \"replace\": FunctionType(name='replace', returns=StrType()),\n    \"rjust\": FunctionType(name='rjust', returns=StrType()),\n    \"rstrip\": FunctionType(name='rstrip', returns=StrType()),\n    \"strip\": FunctionType(name='strip', returns=StrType()),\n    \"swapcase\": FunctionType(name='swapcase', returns=StrType()),\n    \"title\": FunctionType(name='title', returns=StrType()),\n    \"translate\": FunctionType(name='translate', returns=StrType()),\n    \"upper\": FunctionType(name='upper', returns=StrType()),\n    \"zfill\": FunctionType(name='zfill', returns=StrType()),\n    # Methods that return numbers\n    \"count\": FunctionType(name='count', returns=NumType()),\n    \"find\": FunctionType(name='find', returns=NumType()),\n    \"rfind\": FunctionType(name='rfind', returns=NumType()),\n    \"index\": FunctionType(name='index', returns=NumType()),\n    \"rindex\": FunctionType(name='rindex', returns=NumType()),\n    # Methods that return booleans\n    \"startswith\": FunctionType(name='startswith', returns=BoolType()),\n    \"endswith\": FunctionType(name='endswith', returns=BoolType()),\n    \"isalnum\": FunctionType(name='isalnum', returns=BoolType()),\n    \"isalpha\": FunctionType(name='isalpha', returns=BoolType()),\n    \"isdigit\": FunctionType(name='isdigit', returns=BoolType()),\n    \"islower\": FunctionType(name='islower', returns=BoolType()),\n    \"isspace\": FunctionType(name='isspace', returns=BoolType()),\n    \"istitle\": FunctionType(name='istitle', returns=BoolType()),\n    \"isupper\": FunctionType(name='isupper', returns=BoolType()),\n    # Methods that return List of Strings\n    \"rsplit\": FunctionType(name='rsplit', returns=ListType(StrType())),\n    \"split\": FunctionType(name='split', returns=ListType(StrType())),\n    \"splitlines\": FunctionType(name='splitlines', returns=ListType(StrType()))\n})\nclass FileType(Type):\n    def index(self, i):\n        return StrType()\n    fields = _dict_extends(Type.fields, {\n        'close': FunctionType(name='close', returns='void'),\n        'read': FunctionType(name='read', returns=StrType()),\n        'readlines': FunctionType(name='readlines', returns=ListType(StrType(), False))\n    })\n    \nclass DictType(Type):\n    def __init__(self, empty=False, literals=None, keys=None, values=None):\n        self.empty = empty\n        self.literals = literals\n        self.values = values\n        self.keys = keys\n    def clone(self):\n        return DictType(self.empty, self.literals, self.keys, self.values)\n    def is_empty(self):\n        return self.empty\n    def index(self, i):\n        if self.empty:\n            return UnknownType()\n        elif self.literals is not None:\n            for literal, value in zip(self.literals, self.values):\n                if are_literals_equal(literal, i):\n                    return value.clone()\n            return UnknownType()\n        else:\n            return self.keys.clone()\n    def load_attr(self, attr, tifa, callee=None, callee_position=None):\n        if attr == 'items':\n            def _items(tifa, function_type, callee, args, position):\n                if self.literals is None:\n                    return ListType(TupleType([self.keys, self.values]))\n                else:\n                    return ListType(TupleType([self.literals[0].type(),\n                                               self.values[0]]))\n            return FunctionType(_items, 'items')\n        elif attr == 'keys':\n            def _keys(tifa, function_type, callee, args, position):\n                if self.literals is None:\n                    return ListType(self.keys)\n                else:\n                    return ListType(self.literals[0].type())\n            return FunctionType(_keys, 'keys')\n        elif attr == 'values':\n            def _items(tifa, function_type, callee, args, position):\n                if self.literals is None:\n                    return ListType(self.values)\n                else:\n                    return ListType(self.values[0])\n            return FunctionType(_values, 'values')\n        return Type.load_attr(self, attr, tifa, callee, callee_position)\n\nclass ModuleType(Type):\n    def __init__(self, name=\"*UnknownModule\", submodules=None, fields=None):\n        self.name = name\n        if submodules is None:\n            submodules = {}\n        self.submodules = submodules\n        if fields is None:\n            fields = {}\n        self.fields = fields\n\nclass SetType(ListType):\n    pass\n\nclass GeneratorType(ListType):\n    pass\n\n# Custom parking class in blockpy    \nclass TimeType(Type): pass\nclass DayType(Type): pass\n    \nMODULES = {\n    'matplotlib': ModuleType('matplotlib',\n        submodules={\n            'pyplot': ModuleType('pyplot', fields={\n                'plot': FunctionType(name='plot', returns=NoneType()),\n                'hist': FunctionType(name='hist', returns=NoneType()),\n                'scatter': FunctionType(name='scatter', returns=NoneType()),\n                'show': FunctionType(name='show', returns=NoneType()),\n                'xlabel': FunctionType(name='xlabel', returns=NoneType()),\n                'ylabel': FunctionType(name='ylabel', returns=NoneType()),\n                'title': FunctionType(name='title', returns=NoneType()),\n            })\n        }),\n    'pprint': ModuleType('pprint',\n        fields={\n            'pprint': FunctionType(name='pprint', returns=NoneType())\n        }),\n    'random': ModuleType('random',\n        fields={\n            'randint': FunctionType(name='randint', returns=NumType())\n        }),\n    'turtle': ModuleType('turtle',\n        fields={\n            'forward': FunctionType(name='forward', returns=NoneType()),\n            'backward': FunctionType(name='backward', returns=NoneType()),\n            'color': FunctionType(name='color', returns=NoneType()),\n            'right': FunctionType(name='right', returns=NoneType()),\n            'left': FunctionType(name='left', returns=NoneType()),\n        }),\n    'parking': ModuleType('parking',\n        fields={\n            'Time': FunctionType(name='Time', returns=TimeType()),\n            'now': FunctionType(name='now', returns=TimeType()),\n            'Day': FunctionType(name='Day', returns=DayType()),\n            'today': FunctionType(name='today', returns=DayType()),\n        }),\n    'math': ModuleType('math',\n        fields={\n            'ceil': FunctionType(name='ceil', returns=NumType()),\n            'copysign': FunctionType(name='copysign', returns=NumType()),\n            'fabs': FunctionType(name='fabs', returns=NumType()),\n            'factorial': FunctionType(name='factorial', returns=NumType()),\n            'floor': FunctionType(name='floor', returns=NumType()),\n            'fmod': FunctionType(name='fmod', returns=NumType()),\n            'frexp': FunctionType(name='frexp', returns=NumType()),\n            'fsum': FunctionType(name='fsum', returns=NumType()),\n            'gcd': FunctionType(name='gcd', returns=NumType()),\n            'isclose': FunctionType(name='isclose', returns=BoolType()),\n            'isfinite': FunctionType(name='isfinite', returns=BoolType()),\n            'isinf': FunctionType(name='isinf', returns=BoolType()),\n            'isnan': FunctionType(name='isnan', returns=BoolType()),\n            'ldexp': FunctionType(name='ldexp', returns=NumType()),\n            'modf': FunctionType(name='modf', returns=NumType()),\n            'trunc': FunctionType(name='trunc', returns=NumType()),\n            'log': FunctionType(name='log', returns=NumType()),\n            'log1p': FunctionType(name='log1p', returns=NumType()),\n            'log2': FunctionType(name='log2', returns=NumType()),\n            'log10': FunctionType(name='log10', returns=NumType()),\n            'pow': FunctionType(name='pow', returns=NumType()),\n            'sqrt': FunctionType(name='sqrt', returns=NumType()),\n            'acos': FunctionType(name='acos', returns=NumType()),\n            'sin': FunctionType(name='sin', returns=NumType()),\n            'cos': FunctionType(name='cos', returns=NumType()),\n            'tan': FunctionType(name='tan', returns=NumType()),\n            'asin': FunctionType(name='asin', returns=NumType()),\n            'acos': FunctionType(name='acos', returns=NumType()),\n            'atan': FunctionType(name='atan', returns=NumType()),\n            'atan2': FunctionType(name='atan2', returns=NumType()),\n            'hypot': FunctionType(name='hypot', returns=NumType()),\n            'degrees': FunctionType(name='degrees', returns=NumType()),\n            'radians': FunctionType(name='radians', returns=NumType()),\n            'sinh': FunctionType(name='sinh', returns=NumType()),\n            'cosh': FunctionType(name='cosh', returns=NumType()),\n            'tanh': FunctionType(name='tanh', returns=NumType()),\n            'asinh': FunctionType(name='asinh', returns=NumType()),\n            'acosh': FunctionType(name='acosh', returns=NumType()),\n            'atanh': FunctionType(name='atanh', returns=NumType()),\n            'erf': FunctionType(name='erf', returns=NumType()),\n            'erfc': FunctionType(name='erfc', returns=NumType()),\n            'gamma': FunctionType(name='gamma', returns=NumType()),\n            'lgamma': FunctionType(name='lgamma', returns=NumType()),\n            'pi': NumType(),\n            'e': NumType(),\n            'tau': NumType(),\n            'inf': NumType(),\n            'nan': NumType(),\n        }),\n}\n\ndef _builtin_sequence_constructor(sequence_type):\n    '''\n    Helper function for creating constructors for the Set and List types.\n    These constructors use the subtype of the arguments.\n    \n    Args:\n        sequence_type (Type): A function for creating new sequence types.\n    '''\n    def sequence_call(tifa, function_type, callee, args, position):\n        # TODO: Should inherit the emptiness too\n        return_type = sequence_type(empty=True)\n        if args:\n            return_type.subtype = args[0].index(LiteralNum(0))\n        return return_type\n    return sequence_call\n    \ndef _builtin_zip(tifa, function_type, callee, args, position):\n    '''\n    Definition of the built-in zip function, which consumes a series of\n    sequences and returns a list of tuples, with each tuple composed of the\n    elements of the sequence paired (or rather, tupled) together.\n    '''\n    if args:\n        tupled_types = TupleType(subtypes=[])\n        for arg in args:\n            tupled_types.append(arg.index(0))\n        return ListType(tupled_types)\n    return ListType(empty=True)\n\nBUILTINS = {\n    # Void Functions\n    \"print\": FunctionType(name=\"print\", returns=NoneType()),\n    # Math Functions\n    \"int\": FunctionType(name=\"int\", returns=NumType()),\n    \"abs\": FunctionType(name=\"abs\", returns=NumType()),\n    \"float\": FunctionType(name=\"float\", returns=NumType()),\n    \"len\": FunctionType(name=\"len\", returns=NumType()),\n    \"ord\": FunctionType(name=\"ord\", returns=NumType()),\n    \"pow\": FunctionType(name=\"pow\", returns=NumType()),\n    \"round\": FunctionType(name=\"round\", returns=NumType()),\n    \"sum\": FunctionType(name=\"sum\", returns=NumType()),\n    # Boolean Functions\n    \"bool\": FunctionType(name=\"bool\", returns=BoolType()),\n    \"all\": FunctionType(name=\"all\", returns=BoolType()),\n    \"any\": FunctionType(name=\"any\", returns=BoolType()),\n    \"isinstance\": FunctionType(name=\"isinstance\", returns=BoolType()),\n    # String Functions\n    \"input\": FunctionType(name=\"input\", returns=StrType()),\n    \"str\": FunctionType(name=\"str\", returns=StrType()),\n    \"chr\": FunctionType(name=\"chr\", returns=StrType()),\n    \"repr\": FunctionType(name=\"repr\", returns=StrType()),\n    # File Functions\n    \"open\": FunctionType(name=\"open\", returns=FileType()),\n    # List Functions\n    \"map\": FunctionType(name=\"map\", returns=ListType()),\n    \"list\": FunctionType(name=\"list\", \n                         definition=_builtin_sequence_constructor(ListType)),\n    # Set Functions\n    \"set\": FunctionType(name=\"set\", \n                         definition=_builtin_sequence_constructor(SetType)),\n    # Dict Functions\n    \"dict\": FunctionType(name=\"dict\", returns=DictType()),\n    # Pass through\n    \"sorted\": FunctionType(name=\"sorted\", returns='identity'),\n    \"reversed\": FunctionType(name=\"reversed\", returns='identity'),\n    \"filter\": FunctionType(name=\"filter\", returns='identity'),\n    # Special Functions\n    \"range\": FunctionType(name=\"range\", returns=ListType(NumType())),\n    \"dir\": FunctionType(name=\"dir\", returns=ListType(StrType())),\n    \"max\": FunctionType(name=\"max\", returns='element'),\n    \"min\": FunctionType(name=\"min\", returns='element'),\n    \"zip\": FunctionType(name=\"zip\", returns=_builtin_zip)\n}\n    \ndef merge_types(left, right):\n    # TODO: Check that lists/sets have the same subtypes\n    if isinstance(left, (ListType, SetType, GeneratorType)):\n        if left.empty:\n            return right.subtype\n        else:\n            return left.subtype.clone()\n    elif isinstance(left, TupleType):\n        return left.subtypes + right.subtypes\n    \nNumType_any = lambda *x: NumType()\nStrType_any = lambda *x: StrType()\nBoolType_any = lambda *x: BoolType()\nVALID_BINOP_TYPES = {\n    ast.Add: {NumType: {NumType: NumType_any}, \n              StrType :{StrType: StrType_any}, \n              ListType: {ListType: merge_types},\n              TupleType: {TupleType: merge_types}},\n    ast.Sub: {NumType: {NumType: NumType_any}, \n              SetType: {SetType: merge_types}},\n    ast.Div: {NumType: {NumType: NumType_any}},\n    ast.FloorDiv: {NumType: {NumType: NumType_any}},\n    ast.Mult: {NumType: {NumType: NumType_any, \n                     StrType: StrType_any, \n                     ListType: lambda l,r: r, \n                     TupleType: lambda l,r: r},\n             StrType: {NumType: StrType_any},\n             ListType: {NumType: lambda l,r: l},\n             TupleType: {NumType: lambda l,r: l}},\n    ast.Pow: {NumType: {NumType: NumType_any}},\n    # TODO: Should we allow old-fashioned string interpolation?\n    # Currently, I vote no because it makes the code harder and is bad form.\n    ast.Mod: {NumType: {NumType: NumType_any}},\n    ast.LShift: {NumType: {NumType: NumType_any}},\n    ast.RShift: {NumType: {NumType: NumType_any}},\n    ast.BitOr: {NumType: {NumType: NumType_any}, \n                BoolType: {NumType: NumType_any,\n                         BoolType: BoolType_any}, \n                SetType: {SetType: merge_types}},\n    ast.BitXor: {NumType: {NumType: NumType_any}, \n                BoolType: {NumType: NumType_any,\n                         BoolType: BoolType_any}, \n                SetType: {SetType: merge_types}},\n    ast.BitAnd: {NumType: {NumType: NumType_any}, \n                BoolType: {NumType: NumType_any,\n                         BoolType: BoolType_any}, \n                SetType: {SetType: merge_types}}\n}\nVALID_UNARYOP_TYPES = {\n    ast.UAdd: {NumType: NumType},\n    ast.USub: {NumType: NumType},\n    ast.Invert: {NumType: NumType}\n}\n    \ndef are_types_equal(left, right):\n    '''\n    Determine if two types are equal.\n    \n    This could be more Polymorphic - move the code for each type into\n    its respective class instead.\n    '''\n    if left is None or right is None:\n        return False\n    elif isinstance(left, UnknownType) or isinstance(right, UnknownType):\n        return False\n    elif type(left) is not type(right):\n        return False\n    elif isinstance(left, (GeneratorType, ListType)):\n        if left.empty or right.empty:\n            return True\n        else:\n            return are_types_equal(left.subtype, right.subtype)\n    elif isinstance(left, TupleType):\n        if left.empty or right.empty:\n            return True\n        elif len(left.subtypes) != len(right.subtypes):\n            return False\n        else:\n            for l, r in zip(left.subtypes, right.subtypes):\n                if not are_types_equal(l, r):\n                    return False\n            return True\n    elif isinstance(left, DictType):\n        if left.empty or right.empty:\n            return True\n        elif left.literals is not None and right.literals is not None:\n            if len(left.literals) != len(right.literals):\n                return False\n            else:\n                for l, r in zip(left.literals, right.literals):\n                    if not are_types_equal(l, r):\n                        return False\n                for l, r in zip(left.values, right.values):\n                    if not are_types_equal(l, r):\n                        return False\n                return True\n        elif left.literals is not None or right.literals is not None:\n            return False\n        else:\n            keys_equal = are_types_equal(left.keys, right.keys)\n            values_equal = are_types_equal(left.values, right.values)\n            return keys_equal and values_equal\n    else:\n        return True\n        \ndef are_literals_equal(first, second):\n    if first is None or second is None:\n        return False\n    elif type(first) != type(second):\n        return False\n    else:\n        if isinstance(first, LiteralTuple):\n            if len(first.value) != len(second.value):\n                return False\n            for l, s in zip(first.value, second.value):\n                if not are_literals_equal(l, s):\n                    return False\n            return True\n        else:\n            return first.value == second.value\n\nclass LiteralValue:\n    '''\n    A special literal representation of a value, used to represent access on\n    certain container types.\n    '''\n    def __init__(self, value):\n        self.value = value\n    \nclass LiteralNum(LiteralValue):\n    '''\n    Used to capture indexes of containers.\n    '''    \n    def type(self):\n        return NumType()\n\nclass LiteralBool(LiteralValue):\n    def type(self):\n        return BoolType()\nclass LiteralStr(LiteralValue):\n    def type(self):\n        return StrType()\nclass LiteralTuple(LiteralValue):\n    def type(self):\n        return TupleType(self.value)\n        \nclass Identifier:\n    '''\n    A representation of an Identifier, encapsulating its current level of\n    existence, scope and State.\n    \n    Attributes:\n        exists (bool): Whether or not the variable actually is defined anywhere.\n                       It is possible that a variable was retrieved that does\n                       not actually exist yet, which indicates it might need to\n                       be created.\n        in_scope (bool): Whether or not the variable exists in the current\n                         scope. Used to detect the presence of certain kinds\n                         of errors where the user is using a variable from\n                         a different scope.\n        scoped_name (str): The fully qualified name of the variable, including\n                           its scope chain.\n        state (State): The current state of the variable.\n    '''\n    def __init__(self, exists, in_scope=False, scoped_name=\"UNKNOWN\", state=\"\"):\n        self.exists = exists\n        self.in_scope = in_scope\n        self.scoped_name = scoped_name\n        self.state = state\n\n    \nclass State:\n    '''\n    A representation of a variable at a particular point in time of the program.\n    \n    Attributes:\n        name (str): The name of the variable, without its scope chain\n        trace (list of State): A recursive definition of previous States for\n                               this State.\n        type (Type): The current type of this variable.\n        method (str): One of 'store', 'read', (TODO). Indicates the change that\n                      occurred to this variable at this State.\n        position (dict): A Position dictionary indicating where this State\n                         change occurred in the source code.\n        read (str): One of 'yes', 'no', or 'maybe'. Indicates if this variable\n                    has been read since it was last changed. If merged from a\n                    diverging path, it is possible that it was \"maybe\" read.\n        set (str): One of 'yes', 'no', or 'maybe'. Indicates if this variable\n                    has been set since it was last read. If merged from a \n                    diverging path, it is possible that it was \"maybe\" changed.\n        over (str): One of 'yes', 'no', or 'maybe'. Indicates if this variable\n                    has been overwritten since it was last set. If merged from a \n                    diverging path, it is possible that it was \"maybe\" changed.\n        over_position (dict): A Position indicating where the State was\n                              previously set versus when it was overwritten.\n        \n    '''\n    def __init__(self, name, trace, type, method, position, \n                 read='maybe', set='maybe', over='maybe', over_position=None):\n        self.name = name\n        self.trace = trace\n        self.type = type\n        self.method = method\n        self.position = position\n        self.over_position = over_position\n        self.read = read\n        self.set = set\n        self.over = over\n    \n    def copy(self, method, position):\n        '''\n        Make a copy of this State, copying this state into the new State's trace\n        '''\n        return State(self.name, [self], self.type, method, position,\n                     self.read, self.set, self.over, self.over_position)\n\n    def __str__(self):\n        '''\n        Create a string representation of this State.\n        '''\n        return \"{method}(r:{read},s:{set},o:{over},{type})\".format(\n            method=self.method,\n            read=self.read[0],\n            set=self.set[0],\n            over=self.over[0],\n            type=self.type.__class__.__name__\n        )\n    def __repr__(self):\n        '''\n        Create a string representation of this State.\n        '''\n        return str(self)\n        \nORDERABLE_TYPES = (NumType, BoolType, StrType, ListType, DayType, TimeType, \n                   SetType, TupleType)\nINDEXABLE_TYPES = (StrType, ListType, SetType, TupleType, DictType)\n                     \nclass Tifa(ast.NodeVisitor):\n    '''\n    \n    Args:\n        python_3 (bool): Whether to parse the code in regular PYTHON_3 mode or\n                         the modified AST that Skulpt uses.\n    '''\n    \n    def __init__(self, python_3=True):\n        self.PYTHON_3 = python_3\n\n    @staticmethod\n    def _error_report(error):\n        '''\n        Return a new unsuccessful report with an error present.\n        '''\n        return {\"success\": False, \n                \"error\": error,\n                \"issues\": {},\n                \"variables\": {}}\n    \n    @staticmethod\n    def _initialize_report():\n        '''\n        Return a successful report with possible set of issues.\n        '''\n        return {\"success\": True,\n                \"variables\": {},\n                \"issues\": {\n                    \"Parser Failure\": [], # Complete failure to parse the code\n                    \"Unconnected blocks\": [], # Any names with ____\n                    \"Empty Body\": [], # Any use of pass on its own\n                    \"Malformed Conditional\": [], # An if/else with empty else or if\n                    \"Unnecessary Pass\": [], # Any use of pass\n                    \"Unread variables\": [], # A variable was not read after it was defined\n                    \"Undefined variables\": [], # A variable was read before it was defined\n                    \"Possibly undefined variables\": [], # A variable was read but was not defined in every branch\n                    \"Overwritten variables\": [], # A written variable was written to again before being read\n                    \"Append to non-list\": [], # Attempted to use the append method on a non-list\n                    \"Used iteration list\": [], # \n                    \"Unused iteration variable\": [], # \n                    \"Non-list iterations\": [], # \n                    \"Empty iterations\": [], # \n                    \"Type changes\": [], # \n                    \"Iteration variable is iteration list\": [], # \n                    \"Unknown functions\": [], # \n                    \"Not a function\": [], # Attempt to call non-function as function\n                    \"Recursive Call\": [],\n                    \"Incorrect Arity\": [],\n                    \"Action after return\": [],\n                    \"Incompatible types\": [], # \n                    \"Return outside function\": [], # \n                    \"Read out of scope\": [], # \n                    \"Write out of scope\": [], # Attempted to modify a variable in a higher scope\n                    \"Aliased built-in\": [], # \n                    \"Method not in Type\": [], # A method was used that didn't exist for that type\n                    \"Submodule not found\": [],\n                    \"Module not found\": [],\n                    \"Else on loop body\": [], # Used an Else on a For or While\n                }\n        }\n    \n    def report_issue(self, issue, data=None):\n        '''\n        Report the given issue with associated metadata, including the position\n        if not explicitly included.\n        '''\n        if data is None:\n            data = {}\n        if 'position' not in data:\n            data['position'] = self.locate()\n        self.report['issues'][issue].append(data)\n        \n    def locate(self, node=None):\n        '''\n        Return a dictionary representing the current location within the\n        AST.\n        \n        Returns:\n            Position dict: A dictionary with the fields 'column' and 'line',\n                           indicating the current position in the source code.\n        '''\n        if node is None:\n            if self.node_chain:\n                node = self.node_chain[-1]\n            else:\n                node = self.final_node\n        return {'column': node.col_offset, 'line': node.lineno}\n        \n                \n    def process_code(self, code, filename=\"__main__\"):\n        '''\n        Processes the AST of the given source code to generate a report.\n        \n        Args:\n            code (str): The Python source code\n            filename (str): The filename of the source code (defaults to __main__)\n        Returns: \n            Report: The successful or successful report object\n        '''\n        # Code\n        self.source = code.split(\"\\n\") if code else []\n        filename = filename\n        \n        # Attempt parsing - might fail!\n        try:\n            ast_tree = ast.parse(code, filename)\n            return self.process_ast(ast_tree)\n        except Exception as error:\n            self.report = Tifa._error_report(error)\n            raise error\n            return self.report;\n    \n    def process_ast(self, ast_tree):\n        '''\n        Given an AST, actually performs the type and flow analyses to return a \n        report.\n        \n        Args:\n            ast (Ast): The AST object\n        Returns:\n            Report: The final report object created (also available as a field).\n        '''\n        self._reset()\n        # Initialize a new, empty report\n        self.report = Tifa._initialize_report()\n        # Traverse every node\n        self.visit(ast_tree);\n        \n        # Check afterwards\n        self.report['variables'] = self.name_map\n        self._finish_scope()\n        \n        # Collect top level variables\n        self._collect_top_level_varaibles()\n        #print(self.report['variables'])\n        \n        return self.report\n    \n    def _collect_top_level_varaibles(self):\n        '''\n        Walk through the variables and add any at the top level to the\n        top_level_variables field of the report.\n        '''\n        self.report['top_level_variables'] = {}\n        main_path_vars = self.name_map[self.path_chain[0]]\n        for full_name in main_path_vars:\n            split_name = full_name.split(\"/\")\n            if len(split_name) == 2 and split_name[0] == str(self.scope_chain[0]):\n                name = split_name[1]\n                self.report['top_level_variables'][name] = main_path_vars[full_name]\n    \n    def _reset(self):\n        '''\n        Reinitialize fields for maintaining the system\n        '''\n        # Unique Global IDs\n        self.path_id = 0;\n        self.scope_id = 0;\n        self.ast_id = 0;\n        \n        # Human readable names\n        self.path_names = ['*Module'];\n        self.scope_names = ['*Module'];\n        self.node_chain = [];\n        \n        # Complete record of all Names\n        self.scope_chain = [self.scope_id]\n        self.path_chain = [self.path_id]\n        self.name_map = {}\n        self.name_map[self.path_id] = {}\n        self.definition_chain = []\n        self.path_parents = {}\n        self.final_node = None\n        \n    def find_variable_scope(self, name):\n        '''\n        Walk through this scope and all enclosing scopes, finding the relevant\n        identifier given by `name`.\n        \n        Args:\n            name (str): The name of the variable\n        Returns:\n            Identifier: An Identifier for the variable, which could potentially\n                        not exist.\n        '''\n        for scope_level, scope in enumerate(self.scope_chain):\n            for path_id in self.path_chain:\n                path = self.name_map[path_id]\n                full_name = \"/\".join(map(str, self.scope_chain[scope_level:]))+\"/\"+name\n                if full_name in path:\n                    is_root_scope = (scope_level==0)\n                    return Identifier(True, is_root_scope, \n                                      full_name, path[full_name])\n                        \n        return Identifier(False)\n    \n    def find_variable_out_of_scope(self, name):\n        '''\n        Walk through every scope and determine if this variable can be found\n        elsewhere (which would be an issue).\n        \n        Args:\n            name (str): The name of the variable\n        Returns:\n            Identifier: An Identifier for the variable, which could potentially\n                        not exist.\n        '''\n        for path in self.name_map.values():\n            for full_name in path:\n                unscoped_name = full_name.split(\"/\")[-1]\n                if name == unscoped_name:\n                    return Identifier(True, False, unscoped_name, path[full_name])\n        return Identifier(False)\n    \n    def find_path_parent(self, path_id, name):\n        if name in self.name_map[path_id]:\n            return Identifier(True, state=self.name_map[path_id][name])\n        else:\n            path_parent = self.path_parents.get(path_id)\n            if path_parent is None:\n                return Identifier(False)\n            else:\n                return self.find_path_parent(path_parent, name)\n        \n    def _finish_scope(self):\n        '''\n        Walk through all the variables present in this scope and ensure that\n        they have been read and not overwritten.\n        '''\n        path_id = self.path_chain[0]\n        for name in self.name_map[path_id]:\n            if Tifa.in_scope(name, self.scope_chain):\n                state = self.name_map[path_id][name]\n                if state.over == 'yes':\n                    position = state.over_position\n                    self.report_issue('Overwritten variables', \n                                     {'name': state.name, 'position': position})\n                if state.read == 'no':\n                    self.report_issue('Unread variables', \n                                     {'name': state.name, 'type': state.type})\n        \n    def visit(self, node):\n        '''\n        Process this node by calling its appropriate visit_*\n        \n        Args:\n            node (AST): The node to visit\n        Returns:\n            Type: The type calculated during the visit.\n        '''\n        # Start processing the node\n        self.node_chain.append(node)\n        self.ast_id += 1\n        \n        # Actions after return?\n        if len(self.scope_chain) > 1:\n            return_state = self.find_variable_scope(\"*return\")\n            if return_state.exists and return_state.in_scope:\n                if return_state.state.set == \"yes\":\n                    self.report_issue(\"Action after return\")\n        \n        # No? All good, let's enter the node\n        self.final_node = node\n        result = ast.NodeVisitor.visit(self, node)\n        \n        # Pop the node out of the chain\n        self.ast_id -= 1\n        self.node_chain.pop()\n        \n        # If a node failed to return something, return the UNKNOWN TYPE\n        if result == None:\n            return UnknownType()\n        else:\n            return result\n            \n    def _visit_nodes(self, nodes):\n        '''\n        Visit all the nodes in the given list.\n        \n        Args:\n            nodes (list): A list of values, of which any AST nodes will be\n                          visited.\n        '''\n        for node in nodes:\n            if isinstance(node, ast.AST):\n                self.visit(node)\n                \n    def walk_targets(self, targets, type, walker):\n        '''\n        Iterate through the targets and call the given function on each one.\n        \n        Args:\n            targets (list of Ast nodes): A list of potential targets to be\n                                         traversed.\n            type (Type): The given type to be unraveled and applied to the\n                         targets.\n            walker (Ast Node, Type -> None): A function that will process\n                                             each target and unravel the type.\n        '''\n        for target in targets:\n            walker(target, type)\n    \n    def _walk_target(self, target, type):\n        '''\n        Recursively apply the type to the target\n        \n        Args:\n            target (Ast): The current AST node to process\n            type (Type): The type to apply to this node\n        '''\n        if isinstance(target, ast.Name):\n            self.store_iter_variable(target.id, type, self.locate(target))\n            return target.id\n        elif isinstance(target, (ast.Tuple, ast.List)):\n            result = None\n            for i, elt in enumerate(target.elts):\n                elt_type = type.index(LiteralNum(i))\n                potential_name = self._walk_target(elt, elt_type)\n                if potential_name is not None and result is None:\n                    result = potential_name\n            return result\n            \n    def visit_Assign(self, node):\n        '''\n        Simple assignment statement:\n        __targets__ = __value__\n        \n        Args:\n            node (AST): An Assign node\n        Returns:\n            None\n        '''\n        # Handle value\n        value_type = self.visit(node.value);\n        # Handle targets\n        self._visit_nodes(node.targets);\n        \n        # TODO: Properly handle assignments with subscripts\n        def action(target, type):\n            if isinstance(target, ast.Name):\n                self.store_variable(target.id, type)\n            elif isinstance(target, (ast.Tuple, ast.List)):\n                for i, elt in enumerate(target.elts):\n                    eltType = type.index(LiteralNum(i))\n                    action(elt, eltType)\n            elif isinstance(target, ast.Subscript):\n                pass\n                # TODO: Handle minor type changes (e.g., appending to an inner list)\n        self.walk_targets(node.targets, value_type, action)\n        \n    def visit_AugAssign(self, node):\n        # Handle value\n        right = self.visit(node.value)\n        # Handle target\n        left = self.visit(node.target)\n        # Target is always a Name, Subscript, or Attribute\n        name = self.identify_caller(node.target)\n        \n        # Handle operation\n        self.load_variable(name)\n        if isinstance(left, UnknownType) or isinstance(right, UnknownType):\n            return UnknownType()\n        elif isinstance(left, RecursedType) or isinstance(right, RecursedType):\n            return RecursedType()\n        elif type(node.op) in VALID_BINOP_TYPES:\n            op_lookup = VALID_BINOP_TYPES[type(node.op)]\n            if type(left) in op_lookup:\n                op_lookup = op_lookup[type(left)]\n                if type(right) in op_lookup:\n                    op_lookup = op_lookup[type(right)]\n                    result_type = op_lookup(left, right)\n                    self.store_variable(name, result_type)\n                    return result_type\n        \n        self.report_issue(\"Incompatible types\", \n                         {\"left\": left, \"right\": right, \n                          \"operation\": node.op})\n                          \n    def visit_Attribute(self, node):\n        # Handle value\n        value_type = self.visit(node.value)\n        # Handle ctx\n        # TODO: Handling contexts\n        # Handle attr\n        return value_type.load_attr(node.attr, self, node.value, self.locate())\n    \n    def visit_BinOp(self, node):\n        # Handle left and right\n        left = self.visit(node.left)\n        right = self.visit(node.right)\n        \n        # Handle operation\n        if isinstance(left, UnknownType) or isinstance(right, UnknownType):\n            return UnknownType()\n        elif isinstance(left, RecursedType) or isinstance(right, RecursedType):\n            return RecursedType()\n        elif type(node.op) in VALID_BINOP_TYPES:\n            op_lookup = VALID_BINOP_TYPES[type(node.op)]\n            if type(left) in op_lookup:\n                op_lookup = op_lookup[type(left)]\n                if type(right) in op_lookup:\n                    op_lookup = op_lookup[type(right)]\n                    return op_lookup(left, right)\n                    \n        self.report_issue(\"Incompatible types\", \n                         {\"left\": left, \"right\": right, \n                          \"operation\": node.op});\n        return UnknownType()\n        \n    def visit_Bool(self, node):\n        return BoolType()\n    \n    \n    def visit_BoolOp(self, node):\n        # Handle left and right\n        values = []\n        for value in node.values:\n            values.append(self.visit(value))   \n        \n        # TODO: Truthiness is not supported! Probably need a Union type\n        # TODO: Literals used as truthy value\n        \n        # Handle operation\n        return BoolType()\n    \n    def visit_Call(self, node):\n        # Handle func part (Name or Attribute)\n        function_type = self.visit(node.func)\n        callee = self.identify_caller(node)\n        \n        # Handle args\n        arguments = [self.visit(arg) for arg in node.args]\n        \n        # TODO: Handle keywords\n        # TODO: Handle starargs\n        # TODO: Handle kwargs\n        if isinstance(function_type, FunctionType):\n            # Test if we have called this definition before\n            if function_type.definition not in self.definition_chain:\n                self.definition_chain.append(function_type.definition)\n                # Function invocation\n                result = function_type.definition(self, function_type, callee, \n                                                  arguments, self.locate())\n                self.definition_chain.pop()\n                return result\n            else:\n                self.report_issue(\"Recursive Call\", {\"name\": callee})\n        else:\n            self.report_issue(\"Not a function\", {\"name\": callee})\n        return UnknownType()\n        \n    def visit_ClassDef(self, node):\n        class_name = node.name\n        self.store_variable(class_name, ClassType)\n        # TODO: Define a new scope definition that executes the body\n        # TODO: find __init__, execute that\n        self.generic_visit(node)\n    \n    def visit_Compare(self, node):\n        # Handle left and right\n        left = self.visit(node.left)\n        comparators = [self.visit(compare) for compare in node.comparators]\n        \n        # Handle ops\n        if isinstance(left, RecursedType):\n            return BoolType()\n        for op, right in zip(node.ops, comparators):\n            if isinstance(right, RecursedType):\n                continue\n            if isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\n                continue\n            elif isinstance(op, (ast.Lt, ast.LtE, ast.GtE, ast.Gt)):\n                if are_types_equal(left, right):\n                    if isinstance(left, ORDERABLE_TYPES):\n                        continue\n            elif isinstance(op, (ast.In, ast.NotIn)):\n                if isinstance(right, INDEXABLE_TYPES):\n                    continue\n            self.report_issue(\"Incompatible types\",\n                              {\"left\": left, \"right\": right,\n                               \"operation\": op})\n        return BoolType()\n      \n    def _visit_collection_loop(self, node):\n        # Handle the iteration list\n        iter = node.iter\n        iter_list_name = None\n        if isinstance(iter, ast.Name):\n            iter_list_name = iter.id\n            if iter_list_name == \"___\":\n                self.report_issue(\"Unconnected blocks\", \n                                  {\"position\": self.locate(iter)})\n            state = self.iterate_variable(iter_list_name)\n            iter_type = state.type\n        else:\n            iter_type = self.visit(iter)\n        \n        if iter_type.is_empty():\n            self.report_issue(\"Empty iterations\", \n                              {\"name\": iter_list_name, \n                               \"position\": self.locate(iter)})\n            \n        if not isinstance(iter_type, INDEXABLE_TYPES):\n            self.report_issue(\"Non-list iterations\", \n                              {\"name\": iter_list_name, \n                               \"position\": self.locate(iter)})\n            \n        iter_subtype = iter_type.index(LiteralNum(0))\n        \n        # Handle the iteration variable\n        iter_variable_name = self._walk_target(node.target, iter_subtype)\n        \n        if iter_variable_name and iter_list_name:\n            if iter_variable_name == iter_list_name:\n                self.report_issue(\"Iteration variable is iteration list\", \n                                  {\"name\": iter_variable_name,\n                                   \"position\": self.locate(node.target)})\n\n    def visit_comprehension(self, node):\n        self._visit_collection_loop(node)\n        # Handle the bodies\n        self.visit_statements(node.ifs)\n    \n    def visit_Dict(self, node):\n        '''\n        Three types of dictionaries\n        - empty\n        - uniform type\n        - record\n        '''\n        type = DictType()\n        if not node.keys:\n            type.empty = True\n        else:\n            type.empty = True\n            all_literals = True\n            keys, values, literals = [], [], []\n            for key, value in zip(node.keys, node.values):\n                key, value = self.visit(key), self.visit(value)\n                literal = Tifa.get_literal(key)\n                if literal is not None:\n                    literals.append(literal)\n                    values.append(value)\n                else:\n                    all_literals = False;\n            if all_literals:\n                type.literals = literals\n                type.values = values\n            else:\n                type.keys = key;\n                type.values = value;\n        return type\n    \n    def visit_DictComp(self, node):\n        # TODO: Handle comprehension scope\n        for generator in node.generators:\n            self.visit(generator)\n        keys = self.visit(node.key)\n        values = self.visit(node.value)\n        return DictType(keys=keys, values=values)\n    \n    def visit_For(self, node):\n        self._visit_collection_loop(node)\n        # Handle the bodies\n        self.visit_statements(node.body)\n        self.visit_statements(node.orelse)\n        \n    def visit_FunctionDef(self, node):\n        # Name\n        function_name = node.name\n        position = self.locate()\n        definitions_scope = self.scope_chain[:]\n        def definition(tifa, call_type, call_name, parameters, call_position):\n            function_scope = Tifa.NewScope(self, definitions_scope)\n            with function_scope:\n                # Process arguments\n                args = node.args.args\n                if len(args) != len(parameters):\n                    self.report_issue('Incorrect Arity', {\"position\": position})\n                # TODO: Handle special types of parameters\n                for arg, parameter in zip(args, parameters):\n                    name = arg.arg if self.PYTHON_3 else arg.id\n                    if parameter is not None:\n                        parameter = parameter.clone_mutably()\n                        self.store_variable(name, parameter, position)\n                if len(args) < len(parameters):\n                    for undefined_parameter in parameters[len(args):]:\n                        self.store_variable(name, UnknownType(), position)\n                self.visit_statements(node.body)\n                return_state = self.find_variable_scope(\"*return\")\n                return_value = NoneType()\n                # If the pseudo variable exists, we load it and get its type\n                if return_state.exists and return_state.in_scope:\n                    return_state = self.load_variable(\"*return\", call_position)\n                    return_value = return_state.type\n            return return_value\n        function = FunctionType(definition=definition, name=function_name)\n        self.store_variable(function_name, function)\n        return function\n    \n    def visit_GeneratorExp(self, node):\n        # TODO: Handle comprehension scope\n        for generator in node.generators:\n            self.visit(generator)\n        return GeneratorType(self.visit(node.elt))\n        \n    def visit_If(self, node):\n        # Visit the conditional\n        self.visit(node.test);\n        \n        if len(node.orelse) == 1 and isinstance(node.orelse[0], ast.Pass):\n            self.report_issue(\"Malformed Conditional\")\n        elif len(node.body) == 1 and isinstance(node.body[0], ast.Pass):\n            if node.orelse:\n                self.report_issue(\"Malformed Conditional\")\n        \n        # Visit the bodies\n        this_path_id = self.path_id\n        if_path = Tifa.NewPath(self, this_path_id, \"i\")\n        with if_path:\n            for statement in node.body:\n                self.visit(statement)\n        else_path = Tifa.NewPath(self, this_path_id, \"e\")\n        with else_path:\n            for statement in node.orelse:\n                self.visit(statement)\n        \n        # Combine two paths into one\n        # Check for any names that are on the IF path\n        self.merge_paths(this_path_id, if_path.id, else_path.id)\n        \n    def visit_IfExp(self, node):\n        # Visit the conditional\n        self.visit(node.test)\n        \n        # Visit the body\n        body = self.visit(node.body)\n        \n        # Visit the orelse\n        orelse = self.visit(node.orelse)\n\n        if are_types_equal(body, orelse):\n            return body\n            \n        # TODO: Union type?\n        return UnknownType()\n    \n    def visit_Import(self, node):\n        # Handle names\n        for alias in node.names:\n            asname = alias.asname or alias.name\n            module_type = self.load_module(alias.name)\n            self.store_variable(asname, module_type)\n            \n    def visit_ImportFrom(self, node):\n        # Handle names\n        for alias in node.names:\n            if node.module is None:\n                asname = alias.asname or alias.name\n                module_type = self.load_module(alias.name)\n            else:\n                module_name = node.module;\n                asname = alias.asname or alias.name\n                module_type = self.load_module(module_name)\n            name_type = module_type.load_attr(alias.name, self, \n                                              callee_position=self.locate())\n            self.store_variable(asname, name_type)\n    \n    def visit_Lambda(self, node):\n        # Name\n        position = self.locate()\n        definitions_scope = self.scope_chain[:]\n        \n        def definition(tifa, call_type, call_name, parameters, call_position):\n            function_scope = Tifa.NewScope(self, definitions_scope)\n            with function_scope:\n                # Process arguments\n                args = node.args.args\n                if len(args) != len(parameters):\n                    self.report_issue('Incorrect Arity', {\"position\": position})\n                # TODO: Handle special types of parameters\n                for arg, parameter in zip(args, parameters):\n                    name = arg.arg if self.PYTHON_3 else arg.id\n                    if parameter is not None:\n                        parameter = parameter.clone_mutably()\n                        self.store_variable(name, parameter, position)\n                if len(args) < len(parameters):\n                    for undefined_parameter in parameters[len(args):]:\n                        self.store_variable(name, UnknownType(), position)\n                return_value = self.visit(node.body)\n            return return_value\n        return FunctionType(definition=definition)\n    \n    def visit_List(self, node):\n        type = ListType()\n        if node.elts:\n            type.empty = False\n            # TODO: confirm homogenous subtype\n            for elt in node.elts:\n                type.subtype = self.visit(elt)\n        else:\n            type.empty = True\n        return type\n            \n    def visit_ListComp(self, node):\n        # TODO: Handle comprehension scope\n        for generator in node.generators:\n            self.visit(generator)\n        return ListType(self.visit(node.elt))\n            \n    def visit_Name(self, node):\n        name = node.id\n        if name == \"___\":\n            self.report_issue(\"Unconnected blocks\")\n        if isinstance(node.ctx, ast.Load):\n            if name == \"True\" or name == \"False\":\n                return BoolType()\n            elif name == \"None\":\n                return NoneType()\n            else:\n                variable = self.find_variable_scope(name)\n                builtin = BUILTINS.get(name)\n                if not variable.exists and builtin:\n                    return builtin\n                else:\n                    state = self.load_variable(name)\n                    return state.type\n        else:\n            variable = self.find_variable_scope(name)\n            if variable.exists:\n                return variable.state.type\n            else:\n                return UnknownType()\n    \n    def visit_Num(self, node):\n        return NumType()\n        \n    def visit_Return(self, node):\n        if len(self.scope_chain) == 1:\n            self.report_issue(\"Return outside function\")\n        if node.value is not None:\n            self.return_variable(self.visit(node.value))\n        else:\n            self.return_variable(NoneType())\n        \n    def visit_SetComp(self, node):\n        # TODO: Handle comprehension scope\n        for generator in node.generators:\n            self.visit(generator)\n        return SetType(self.visit(node.elt))\n    \n    def visit_statements(self, nodes):\n        # TODO: Check for pass in the middle of a series of statement\n        if any(isinstance(node, ast.Pass) for node in nodes):\n            pass\n        return [self.visit(statement) for statement in nodes]\n                \n    def visit_Str(self, node):\n        return StrType()\n        \n    def visit_Subscript(self, node):\n        # Handle value\n        value_type = self.visit(node.value)\n        # Handle slice\n        if isinstance(node.slice, ast.Index):\n            return value_type.index(Tifa.get_literal(node.slice.value))\n        elif isinstance(node.slice, ast.Slice):\n            return value_type\n    \n    def visit_Tuple(self, node):\n        type = TupleType()\n        if not node.elts:\n            type.empty = True\n            type.subtypes = []\n        else:\n            type.empty = False\n            # TODO: confirm homogenous subtype\n            type.subtypes = [self.visit(elt) for elt in node.elts]\n        return type\n    \n    def visit_UnaryOp(self, node):\n        # Handle operand\n        operand = self.visit(node.operand)\n        \n        if isinstance(node.op, ast.Not):\n            return BoolType()\n        elif isinstance(operand, UnknownType):\n            return UnknownType()\n        elif type(node.op) in VALID_UNARYOP_TYPES:\n            op_lookup = VALID_UNARYOP_TYPES[type(node.op)]\n            if type(node.op) in op_lookup:\n                op_lookup = op_lookup[type(node.op)]\n                if type(operand) in op_lookup:\n                    op_lookup = op_lookup[type(operand)]\n                    return op_lookup(operand)\n        return UnknownType()\n        \n    def visit_While(self, node):\n        # Visit conditional\n        self.visit(node.test)\n        \n        # Visit the bodies\n        this_path_id = self.path_id\n        # One path is that we never enter the body\n        empty_path = Tifa.NewPath(self, this_path_id, \"e\")\n        with empty_path:\n            pass\n        # Another path is that we loop through the body and check the test again\n        body_path = Tifa.NewPath(self, this_path_id, \"w\")\n        with body_path:\n            for statement in node.body:\n                self.visit(statement)\n            # Revisit conditional\n            self.visit(node.test);\n        # If there's else bodies (WEIRD) then we should check them afterwards\n        if node.orelse:\n            self.report_issue(\"Else on loop body\")\n            for statement in node.orelse:\n                self.visit(statement)\n        \n        # Combine two paths into one\n        # Check for any names that are on the IF path\n        self.merge_paths(this_path_id, body_path.id, empty_path.id)\n        \n    def visit_With(self, node):\n        if self.PYTHON_3:\n            for item in node.items:\n                type_value = self.visit(item.context_expr)\n                self.visit(item.optional_vars)\n                self._walk_target(item.optional_vars, type_value)\n        else:\n            type_value = self.visit(node.context_expr)\n            #self.visit(node.optional_vars)\n            self._walk_target(node.optional_vars, type_value)\n        # Handle the bodies\n        self.visit_statements(node.body)\n        \n    def _scope_chain_str(self, name=None):\n        '''\n        Convert the current scope chain to a string representation (divided \n        by \"/\").\n        \n        Returns:\n            str: String representation of the scope chain.\n        '''\n        if name:\n            return \"/\".join(map(str, self.scope_chain)) + \"/\" + name\n        else:\n            return \"/\".join(map(str, self.scope_chain))\n        \n    def identify_caller(self, node):\n        '''\n        Figures out the variable that was used to kick off this call,\n        which is almost always the relevant Name to track as being updated.\n        If the origin wasn't a Name, nothing will need to be updated so None\n        is returned instead.\n        \n        TODO: Is this sufficient?\n        \n        Args:\n            node (AST): An AST node\n        Returns:\n            str or None: The name of the variable or None if no origin could\n                         be found.\n        '''\n        if isinstance(node, ast.Name):\n            return node.id\n        elif isinstance(node, ast.Call):\n            return self.identify_caller(node.func)\n        elif isinstance(node, (ast.Attribute, ast.Subscript)):\n            return self.identify_caller(node.value)\n        return None\n        \n    def iterate_variable(self, name):\n        '''\n        Update the variable by iterating through it - this doesn't do anything\n        fancy yet.\n        '''\n        return self.load_variable(name)\n    \n    def store_iter_variable(self, name, type, position=None):\n        state = self.store_variable(name, type, position)\n        state.read = 'yes'\n        return state\n    \n    def return_variable(self, type):\n        return self.store_variable(\"*return\", type)\n        \n    def append_variable(self, name, type, position=None):\n        return self.store_variable(name, type, position)\n        \n    def store_variable(self, name, type, position=None):\n        '''\n        Update the variable with the given name to now have the new type.\n        \n        Args:\n            name (str): The unqualified name of the variable. The variable will\n                        be assumed to be in the current scope.\n            type (Type): The new type of this variable.\n        Returns:\n            State: The new state of the variable.\n        '''\n        if position is None:\n            position = self.locate()\n        full_name = self._scope_chain_str(name)\n        current_path = self.path_chain[0]\n        variable = self.find_variable_scope(name)\n        if not variable.exists:\n            # Create a new instance of the variable on the current path\n            new_state = State(name, [], type, 'store', position, \n                              read='no', set='yes', over='no')\n            self.name_map[current_path][full_name] = new_state\n        else:\n            new_state = self.trace_state(variable.state, \"store\")\n            if not variable.in_scope:\n                self.report_issue(\"Write out of scope\", {'name': name})\n            # Type change?\n            if not are_types_equal(type, variable.state.type):\n                self.report_issue(\"Type changes\", \n                                 {'name': name, 'old': variable.state.type, \n                                  'new': type})\n            new_state.type = type\n            # Overwritten?\n            if variable.state.set == 'yes' and variable.state.read == 'no':\n                new_state.over_position = position\n                new_state.over = 'yes'\n            else:\n                new_state.set = 'yes'\n                new_state.read = 'no'\n            self.name_map[current_path][full_name] = new_state\n        return new_state\n    \n    def load_variable(self, name, position=None):\n        '''\n        Retrieve the variable with the given name.\n        \n        Args:\n            name (str): The unqualified name of the variable. If the variable is\n                        not found in the current scope or an enclosing sope, all\n                        other scopes will be searched to see if it was read out\n                        of scope.\n        Returns:\n            State: The current state of the variable.\n        '''\n        full_name = self._scope_chain_str(name)\n        current_path = self.path_chain[0]\n        variable = self.find_variable_scope(name)\n        if position is None:\n            position = self.locate()\n        if not variable.exists:\n            out_of_scope_var = self.find_variable_out_of_scope(name)\n            # Create a new instance of the variable on the current path\n            if out_of_scope_var.exists:\n                self.report_issue(\"Read out of scope\", {'name': name})\n            else:\n                self.report_issue(\"Undefined variables\", {'name': name})\n            new_state = State(name, [], UnknownType(), 'load', position,\n                              read='yes', set='no', over='no')\n            self.name_map[current_path][full_name] = new_state\n        else:\n            new_state = self.trace_state(variable.state, \"load\")\n            if variable.state.set == 'no':\n                self.report_issue(\"Undefined variables\", {'name': name})\n            if variable.state.set == 'maybe':\n                self.report_issue(\"Possibly undefined variables\", {'name': name})\n            new_state.read = 'yes';\n            if not variable.in_scope:\n                self.name_map[current_path][variable.scoped_name] = new_state\n            else:\n                self.name_map[current_path][full_name] = new_state\n        return new_state\n        \n    def load_module(self, chain):\n        '''\n        Finds the module in the set of available modules.\n        \n        Args:\n            chain (str): A chain of module imports (e.g., \"matplotlib.pyplot\")\n        Returns:\n            ModuleType: The specific module with its members, or an empty\n                        module type.\n        '''\n        module_names = chain.split('.')\n        if module_names[0] in MODULES:\n            base_module = MODULES[module_names[0]]\n            for module in module_names:\n                if (isinstance(base_module, ModuleType) and \n                    module in base_module.submodules):\n                    base_module = base_module.submodules[module]\n                else:\n                    self.report_issue(\"Submodule not found\", {\"name\": chain})\n            return base_module\n        else:\n            self.report_issue(\"Module not found\", {\"name\": chain})\n            return ModuleType()\n            \n    def combine_states(self, left, right):\n        state = State(left.name, [left], left.type, 'branch', self.locate(),\n                      read=left.read, set=left.set, over=left.over,\n                      over_position=left.over_position)\n        if right is None:\n            state.read = 'no' if left.read == 'no' else 'maybe'\n            state.set = 'no' if left.set == 'no' else 'maybe'\n            state.over = 'no' if left.over == 'no' else 'maybe'\n        else:\n            if not are_types_equal(left.type, right.type):\n                self.report_issue(\"Type changes\", {'name': left.name, \n                                                   'old': left.type, \n                                                   'new': right.type})\n            state.read = Tifa.match_rso(left.read, right.read)\n            state.set = Tifa.match_rso(left.set, right.set)\n            state.over = Tifa.match_rso(left.over, right.over)\n            if left.over == 'no':\n                state.over_position = right.over_position\n            state.trace.append(right)\n        return state\n    \n    def merge_paths(self, parent_path_id, left_path_id, right_path_id):\n        '''\n        Combines any variables on the left and right path into the parent\n        name space.\n        \n        Args:\n            parent_path_id (int): The parent path of the left and right branches\n            left_path_id (int): One of the two paths\n            right_path_id (int): The other of the two paths.\n        '''\n        # Combine two paths into one\n        # Check for any names that are on the IF path\n        for left_name in self.name_map[left_path_id]:\n            left_state = self.name_map[left_path_id][left_name]\n            right_identifier = self.find_path_parent(right_path_id, left_name)\n            if right_identifier.exists:\n                # Was on both IF and ELSE path\n                right_state = right_identifier.state\n            else:\n                # Was only on IF path, potentially on the parent path\n                right_state = self.name_map[parent_path_id].get(left_name)\n            combined = self.combine_states(left_state, right_state)\n            self.name_map[parent_path_id][left_name] = combined\n        # Check for names that are on the ELSE path but not the IF path\n        for right_name in self.name_map[right_path_id]:\n            if right_name not in self.name_map[left_path_id]:\n                right_state = self.name_map[right_path_id][right_name]\n                # Potentially on the parent path\n                parent_state = self.name_map[parent_path_id].get(right_name)\n                combined = self.combine_states(right_state, parent_state)\n                self.name_map[parent_path_id][right_name] = combined\n    \n    def trace_state(self, state, method):\n        '''\n        Makes a copy of the given state with the given method type.\n        \n        Args:\n            state (State): The state to copy (as in, we trace a copy of it!)\n            method (str): The operation being applied to the state.\n        Returns:\n            State: The new State\n        '''\n        return state.copy(method, self.locate())\n    \n    @staticmethod\n    def in_scope(full_name, scope_chain):\n        '''\n        Determine if the fully qualified variable name is in the given scope\n        chain.\n        \n        Args:\n            full_name (str): A fully qualified variable name\n            scope_chain (list): A representation of a scope chain.\n        Returns:\n            bool: Whether the variable lives in this scope\n        '''\n        # Get this entity's full scope chain\n        name_scopes = full_name.split(\"/\")[:-1]\n        # against the reverse scope chain\n        checking_scopes = [str(s) for s in scope_chain[::-1]]\n        return name_scopes == checking_scopes\n    \n    @staticmethod\n    def match_rso(left, right):\n        if left == right:\n            return left\n        else:\n            return \"maybe\"\n    \n    @staticmethod\n    def get_literal(node):\n        if isinstance(node, ast.Num):\n            return LiteralNum(node.n)\n        elif isinstance(node, ast.Str):\n            return LiteralStr(node.s)\n        elif isinstance(node, ast.Tuple):\n            values = []\n            for elt in node.elts:\n                subvalue = Tifa.get_literal(elt)\n                if subvalue is not None:\n                    values.append(subvalue)\n                else:\n                    return None\n            return LiteralTuple(values)\n        elif isinstance(node, ast.Name):\n            if node.id == \"None\":\n                return LiteralNone()\n            elif node.id == \"False\":\n                return LiteralBool(False)\n            elif node.id == \"True\":\n                return LiteralBool(True)\n        return None\n\n    \n    class NewPath:\n        '''\n        Context manager for entering and leaving execution paths (e.g., if\n        statements).)\n        \n        Args:\n            tifa (Tifa): The tifa instance, so we can modify some of its\n                         properties that track variables and paths.\n            origin_path (int): The path ID parent to this one.\n            name (str): The symbolic name of this path, typically 'i' for an IF\n                        body and 'e' for ELSE body.\n        \n        Fields:\n            id (int): The path ID of this path\n        '''\n        def __init__(self, tifa, origin_path, name):\n            self.tifa = tifa\n            self.name = name\n            self.origin_path = origin_path\n            self.id = None\n        def __enter__(self):\n            self.tifa.path_id += 1\n            self.id = self.tifa.path_id\n            self.tifa.path_names.append(str(self.id)+self.name)\n            self.tifa.path_chain.insert(0, self.id)\n            self.tifa.name_map[self.id] = {}\n            self.tifa.path_parents[self.id] = self.origin_path\n        def __exit__(self, type, value, traceback):\n            self.tifa.path_names.pop()\n            self.tifa.path_chain.pop(0)\n        \n    class NewScope:\n        '''\n        Context manager for entering and leaving scopes (e.g., inside of\n        function calls).\n        \n        Args:\n            tifa (Tifa): The tifa instance, so we can modify some of its\n                         properties that track variables and paths.\n            definitions_scope_chain (list of int): The scope chain of the \n                                                   definition\n        '''\n        def __init__(self, tifa, definitions_scope_chain):\n            self.tifa = tifa\n            self.definitions_scope_chain = definitions_scope_chain\n        def __enter__(self):\n            # Manage scope\n            self.old_scope = self.tifa.scope_chain[:]\n            # Move to the definition's scope chain\n            self.tifa.scope_chain = self.definitions_scope_chain[:]\n            # And then enter its body's new scope\n            self.tifa.scope_id += 1\n            self.tifa.scope_chain.insert(0, self.tifa.scope_id)\n        def __exit__(self, type, value, traceback):\n            # Finish up the scope\n            self.tifa._finish_scope()\n            # Leave the body\n            self.tifa.scope_chain.pop(0)\n            # Restore the scope\n            self.tifa.scope_chain = self.old_scope\n        ", "src/lib/sunau.py": "raise NotImplementedError(\"sunau is not yet implemented in Skulpt\")\n", "src/lib/__future__.py": "raise NotImplementedError(\"__future__ is not yet implemented in Skulpt\")\n", "src/lib/shelve.py": "raise NotImplementedError(\"shelve is not yet implemented in Skulpt\")\n", "src/lib/collections.js": "var $builtinmodule = function (name) {\n\n    var mod = {};\n\n    // defaultdict object\n\n    mod.defaultdict = function defaultdict(default_, args) {\n        if (!(this instanceof mod.defaultdict)) {\n            return new mod.defaultdict(default_, args);\n        }\n\n        Sk.abstr.superConstructor(mod.defaultdict, this, args);\n\n        if (default_ === undefined) {\n            this.default_factory = Sk.builtin.none.none$;\n        }\n        else {\n            if (!Sk.builtin.checkCallable(default_) && !(default_ instanceof Sk.builtin.none)) {\n                throw new Sk.builtin.TypeError(\"first argument must be callable\");\n            }\n            this.default_factory = default_;\n        }\n\n        if (this['$d']) {\n            this['$d']['default_factory'] = this.default_factory;\n        }\n        else {\n            this['$d'] = {'default_factory': this.default_factory};\n        }\n\n        return this;\n    };\n\n    Sk.abstr.setUpInheritance(\"defaultdict\", mod.defaultdict, Sk.builtin.dict);\n\n    mod.defaultdict.prototype['$r'] = function () {\n        var def_str = Sk.misceval.objectRepr(this.default_factory).v;\n        var dict_str = Sk.builtin.dict.prototype['$r'].call(this).v;\n        return new Sk.builtin.str(\"defaultdict(\" + def_str + \", \" + dict_str + \")\");\n    };\n\n    mod.defaultdict.prototype['__missing__'] = function (key) {\n        Sk.builtin.pyCheckArgs('__missing__', arguments, 0, 1);\n        if (key) {\n            throw new Sk.builtin.KeyError(Sk.misceval.objectRepr(key));\n        }\n        else {\n            return Sk.misceval.callsim(this.default_factory);\n        }\n    };\n\n    mod.defaultdict.prototype.mp$subscript = function (key) {\n        try {\n            return Sk.builtin.dict.prototype.mp$subscript.call(this, key);\n        }\n        catch (e) {\n            if (this.default_factory instanceof Sk.builtin.none) {\n                return this.__missing__(key);\n            }\n            else {\n                ret = this.__missing__();\n                this.mp$ass_subscript(key, ret);\n                return ret;\n            }\n        }\n    };\n\n    // Counter object\n\n    mod.Counter = function Counter(iter_or_map) {\n        if (!(this instanceof mod.Counter)) {\n            return new mod.Counter(iter_or_map);\n        }\n\n\n        if (iter_or_map instanceof Sk.builtin.dict || iter_or_map === undefined) {\n            Sk.abstr.superConstructor(mod.Counter, this, iter_or_map);\n\n        }\n        else {\n            if (!(Sk.builtin.checkIterable(iter_or_map))) {\n                throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iter_or_map) + \"' object is not iterable\");\n            }\n\n            Sk.abstr.superConstructor(mod.Counter, this);\n            var one = new Sk.builtin.int_(1);\n\n            for (var iter = iter_or_map.tp$iter(), k = iter.tp$iternext();\n                 k !== undefined;\n                 k = iter.tp$iternext()) {\n                var count = this.mp$subscript(k);\n                count = count.nb$add(one);\n                this.mp$ass_subscript(k, count);\n            }\n        }\n\n        return this;\n    };\n\n    Sk.abstr.setUpInheritance(\"Counter\", mod.Counter, Sk.builtin.dict);\n\n    mod.Counter.prototype['$r'] = function () {\n        var dict_str = this.size > 0 ? Sk.builtin.dict.prototype['$r'].call(this).v : '';\n        return new Sk.builtin.str('Counter(' + dict_str + ')');\n    };\n\n    mod.Counter.prototype.mp$subscript = function (key) {\n        try {\n            return Sk.builtin.dict.prototype.mp$subscript.call(this, key);\n        }\n        catch (e) {\n            return new Sk.builtin.int_(0);\n        }\n    };\n\n    mod.Counter.prototype['elements'] = new Sk.builtin.func(function (self) {\n        Sk.builtin.pyCheckArgs('elements', arguments, 1, 1);\n        var all_elements = [];\n        for (var iter = self.tp$iter(), k = iter.tp$iternext();\n             k !== undefined;\n             k = iter.tp$iternext()) {\n            for (var i = 0; i < self.mp$subscript(k).v; i++) {\n                all_elements.push(k);\n            }\n        }\n\n        var ret =\n        {\n            tp$iter: function () {\n                return ret;\n            },\n            $obj: this,\n            $index: 0,\n            $elem: all_elements,\n            tp$iternext: function () {\n                if (ret.$index >= ret.$elem.length) {\n                    return undefined;\n                }\n                return ret.$elem[ret.$index++];\n            }\n        };\n\n        return ret;\n\n    });\n\n    mod.Counter.prototype['most_common'] = new Sk.builtin.func(function (self, n) {\n        Sk.builtin.pyCheckArgs('most_common', arguments, 1, 2);\n        var length = self.mp$length();\n\n        if (n === undefined) {\n            n = length;\n        }\n        else {\n            if (!Sk.builtin.checkInt(n)) {\n                if (n instanceof Sk.builtin.float_) {\n                    throw new Sk.builtin.TypeError(\"integer argument expected, got float\");\n                }\n                else {\n                    throw new Sk.builtin.TypeError(\"an integer is required\");\n                }\n            }\n\n            n = Sk.builtin.asnum$(n);\n            n = n <= length ? n : length;\n            n = n >= 0 ? n : 0;\n        }\n\n        var most_common_elem = [];\n        for (var iter = self.tp$iter(), k = iter.tp$iternext();\n             k !== undefined;\n             k = iter.tp$iternext()) {\n            most_common_elem.push([k, self.mp$subscript(k)]);\n        }\n\n        var sort_func = function (a, b) {\n            if (a[1].v < b[1].v) {\n                return 1;\n            } else if (a[1].v > b[1].v) {\n                return -1;\n            } else {\n                return 0;\n            }\n        };\n        most_common_elem = most_common_elem.sort(sort_func);\n\n        var ret = [];\n        for (var i = 0; i < n; i++) {\n            ret.push(new Sk.builtin.tuple(most_common_elem.shift()));\n        }\n\n        return new Sk.builtin.list(ret);\n    });\n\n    mod.Counter.prototype['update'] = new Sk.builtin.func(function (self, other) {\n        Sk.builtin.pyCheckArgs('update', arguments, 1, 2);\n\n        if (other instanceof Sk.builtin.dict) {\n            for (var iter = other.tp$iter(), k = iter.tp$iternext();\n                 k !== undefined;\n                 k = iter.tp$iternext()) {\n                var count = self.mp$subscript(k);\n                self.mp$ass_subscript(k, count.nb$add(other.mp$subscript(k)));\n            }\n        }\n        else if (other !== undefined) {\n            if (!Sk.builtin.checkIterable(other)) {\n                throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(other) + \"' object is not iterable\");\n            }\n\n            var one = new Sk.builtin.int_(1);\n            for (var iter = other.tp$iter(), k = iter.tp$iternext();\n                 k !== undefined;\n                 k = iter.tp$iternext()) {\n                var count = self.mp$subscript(k);\n                self.mp$ass_subscript(k, count.nb$add(one));\n            }\n        }\n    });\n\n    mod.Counter.prototype['subtract'] = new Sk.builtin.func(function (self, other) {\n        Sk.builtin.pyCheckArgs('subtract', arguments, 1, 2);\n\n        if (other instanceof Sk.builtin.dict) {\n            for (var iter = other.tp$iter(), k = iter.tp$iternext();\n                 k !== undefined;\n                 k = iter.tp$iternext()) {\n                var count = self.mp$subscript(k);\n                self.mp$ass_subscript(k, count.nb$subtract(other.mp$subscript(k)));\n            }\n        }\n        else if (other !== undefined) {\n            if (!Sk.builtin.checkIterable(other)) {\n                throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(other) + \"' object is not iterable\");\n            }\n\n            var one = new Sk.builtin.int_(1);\n            for (var iter = other.tp$iter(), k = iter.tp$iternext();\n                 k !== undefined;\n                 k = iter.tp$iternext()) {\n                var count = self.mp$subscript(k);\n                self.mp$ass_subscript(k, count.nb$subtract(one));\n            }\n        }\n    });\n\n\n    // OrderedDict\n    mod.OrderedDict = function OrderedDict(items)\n    {\n        if (!(this instanceof mod.OrderedDict))\n        {\n            return new mod.OrderedDict(items);\n        }\n\n        this.orderedkeys = [];\n\n        Sk.abstr.superConstructor(mod.OrderedDict, this, items);\n\n        return this;\n    }\n\n    Sk.abstr.setUpInheritance(\"OrderedDict\", mod.OrderedDict, Sk.builtin.dict);\n\n    mod.OrderedDict.prototype['$r'] = function()\n    {\n        var v;\n        var iter, k;\n        var ret = [];\n        var pairstr;\n        for (iter = this.tp$iter(), k = iter.tp$iternext();\n             k !== undefined;\n             k = iter.tp$iternext()) {\n            v = this.mp$subscript(k);\n            if (v === undefined) {\n                //print(k, \"had undefined v\");\n                v = null;\n            }\n            ret.push(\"(\" + Sk.misceval.objectRepr(k).v + \", \" + Sk.misceval.objectRepr(v).v + \")\");\n        }\n        pairstr = ret.join(\", \");\n        if (ret.length > 0)\n        {\n            pairstr = \"[\" + pairstr + \"]\";\n        }\n        return new Sk.builtin.str(\"OrderedDict(\" + pairstr + \")\");\n    }\n\n    mod.OrderedDict.prototype.mp$ass_subscript = function(key, w)\n    {\n        var idx = this.orderedkeys.indexOf(key);\n        if (idx == -1)\n        {\n            this.orderedkeys.push(key);\n        }\n\n        return Sk.builtin.dict.prototype.mp$ass_subscript.call(this, key, w);\n    }\n\n    mod.OrderedDict.prototype.mp$del_subscript = function(key)\n    {\n        var idx = this.orderedkeys.indexOf(key);\n        if (idx != -1)\n        {\n            this.orderedkeys.splice(idx, 1);\n        }\n\n        return Sk.builtin.dict.prototype.mp$del_subscript.call(this, key);\n    }\n\n    mod.OrderedDict.prototype.__iter__ = new Sk.builtin.func(function (self) {\n        Sk.builtin.pyCheckArgs(\"__iter__\", arguments, 0, 0, false, true);\n\n        return mod.OrderedDict.prototype.tp$iter.call(self);\n    });\n\n    mod.OrderedDict.prototype.tp$iter = function()\n    {\n        var ret;\n        ret =\n        {\n            tp$iter    : function () {\n                return ret;\n            },\n            $obj       : this,\n            $index     : 0,\n            $keys      : this.orderedkeys.slice(0),\n            tp$iternext: function () {\n                // todo; StopIteration\n                if (ret.$index >= ret.$keys.length) {\n                    return undefined;\n                }\n                return ret.$keys[ret.$index++];\n            }\n        };\n        return ret;\n    }\n\n    mod.OrderedDict.prototype.ob$eq = function (other) {\n        var l;\n        var otherl;\n        var iter;\n        var k;\n        var v;\n\n        if (!(other instanceof mod.OrderedDict))\n        {\n            return Sk.builtin.dict.prototype.ob$eq.call(this, other);\n        }\n\n        l = this.mp$length();\n        otherl = other.mp$length();\n\n        if (l !== otherl) {\n            return Sk.builtin.bool.false$;\n        }\n\n        for (iter = this.tp$iter(), otheriter = other.tp$iter(),\n             k = iter.tp$iternext(), otherk = otheriter.tp$iternext();\n             k !== undefined;\n             k = iter.tp$iternext(), otherk = otheriter.tp$iternext()) \n        {\n            if (!Sk.misceval.isTrue(Sk.misceval.richCompareBool(k, otherk, \"Eq\")))\n            {\n                return Sk.builtin.bool.false$;\n            }\n            v = this.mp$subscript(k);\n            otherv = other.mp$subscript(otherk);\n\n            if (!Sk.misceval.isTrue(Sk.misceval.richCompareBool(v, otherv, \"Eq\"))) {\n                return Sk.builtin.bool.false$;\n            }\n        }\n\n        return Sk.builtin.bool.true$;\n    };\n\n    mod.OrderedDict.prototype.ob$ne = function (other) {\n        var l;\n        var otherl;\n        var iter;\n        var k;\n        var v;\n\n        if (!(other instanceof mod.OrderedDict))\n        {\n            return Sk.builtin.dict.prototype.ob$ne.call(this, other);\n        }\n\n        l = this.size;\n        otherl = other.size;\n\n        if (l !== otherl) {\n            return Sk.builtin.bool.true$;\n        }\n\n        for (iter = this.tp$iter(), otheriter = other.tp$iter(),\n             k = iter.tp$iternext(), otherk = otheriter.tp$iternext();\n             k !== undefined;\n             k = iter.tp$iternext(), otherk = otheriter.tp$iternext()) \n        {\n            if (!Sk.misceval.isTrue(Sk.misceval.richCompareBool(k, otherk, \"Eq\")))\n            {\n                return Sk.builtin.bool.true$;\n            }\n            v = this.mp$subscript(k);\n            otherv = other.mp$subscript(otherk);\n\n            if (!Sk.misceval.isTrue(Sk.misceval.richCompareBool(v, otherv, \"Eq\"))) {\n                return Sk.builtin.bool.true$;\n            }\n        }\n\n        return Sk.builtin.bool.false$;\n    };\n\n    mod.OrderedDict.prototype[\"pop\"] = new Sk.builtin.func(function (self, key, d) {\n        var s;\n        var idx;\n\n        Sk.builtin.pyCheckArgs('pop', arguments, 2, 3);\n\n        idx = self.orderedkeys.indexOf(key);\n        if (idx != -1)\n        {\n            self.orderedkeys.splice(idx, 1);\n        }\n\n        return Sk.misceval.callsim(Sk.builtin.dict.prototype[\"pop\"], self, key, d);\n    });\n\n    mod.OrderedDict.prototype[\"popitem\"] = new Sk.builtin.func(function (self, last) {\n        var key, val;\n        var s;\n\n        Sk.builtin.pyCheckArgs('popitem', arguments, 1, 2);\n\n        // Empty dictionary\n        if (self.orderedkeys.length == 0)\n        {\n            s = new Sk.builtin.str('dictionary is empty');\n            throw new Sk.builtin.KeyError(s.v);\n        }\n\n        key = self.orderedkeys[0];\n        if (last === undefined || Sk.misceval.isTrue(last))\n        {\n            key = self.orderedkeys[self.orderedkeys.length - 1];\n        }\n\n        val = Sk.misceval.callsim(self[\"pop\"], self, key);\n        return Sk.builtin.tuple([key, val]);\n    });\n\n    // deque\n    mod.deque = function deque(iterable, maxlen) {\n        throw new Sk.builtin.NotImplementedError(\"deque is not implemented\")\n    };\n\n    // namedtuple\n    mod.namedtuples = {};\n    var keywds = Sk.importModule(\"keyword\", false, false);\n    // should cover most things.  Does not:\n    // * keyword args\n    // _make\n    // _replace\n    // _asdict\n    // _fields\n\n\n    var hasDupes = function(a) {\n        var counts = [];\n        for(var i = 0; i <= a.length; i++) {\n            if(counts[a[i]] === undefined) {\n                counts[a[i]] = 1;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    var Skinherits = function(childCtor, parentCtor) {\n      /** @constructor */\n      function tempCtor() {};\n      tempCtor.prototype = parentCtor.prototype;\n      childCtor.superClass_ = parentCtor.prototype;\n      childCtor.prototype = new tempCtor();\n      /** @override */\n      childCtor.prototype.constructor = childCtor;\n    };\n\n    mod.namedtuple = function (name, fields) {\n        if (Sk.ffi.remapToJs(Sk.misceval.callsim(keywds.$d['iskeyword'],name ))) {\n            throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: \" + name.v);\n        }\n        var nm = Sk.ffi.remapToJs(name);\n        startsw = new RegExp(/^[0-9].*/);\n        startsw2 = new RegExp(/^[0-9_].*/);\n        alnum = new RegExp(/^\\w*$/);\n        if (startsw.test(nm) || (! alnum.test(nm))) {\n            throw new Sk.builtin.ValueError(\" Bad type name \" + nm);\n        }\n        // fields could be a string or a tuple or list of strings\n        var flds = Sk.ffi.remapToJs(fields);\n\n        if (typeof(flds) === 'string') {\n            flds = flds.split(/\\s+/);\n        }\n        // import the keyword module here and use iskeyword\n        for (i = 0; i < flds.length; i++) {\n            if (Sk.ffi.remapToJs(Sk.misceval.callsim(keywds.$d['iskeyword'],Sk.ffi.remapToPy(flds[i]))) ||\n                  startsw2.test(flds[i]) || (! alnum.test(flds[i]))\n            ) {\n                throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: \" + flds[i]);\n            }\n        }\n        if (hasDupes(flds)) {\n            throw new Sk.builtin.ValueError(\"Field names must be unique.\");\n        }\n\n        var cons = function nametuple_constructor() {\n            var o;\n            if (arguments.length !== flds.length ) {\n                throw new Sk.builtin.TypeError(\"Number of arguments must match\");\n            }\n            if (!(this instanceof mod.namedtuples[nm])) {\n                o = Object.create(mod.namedtuples[nm].prototype);\n                o.constructor.apply(o, arguments);\n                return o;\n            }\n            this.__class__ = mod.namedtuples[nm];\n            this.v = Array.prototype.slice.call(arguments);\n        };\n        mod.namedtuples[nm] = cons;\n\n        Skinherits(cons, Sk.builtin.tuple);\n        cons.prototype.tp$name = nm;\n        cons.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(nm, mod.namedtuples[nm]);\n        cons.prototype[\"$r\"] = function () {\n            var ret;\n            var i;\n            var bits;\n            if (this.v.length === 0) {\n                return new Sk.builtin.str(nm + \"()\");\n            }\n            bits = [];\n            for (i = 0; i < this.v.length; ++i) {\n                bits[i] = flds[i] + \"=\" + Sk.misceval.objectRepr(this.v[i]).v;\n            }\n            ret = bits.join(\", \");\n            if (this.v.length === 1) {\n                ret += \",\";\n            }\n            return new Sk.builtin.str(nm + \"(\" + ret + \")\");\n        };\n\n        cons.prototype.tp$getattr = function (name) {\n            var i = flds.indexOf(name);\n            if (i >= 0) {\n                return this.v[i];\n            }\n            return undefined;\n        };\n\n        cons.prototype.tp$setattr = function (name, value) {\n            throw new Sk.builtin.AttributeError(\"can't set attribute\");\n        };\n\n        return cons;\n    };\n\n    return mod;\n};\n", "src/lib/httplib.py": "raise NotImplementedError(\"httplib is not yet implemented in Skulpt\")\n", "src/lib/string.py": "raise NotImplementedError(\"string is not yet implemented in Skulpt\")\n", "src/lib/smtplib.py": "raise NotImplementedError(\"smtplib is not yet implemented in Skulpt\")\n", "src/lib/getopt.py": "raise NotImplementedError(\"getopt is not yet implemented in Skulpt\")\n", "src/lib/toaiff.py": "raise NotImplementedError(\"toaiff is not yet implemented in Skulpt\")\n", "src/lib/timeit.py": "raise NotImplementedError(\"timeit is not yet implemented in Skulpt\")\n", "src/lib/hmac.py": "raise NotImplementedError(\"hmac is not yet implemented in Skulpt\")\n", "src/lib/tarfile.py": "raise NotImplementedError(\"tarfile is not yet implemented in Skulpt\")\n", "src/lib/stringprep.py": "raise NotImplementedError(\"stringprep is not yet implemented in Skulpt\")\n", "src/lib/posixfile.py": "raise NotImplementedError(\"posixfile is not yet implemented in Skulpt\")\n", "src/lib/ssl.py": "raise NotImplementedError(\"ssl is not yet implemented in Skulpt\")\n", "src/lib/turtle.js": "var $builtinmodule = function (name) {\n\"use strict\";\n\nfunction getConfiguredTarget() {\n    var selector, target;\n\n    selector = (Sk.TurtleGraphics && Sk.TurtleGraphics.target) || \"turtle\",\n    target   = typeof selector === \"string\" ?\n        document.getElementById(selector) :\n        selector;\n    // ensure that the canvas container is empty\n    while (target.firstChild) {\n        target.removeChild(target.firstChild);\n    }\n    return target;\n}\n\nfunction generateTurtleModule(_target) {\n    var _module              = {},\n        _durationSinceRedraw = 0,\n        _focus               = true,\n        OPTIMAL_FRAME_RATE   = 1000/30,\n        SHAPES               = {},\n        TURTLE_COUNT         = 0,\n        Types                = {},\n        _frameRequest,\n        _frameRequestTimeout,\n        _screenInstance,\n        _config,\n        _anonymousTurtle,\n        _mouseHandler;\n\n    // Ensure that the turtle DOM target has a tabindex\n    // so that it can accept keyboard focus and events\n    if (!_target.hasAttribute(\"tabindex\")) {\n        _target.setAttribute(\"tabindex\", 0);\n    }\n\n    Types.FLOAT = function(value) {\n        return Sk.builtin.float_(value);\n    };\n    Types.COLOR = function(value) {\n        if (typeof value === \"string\") {\n            return new Sk.builtin.str(value);\n        }\n        else {\n            for(var i = 0; i < 3; i++) {\n                value[i] = Sk.builtin.assk$(value[i]);\n            }\n            if (value.length === 4) {\n                value[3] = Sk.builtin.float_(value[3]);\n            }\n            return new Sk.builtin.tuple(value);\n        }\n    };\n    Types.TURTLE_LIST = function(value) {\n        var skValues = [];\n        for (var i = 0; i < value.length; i++) {\n            skValues.push(value[i].skInstance);\n        }\n        return new Sk.builtin.tuple(skValues);\n    };\n\n    SHAPES.arrow    = [[-10,0],[10,0],[0,10]];\n    SHAPES.square   = [[ 10,-10],[10,10],[-10,10],[-10, -10]];\n    SHAPES.triangle = [[10,-5.77],[0,11.55],[-10,-5.77]];\n    SHAPES.classic  = [[0,0],[-5,-9],[0,-7],[5,-9]];\n    SHAPES.turtle   = [\n        [0,16],[-2,14],[-1,10],[-4,7],[-7,9],[-9,8],[-6,5],[-7,1],[-5,-3],[-8,-6],\n        [-6,-8],[-4,-5],[0,-7],[4,-5],[6,-8],[8,-6],[5,-3],[7,1],[6,5],[9,8],[7,9],\n        [4,7],[1,10],[2,14]\n    ];\n\n    SHAPES.circle = [\n        [10,0],[9.51,3.09],[8.09,5.88],[5.88,8.09],[3.09,9.51],[0,10],[-3.09,9.51],\n        [-5.88,8.09],[-8.09,5.88],[-9.51,3.09],[-10,0],[-9.51,-3.09],[-8.09,-5.88],\n        [-5.88,-8.09],[-3.09,-9.51],[-0,-10],[3.09,-9.51],[5.88,-8.09],[8.09,-5.88],\n        [9.51,-3.09]\n    ];\n\n    _config = (function() {\n        var defaultSetup = {\n                target     : \"turtle\", // DOM element or id of parent container\n                width      : 400, // if set to 0 it will use the target width\n                height     : 400, // if set to 0 it will use the target height\n                animate    : true, // enabled/disable all animated rendering\n                bufferSize : 0, // default turtle buffer size\n                allowUndo  : true, // enable ability to use the undo buffer\n            },\n            key;\n\n        if (!Sk.TurtleGraphics) {\n            Sk.TurtleGraphics = {};\n        }\n\n        for(key in defaultSetup) {\n            if (!Sk.TurtleGraphics.hasOwnProperty(key)) {\n                Sk.TurtleGraphics[key] = defaultSetup[key];\n            }\n        }\n\n        return Sk.TurtleGraphics;\n    })();\n\n    // InstantPromise is a workaround to allow usage of the clean promise-style\n    // then/catch syntax but to instantly call resolve the then/catch chain so we\n    // can avoid creating Suspensions in unnecessary cases.  This is desirable\n    // because Suspensions have a fairly large negative impact on overall\n    // performance.  These 'instant promises' come into play when a tracer()\n    // call is made with a value other than 1.  When tracer is 0 or greater than 1\n    // , we can bypass the creation of a Suspension and proceed to the next line of\n    // code immediately if the current line is not going to incur involve a screen\n    // update. We determine if a real promise or InstantPromise is necessary by\n    // checking FrameManager.willRenderNext()\n    function InstantPromise() {\n        this.lastResult = undefined;\n        this.lastError  = undefined;\n    }\n\n    InstantPromise.prototype.then = function(cb) {\n        if (this.lastError) {\n            return this;\n        }\n\n        try {\n         this.lastResult = cb(this.lastResult);\n        } catch(e) {\n            this.lastResult = undefined;\n            this.lastError  = e;\n        }\n\n        return this.lastResult instanceof Promise ? this.lastResult : this;\n    };\n\n    InstantPromise.prototype.catch = function(cb) {\n        if (this.lastError) {\n            try {\n                this.lastResult = cb(this.lastError);\n                this.lastError  = undefined;\n            } catch(e) {\n                this.lastResult = undefined;\n                this.lastError = e;\n            }\n        }\n\n        return this.lastResult instanceof Promise ? this.lastResult : this;\n    };\n\n    function FrameManager() {\n        this.reset();\n    }\n\n    var _frameManager;\n    function getFrameManager() {\n        if (!_frameManager) {\n            _frameManager = new FrameManager();\n        }\n        return _frameManager;\n    }\n\n    (function(proto) {\n        var browserFrame;\n        (function(frame) {\n            if (frame) {\n                browserFrame = function(method) {\n                    return (_frameRequest = frame(method));\n                };\n            }\n        })(window.requestAnimationFrame || window.mozRequestAnimationFrame);\n\n        function animationFrame(delay) {\n            if (!_config.animate) {\n                return function(method) {\n                    method();\n                };\n            }\n\n            if (!delay && browserFrame) {\n                return browserFrame;\n            }\n\n            return function(method) {\n                _frameRequestTimeout = window.setTimeout(\n                    method,\n                    delay || OPTIMAL_FRAME_RATE\n                );\n                 return _frameRequestTimeout;\n            };\n        }\n\n        proto.willRenderNext = function() {\n            return !!(this._buffer && this._frameCount+1 === this.frameBuffer());\n        };\n\n        proto.turtles = function() {\n            return this._turtles;\n        };\n\n        proto.addTurtle = function(turtle) {\n            this._turtles.push(turtle);\n        };\n\n        proto.reset = function() {\n            if (this._turtles) {\n                for(var i = this._turtles.length; --i >= 0;) {\n                    this._turtles[i].reset();\n                }\n            }\n            this._turtles        = [];\n            this._frames         = [];\n            this._frameCount     = 0;\n            this._buffer         = 1;\n            this._rate           = 0;\n            this._animationFrame = animationFrame();\n        };\n\n        proto.addFrame = function(method, countAsFrame) {\n            var instant = false;\n\n            if (countAsFrame) {\n                this._frameCount += 1;\n            }\n\n            this.frames().push(method);\n\n            instant = (\n                !_config.animate ||\n                (this._buffer && this._frameCount === this.frameBuffer())\n            );\n\n            return instant ? this.update() : new InstantPromise();\n        };\n\n        proto.frames = function() {\n            return this._frames;\n        };\n\n        proto.frameBuffer = function(buffer) {\n            if (typeof buffer === \"number\") {\n                this._buffer = buffer | 0;\n                if (buffer && buffer <= this._frameCount) {\n                    return this.update();\n                }\n            }\n            return this._buffer;\n        };\n\n        proto.refreshInterval = function(rate) {\n            if (typeof rate === \"number\") {\n                this._rate = rate | 0;\n                this._animationFrame = animationFrame(rate);\n            }\n            return this._rate;\n        };\n\n        proto.update = function() {\n            return (this._frames && this._frames.length) ?\n                this.requestAnimationFrame() :\n                new InstantPromise();\n        };\n\n        proto.requestAnimationFrame = function() {\n            var frames         = this._frames,\n                animationFrame = this._animationFrame,\n                turtles        = this._turtles,\n                sprites        = getScreen().spriteLayer(),\n                turtle, i;\n\n            this._frames     = [];\n            this._frameCount = 0;\n\n            return new Promise(function(resolve) {\n                animationFrame(function paint() {\n                    for (i = 0; i < frames.length; i++) {\n                        if (frames[i]) {\n                            frames[i]();\n                        }\n                    }\n                    clearLayer(sprites);\n                    for (i = 0; i < turtles.length; i++) {\n                        turtle = turtles[i];\n                        if (turtle.getState().shown) {\n                            drawTurtle(turtle.getState(), sprites);\n                        }\n                    }\n                    resolve();\n                });\n            });\n        };\n    })(FrameManager.prototype);\n\n    function MouseHandler() {\n        var self = this;\n\n        this._target   = getTarget();\n        this._managers = {};\n        this._handlers = {\n            mousedown : function(e) {\n                self.onEvent(\"mousedown\", e);\n            },\n            mouseup : function(e) {\n                self.onEvent(\"mouseup\", e);\n            },\n            mousemove : function(e) {\n                self.onEvent(\"mousemove\", e);\n            }\n        };\n        for (var key in this._handlers) {\n            this._target.addEventListener(key, this._handlers[key]);\n        }\n    }\n\n    (function(proto) {\n        proto.onEvent = function(type, e) {\n            var managers     = this._managers[type],\n                moveManagers = this._managers[\"mousemove\"],\n                computed     = false,\n                x, y, localX, localY, i;\n\n            function computeCoordinates() {\n                if (computed) return;\n                var world = getScreen();\n                var rect  = world.spriteLayer().canvas.getBoundingClientRect();\n                x         = e.clientX - rect.left | 0;\n                y         = e.clientY - rect.top  | 0;\n                localX    = x * world.xScale + world.llx;\n                localY    = y * world.yScale + world.ury;\n                computed = true;\n            }\n\n            if ((type === \"mousedown\" || type === \"mouseup\") && moveManagers && moveManagers.length) {\n                computeCoordinates();\n                for (i = moveManagers.length; --i >= 0;) {\n                    if (moveManagers[i].test(x, y, localX, localY)) {\n                        moveManagers[i].canMove(type === \"mousedown\");\n                    }\n                }\n            }\n\n            if (managers && managers.length) {\n                computeCoordinates();\n                for (i = managers.length; --i >= 0;) {\n                    if (type === \"mousemove\") {\n                        if (managers[i].canMove()) {\n                            managers[i].trigger([localX, localY]);\n                        }\n                        continue;\n                    }\n\n                    if (managers[i].test(x, y, localX, localY)) {\n                        managers[i].trigger([localX, localY]);\n                    }\n                }\n            }\n        };\n\n        proto.reset = function() {\n            this._managers = {};\n        };\n\n        proto.addManager = function(type, manager) {\n            if (!this._managers[type]) {\n                this._managers[type] = [];\n            }\n\n            this._managers[type].push(manager);\n        };\n\n    })(MouseHandler.prototype);\n\n    function EventManager(type, target) {\n        this._type     = type;\n        this._target   = target;\n        this._handlers = undefined;\n        getMouseHandler().addManager(type, this);\n    }\n\n    (function(proto) {\n        proto.reset = function() {\n            this._handlers = undefined;\n        };\n\n        proto.canMove = function(value) {\n            if (!this._target || !this._target.hitTest) return false;\n\n            if (value !== undefined) {\n                this._target.hitTest.hit = value;\n            }\n\n            return this._target.hitTest.hit;\n        };\n\n        proto.test = function(x, y, localX, localY) {\n            return this._target && this._target.hitTest ?\n                this._target.hitTest(x, y, localX, localY) :\n                !!this._target;\n        };\n\n        proto.trigger = function(args) {\n            var handlers = this._handlers,\n                i;\n\n            if (handlers && handlers.length) {\n                for (i = 0; i < handlers.length; i++) {\n                    handlers[i].apply({}, args);\n                }\n            }\n        };\n\n        proto.addHandler = function(handler, add) {\n            var handlers = this._handlers;\n\n            if (!add && handlers && handlers.length) {\n                // remove all existing handlers\n                while (handlers.shift()) {/* noop */}\n            }\n\n            if (typeof handler !== \"function\") {\n                if (handlers && !handlers.length) {\n                    this.reset();\n                }\n                return;\n            }\n\n            if (!handlers) {\n                handlers = this._handlers = [];\n            }\n\n            handlers.push(handler);\n        };\n    })(EventManager.prototype);\n\n    function Turtle() {\n        getFrameManager().addTurtle(this);\n        this._screen = getScreen();\n        this._managers = {};\n        this.reset();\n    }\n\n    Turtle.RADIANS = 2 * Math.PI;\n\n    (function(proto) {\n        proto.hitTest = function(mouseX, mouseY, localX, localY) {\n            var context = getScreen().hitTestLayer();\n            clearLayer(context);\n            drawTurtle(this.getState(), context);\n            var pixel = context.getImageData(mouseX,mouseY,1,1).data;\n            // check alpha first since it is most likely to have a value\n            return pixel[3] ||pixel[0] || pixel[1] || pixel[2];\n        };\n\n        proto.addUpdate = function(method, countAsFrame, stateChanges) {\n            var self  = this,\n                state = this.getState(),\n                args  = Array.prototype.slice.call(arguments, stateChanges ? 2 : 3);\n\n            return getFrameManager().addFrame(function() {\n                if (method) {\n                    method.apply(state, args);\n                }\n                if (stateChanges) {\n                    for(var key in stateChanges) {\n                        state[key] = stateChanges[key];\n                    }\n                }\n            }, countAsFrame);\n        };\n\n        proto.getState = function() {\n            var self = this;\n\n            if (!this._state) {\n                this._state = {\n                    x       : this._x,\n                    y       : this._y,\n                    angle   : this._angle,\n                    radians : this._radians,\n                    shape   : this._shape,\n                    color   : this._color,\n                    fill    : this._fill,\n                    filling : this._filling,\n                    size    : this._size,\n                    speed   : this._computed_speed,\n                    down    : this._down,\n                    shown   : this._shown,\n                    context : function() {\n                        return self.getPaper();\n                    }\n                };\n            }\n            return this._state;\n        };\n\n        proto.translate = function(startX, startY, dx, dy, beginPath, isCircle) {\n            var self = this;\n            return translate(this, startX, startY, dx, dy, beginPath, isCircle)\n                .then(function(coords) {\n                    self._x = coords[0];\n                    self._y = coords[1];\n                });\n        };\n\n        proto.rotate = function(startAngle, delta, isCircle) {\n            var self = this;\n            return rotate(this, startAngle, delta, isCircle)\n                .then(function(heading) {\n                    self._angle   = heading.angle;\n                    self._radians = heading.radians;\n                });\n        };\n\n        proto.queueMoveBy = function(startX, startY, theta, distance) {\n            var dx = Math.cos(theta) * distance,\n                dy = Math.sin(theta) * distance;\n\n            return this.translate(startX, startY, dx, dy, true);\n        };\n\n        proto.queueTurnTo = function(startAngle, endAngle) {\n            endAngle = endAngle % this._fullCircle;\n            if (endAngle < 0) {\n                endAngle += this._fullCircle;\n            }\n            return this.rotate(startAngle, endAngle - startAngle);\n        };\n\n        proto.getManager = function(type) {\n            if (!this._managers[type]) {\n                this._managers[type] = new EventManager(type, this);\n            }\n            return this._managers[type];\n        };\n\n        proto.getPaper = function() {\n            return this._paper || (this._paper = createLayer(2));\n        };\n\n        proto.reset = function() {\n            this._x          = 0;\n            this._y          = 0;\n            this._radians    = 0;\n            this._angle      = 0;\n            this._shown      = true;\n            this._down       = true;\n            this._color      = \"black\";\n            this._fill       = \"black\";\n            this._shape      = \"classic\";\n            this._size       = 1;\n            this._filling    = false;\n            this._undoBuffer = [];\n            this._speed      = 3;\n            this._computed_speed = 5;\n            this._state      = undefined;\n\n            for(var key in this._managers) {\n                this._managers[key].reset();\n            }\n\n            this._isRadians  = false;\n            this._fullCircle = 360;\n            this._bufferSize = typeof _config.bufferSize === \"number\" ?\n                _config.bufferSize :\n                0;\n\n            removeLayer(this._paper);\n            this._paper = undefined;\n        };\n\n        proto.$degrees = function(fullCircle) {\n            fullCircle = (typeof fullCircle === \"number\") ?\n                Math.abs(fullCircle) :\n                360;\n\n            this._isRadians  = false;\n            if (!fullCircle || !this._fullCircle) {\n                this._angle = this._radians = 0;\n            }\n            else {\n                this._angle = this._angle / this._fullCircle * fullCircle;\n            }\n            this._fullCircle = fullCircle;\n            return this.addUpdate(\n                undefined,\n                false,\n                {angle:this._angle, radians: this._radians}\n            );\n        };\n        proto.$degrees.minArgs     = 0;\n        proto.$degrees.keywordArgs = [\"fullcircle\"];\n        proto.$degrees.returnType  = Types.FLOAT;\n\n        proto.$radians = function() {\n            if (!this._isRadians) {\n                this._isRadians     = true;\n                this._angle = this._radians;\n                this._fullCircle = Turtle.RADIANS;\n            }\n\n            return this._angle;\n        };\n        proto.$radians.returnType = Types.FLOAT;\n\n        proto.$position = proto.$pos = function() {\n            return [this.$xcor(), this.$ycor()];\n        };\n        proto.$position.returnType = function(value) {\n            return new Sk.builtin.tuple([\n                    Sk.builtin.float_(value[0]),\n                    Sk.builtin.float_(value[1])\n            ]);\n        };\n\n        proto.$towards = function(x,y) {\n            var coords  = getCoordinates(x,y),\n                radians = Math.PI + Math.atan2(this._y - coords.y, this._x - coords.x),\n                angle   = radians * (this._fullCircle / Turtle.RADIANS);\n\n            return angle;\n        };\n        proto.$towards.minArgs    = 1;\n        proto.$towards.returnType = Types.FLOAT;\n\n        proto.$distance = function(x,y) {\n            var coords = getCoordinates(x,y),\n                dx     = coords.x - this._x,\n                dy     = coords.y - this._y;\n\n            return Math.sqrt(dx * dx + dy * dy);\n        };\n        proto.$distance.minArgs    = 1;\n        proto.$distance.returnType = Types.FLOAT;\n\n        proto.$heading = function() {\n            return Math.abs(this._angle) < 1e-13 ? 0 : this._angle;\n        };\n        proto.$heading.returnType = Types.FLOAT;\n\n        proto.$xcor = function() {\n            return Math.abs(this._x) < 1e-13 ? 0 : this._x;\n        };\n        proto.$xcor.returnType = Types.FLOAT;\n\n        proto.$ycor = function() {\n            return Math.abs(this._y) < 1e-13 ? 0 : this._y;\n        };\n        proto.$ycor.returnType = Types.FLOAT;\n\n        proto.$forward = proto.$fd = function(distance) {\n            pushUndo(this);\n            return this.queueMoveBy(this._x, this._y, this._radians, distance);\n        };\n\n        proto.$undo = function() {\n            popUndo(this);\n        };\n\n        proto.$undobufferentries = function() {\n            return this._undoBuffer.length;\n        };\n\n        proto.$setundobuffer = function(size) {\n            this._bufferSize = typeof size === \"number\" ?\n                Math.min(Math.abs(size), 1000) :\n                0;\n        };\n\n        proto.$backward = proto.$back = proto.$bk = function(distance) {\n            pushUndo(this);\n            return this.queueMoveBy(this._x, this._y, this._radians, -distance);\n        };\n\n        proto.$goto_$rw$ = proto.$setpos = proto.$setposition = function(x,y) {\n            var coords = getCoordinates(x,y);\n\n            pushUndo(this);\n\n            return this.translate(\n                this._x, this._y,\n                coords.x - this._x, coords.y - this._y,\n                true\n            );\n        };\n        proto.$goto_$rw$.minArgs = 1;\n\n        proto.$setx = function(x) {\n            return this.translate(this._x, this._y, x - this._x, 0, true);\n        };\n\n        proto.$sety = function(y) {\n            return this.translate(this._x, this._y, 0, y - this._y, true);\n        };\n\n        proto.$home = function() {\n            var self  = this,\n                angle = this._angle;\n\n            pushUndo(this);\n            return self.translate(this._x, this._y, -this._x, -this._y, true)\n                .then(function(position) {\n                    return self.queueTurnTo(angle, 0);\n                })\n                .then(function(heading) {\n                    return undefined;\n                });\n        };\n\n        proto.$right = proto.$rt = function(angle) {\n            pushUndo(this);\n            return this.rotate(this._angle, -angle);\n        };\n\n        proto.$left = proto.$lt = function(angle) {\n            pushUndo(this);\n            return this.rotate(this._angle, angle);\n        };\n\n        proto.$setheading = proto.$seth = function(angle) {\n            pushUndo(this);\n            return this.queueTurnTo(this._angle, angle);\n        };\n\n        function circleRotate(turtle, angle, radians) {\n            return function() {\n                return turtle.addUpdate(\n                    undefined,\n                    false,{angle:angle, radians:radians}\n                );\n            };\n        }\n\n        function circleSegment(turtle, x, y, dx, dy, beginPath) {\n            return function() {\n                return turtle.translate(x, y, dx, dy, beginPath, true);\n            };\n        }\n\n        proto.$circle = function(radius, extent, steps) {\n            var self      = this,\n                x         = this._x,\n                y         = this._y,\n                angle     = this._angle,\n                heading   = {},\n                states    = [],\n                scale     = 1/getScreen().lineScale,\n                beginPath = true,\n                endAngle, frac, w, w2, l, i, dx, dy, promise;\n\n            pushUndo(this);\n\n            if (extent === undefined) {\n                extent = self._fullCircle;\n            }\n\n            if (steps === undefined) {\n                frac  = Math.abs(extent)/self._fullCircle;\n                steps = 1 + ((Math.min(11+Math.abs(radius*scale)/6, 59)*frac) | 0);\n            }\n            w  = extent / steps;\n            w2 = 0.5 * w;\n            l  = 2 * radius * Math.sin(w*Math.PI/self._fullCircle);\n\n            if (radius < 0) {\n                l = -l;\n                w = -w;\n                w2 = -w2;\n                endAngle = angle - extent;\n            }\n            else {\n                endAngle = angle + extent;\n            }\n\n            promise = getFrameManager().willRenderNext() ? Promise.resolve() : new InstantPromise();\n\n            angle += w2;\n\n            for(i = 0; i < steps; i++) {\n                calculateHeading(self, angle + w * i, heading);\n                dx = Math.cos(heading.radians) * l;\n                dy = Math.sin(heading.radians) * l;\n                promise = promise\n                    .then(circleRotate(self, heading.angle, heading.radians))\n                    .then(circleSegment(self, x, y, dx, dy, beginPath));\n                x += dx;\n                y += dy;\n                beginPath = false;\n            }\n\n            promise = promise.then(function() {\n                calculateHeading(self, endAngle, heading);\n                self._angle   = heading.angle;\n                self._radians = heading.radians;\n                return self.addUpdate(undefined, true, heading);\n            });\n\n            return promise;\n        };\n        proto.$circle.keywordArgs = [\"extent\", \"steps\"];\n        proto.$circle.minArgs     = 1;\n\n        proto.$penup = proto.$up = proto.$pu = function() {\n            this._down = false;\n            return this.addUpdate(undefined, false, {down:false});\n        };\n\n        proto.$pendown = proto.$down = proto.$pd = function() {\n            this._down = true;\n            return this.addUpdate(undefined, false, {down:true});\n        };\n\n        proto.$isdown = function() {\n            return this._down;\n        };\n\n        proto.$speed = function(speed) {\n            if (arguments.length) {\n                this._speed          = Math.max(0, Math.min(1000, speed));\n                this._computed_speed = Math.max(0, speed * 2 - 1);\n                return this.addUpdate(undefined, false, {speed:this._computed_speed});\n            }\n\n            return this._speed;\n        };\n        proto.$speed.minArgs = 0;\n        proto.$speed.keywordArgs = [\"speed\"];\n\n        proto.$pencolor = function(r,g,b,a) {\n            var color;\n\n            if (arguments.length) {\n                this._color = createColor(r,g,b,a);\n                return this.addUpdate(undefined, this._shown, {color : this._color});\n            }\n\n            return hexToRGB(this._color);\n        };\n        proto.$pencolor.minArgs = 0;\n        proto.$pencolor.returnType = Types.COLOR;\n\n        proto.$fillcolor = function(r,g,b,a) {\n            var color;\n\n            if (arguments.length) {\n                this._fill = createColor(r,g,b,a);\n                return this.addUpdate(undefined, this._shown, {fill : this._fill});\n            }\n\n            return hexToRGB(this._fill);\n        };\n        proto.$fillcolor.minArgs = 0;\n        proto.$fillcolor.returnType = Types.COLOR;\n\n        proto.$color = function(color, fill, b, a) {\n            if (arguments.length) {\n                if (arguments.length === 1 || arguments.length >= 3) {\n                    this._color = createColor(color, fill, b, a);\n                    this._fill  = this._color;\n                }\n                else {\n                    this._color = createColor(color);\n                    this._fill  = createColor(fill);\n                }\n                return this.addUpdate(undefined, this._shown, {\n                    color : this._color,\n                    fill  : this._fill\n                });\n            }\n            return [this.$pencolor(), this.$fillcolor()];\n        };\n        proto.$color.minArgs = 0;\n        proto.$color.returnType = function(value) {\n            return new Sk.builtin.tuple([\n                Types.COLOR(value[0]),\n                Types.COLOR(value[1])\n            ]);\n        };\n\n        proto.$fill = function(flag) {\n            var self = this;\n\n            if (flag !== undefined) {\n                flag = !!flag;\n                if (flag === this._filling) return;\n                this._filling = flag;\n                if (flag) {\n                    pushUndo(this);\n                    return this.addUpdate(undefined, false, {\n                        filling      : true,\n                        fillBuffer : [{x : this._x, y : this._y}]\n                    });\n                }\n                else {\n                    pushUndo(this);\n                    return this.addUpdate(\n                        function() {\n                            this.fillBuffer.push(this);\n                            drawFill.call(this);\n                        },\n                        true,\n                        {\n                            filling      : false,\n                            fillBuffer : undefined\n                        }\n                    );\n                }\n            }\n\n            return this._filling;\n        };\n        proto.$fill.minArgs = 0;\n\n        proto.$begin_fill = function() {\n            return this.$fill(true);\n        };\n\n        proto.$end_fill = function() {\n            return this.$fill(false);\n        };\n\n        proto.$stamp = function() {\n            pushUndo(this);\n            return this.addUpdate(function() {\n                drawTurtle(this, this.context());\n            }, true);\n        };\n\n        proto.$dot = function(size, color, g, b, a) {\n            pushUndo(this);\n            size = Sk.builtin.asnum$(size);\n            size = (typeof size === \"number\") ?\n                Math.max(1, Math.abs(size) | 0) :\n                Math.max(this._size + 4, this._size * 2);\n\n            color = (color !== undefined) ?\n                createColor(color, g, b, a) :\n                this._color;\n\n            return this.addUpdate(drawDot, true, undefined, size, color);\n        };\n\n        proto.$write = function(message,move,align,font) {\n            var self = this,\n                promise, face, size, type, width;\n\n            pushUndo(this);\n\n            message = String(message);\n\n            if (font && font.constructor === Array) {\n                face = typeof font[0] === \"string\" ? font[0] : \"Arial\";\n                size = String(font[1] || \"12pt\");\n                type = typeof font[2] === \"string\" ? font[2] : \"normal\";\n                if (/^\\d+$/.test(size)) {\n                    size += \"pt\";\n                }\n\n                font = [type, size, face].join(\" \");\n            }\n\n            if (!align) {\n                align = \"left\";\n            }\n\n            promise = this.addUpdate(\n                drawText, true, undefined, message, align, font\n            );\n\n            if (move && (align === \"left\" || align === \"center\")) {\n                width = measureText(message, font);\n                if (align === \"center\") {\n                    width = width/2;\n                }\n                promise = promise.then(function() {\n                    var state = self.getState();\n                    return self.translate(state.x, state.y, width, 0, true);\n                });\n            }\n\n            return promise;\n        };\n        proto.$write.keywordArgs = [\"move\",\"align\",\"font\"];\n        proto.$write.minArgs     = 1;\n\n        proto.$pensize = proto.$width = function(size) {\n            if (arguments.length) {\n                this._size = size;\n                return this.addUpdate(undefined, this._shown, {size : size});\n            }\n\n            return this._size;\n        };\n        proto.$pensize.minArgs = proto.$width.minArgs = 0;\n        proto.$pensize.keywordArgs = proto.$width.keywordArgs = [\"width\"];\n\n        proto.$showturtle = proto.$st = function() {\n            this._shown = true;\n            return this.addUpdate(undefined, true, {shown : true});\n        };\n\n        proto.$hideturtle = proto.$ht = function() {\n            this._shown = false;\n            return this.addUpdate(undefined, true, {shown : false});\n        };\n\n        proto.$isvisible = function() {\n            return this._shown;\n        };\n\n        proto.$shape = function(shape) {\n            if (shape && SHAPES[shape]) {\n                this._shape = shape;\n                return this.addUpdate(undefined, this._shown, {shape : shape});\n            }\n\n            return this._shape;\n        };\n        proto.$shape.minArgs     = 0;\n        proto.$shape.keywordArgs = [\"name\"];\n\n        proto.$window_width = function() {\n            return this._screen.$window_width();\n        };\n        \n        proto.$window_height = function() {\n            return this._screen.$window_height();\n        };\n        \n        proto.$tracer = function(n, delay) {\n            return this._screen.$tracer(n, delay);\n        };\n        proto.$tracer.minArgs     = 0;\n        proto.$tracer.keywordArgs = [\"n\", \"delay\"];\n        \n        proto.$update = function() {\n            return this._screen.$update();\n        };\n        \n        proto.$delay = function(delay) {\n            return this._screen.$delay(delay);\n        };\n        proto.$delay.minArgs     = 0;\n        proto.$delay.keywordArgs = [\"delay\"];\n\n        proto.$reset = function() {\n            this.reset();\n            return this.$clear();\n        };\n\n        proto.$mainloop = proto.$done = function() {\n            return this._screen.$mainloop();\n        };\n\n        proto.$clear = function() {\n            return this.addUpdate(function() {\n                clearLayer(this.context());\n            }, true);\n        };\n        proto.$dot.minArgs = 0;\n\n        proto.$onclick = function(method,btn,add) {\n            this.getManager(\"mousedown\").addHandler(method, add);\n        };\n        proto.$onclick.minArgs = 1;\n        proto.$onclick.keywordArgs = [\"btn\",\"add\"];\n\n        proto.$onrelease = function(method,btn,add) {\n            this.getManager(\"mouseup\").addHandler(method, add);\n        };\n        proto.$onrelease.minArgs = 1;\n        proto.$onrelease.keywordArgs = [\"btn\",\"add\"];\n\n        proto.$ondrag = function(method,btn,add) {\n            this.getManager(\"mousemove\").addHandler(method, add);\n        };\n        proto.$ondrag.minArgs = 1;\n        proto.$ondrag.keywordArgs = [\"btn\",\"add\"];\n\n        proto.$getscreen = function() {\n            return _module.Screen();\n        };\n        proto.$getscreen.isSk = true;\n\n        proto.$clone = function() {\n\n            var newTurtleInstance = Sk.misceval.callsimOrSuspend(_module.Turtle);\n\n            // All the properties that are in getState()\n            newTurtleInstance.instance._x = this._x;\n            newTurtleInstance.instance._y = this._y;\n            newTurtleInstance.instance._angle = this._angle;\n            newTurtleInstance.instance._radians = this._radians;\n            newTurtleInstance.instance._shape = this._shape;\n            newTurtleInstance.instance._color = this._color;\n            newTurtleInstance.instance._fill = this._fill;\n            newTurtleInstance.instance._filling = this._filling;\n            newTurtleInstance.instance._size = this._size;\n            newTurtleInstance.instance._computed_speed = this._computed_speed;\n            newTurtleInstance.instance._down = this._down;\n            newTurtleInstance.instance._shown = this._shown;\n\n            // Other properties to copy\n            newTurtleInstance.instance._isRadians = this._isRadians;\n            newTurtleInstance.instance._fullCircle = this._fullCircle;\n            newTurtleInstance.instance._bufferSize = this._bufferSize;\n            newTurtleInstance.instance._undoBuffer = this._undoBuffer;\n\n\n            newTurtleInstance._clonedFrom = this;\n\n            return newTurtleInstance;\n        };\n        proto.$clone.returnType = function(value) {\n            // When I return the instance here, I'm not sure if it ends up with the right \"Turtle\" python type.\n            return value\n        };\n\n        proto.$getturtle = proto.$getpen = function() {\n            return this.skInstance;\n        };\n        proto.$getturtle.isSk = true;\n    })(Turtle.prototype);\n\n    function Screen() {\n        var w,h;\n        this._frames    = 1;\n        this._delay     = undefined;\n        this._bgcolor   = \"none\";\n        this._mode      = \"standard\";\n        this._managers  = {};\n        this._keyLogger = {};\n        if (_config.height && _config.width) {\n            w = _config.width/2;\n            h = _config.height/2;\n        } else {\n            w = _config.defaultSetup.width/2;\n            h = _config.defaultSetup.height/2;\n        }\n        this.setUpWorld(-w,-h,w,h);\n    }\n\n    (function(proto) {\n        proto.spriteLayer = function() {\n            return this._sprites || (this._sprites = createLayer(3));\n        };\n\n        proto.bgLayer = function() {\n            return this._background || (this._background = createLayer(1));\n        };\n\n        proto.hitTestLayer = function() {\n            return this._hitTest || (this._hitTest = createLayer(0,true));\n        };\n\n        proto.getManager = function(type) {\n            if (!this._managers[type]) {\n                this._managers[type] = new EventManager(type, this);\n            }\n            return this._managers[type];\n        };\n\n        proto.reset = function() {\n            var key;\n\n            this._keyListeners = undefined;\n\n            for (key in this._keyLogger) {\n                window.clearInterval(this._keyLogger[key]);\n                window.clearTimeout(this._keyLogger[key]);\n                delete this._keyLogger[key];\n            }\n\n            if (this._keyDownListener) {\n                getTarget().removeEventListener(\"keydown\", this._keyDownListener);\n                this._keyDownListener = undefined;\n            }\n\n            if (this._keyUpListener) {\n                getTarget().removeEventListener(\"keyup\", this._keyUpListener);\n                this._keyUpListener = undefined;\n            }\n\n            if (this._timer) {\n                window.clearTimeout(this._timer);\n                this._timer = undefined;\n            }\n\n            for(key in this._managers) {\n                this._managers[key].reset();\n            }\n\n            this._mode = \"standard\";\n            removeLayer(this._sprites);\n            this._sprites = undefined;\n            removeLayer(this._background);\n            this._background = undefined;\n        };\n\n        proto.setUpWorld = function(llx, lly, urx, ury) {\n            var world = this;\n\n            world.llx       = llx;\n            world.lly       = lly;\n            world.urx       = urx;\n            world.ury       = ury;\n            world.xScale    = (urx - llx) / getWidth();\n            world.yScale    = -1 * (ury - lly) / getHeight();\n            world.lineScale = Math.min(Math.abs(world.xScale), Math.abs(world.yScale));\n        };\n\n        proto.$setup = function(width, height, startX, startY) {\n            if (isNaN(parseFloat(width))) {\n                width = getWidth();\n            }\n            if (isNaN(parseFloat(height))) {\n                height = getHeight();\n            }\n\n            if (width <= 1) {\n                width = getWidth() * width;\n            }\n            if (height <= 1) {\n                height = getHeight() * height;\n            }\n\n            this._width  = width;\n            this._height = height;\n\n            this._xOffset = (startX !== undefined && !isNaN(parseInt(startX))) ?\n                parseInt(startX) :\n                0;\n\n            this._yOffset = (startY !== undefined && !isNaN(parseInt(startY))) ?\n                parseInt(startY) :\n                0;\n\n            if (this._mode === \"world\") {\n                return this._setworldcoordinates(this.llx, this.lly, this.urx, this.ury);\n            }\n\n            return this._setworldcoordinates(-width/2, -height/2, width/2, height/2);\n        };\n        proto.$setup.minArgs     = 0;\n        proto.$setup.keywordArgs = [\"width\", \"height\", \"startx\", \"starty\"];\n\n        proto.$register_shape = proto.$addshape = function(name, points) {\n            SHAPES[name] = points;\n        };\n\n        proto.$getshapes = function() {\n            return Object.keys(SHAPES);\n        };\n\n        proto.$tracer = function(frames, delay) {\n            if (frames !== undefined || delay !== undefined) {\n                if (typeof delay === \"number\") {\n                    this._delay = delay;\n                    getFrameManager().refreshInterval(delay);\n                }\n                if (typeof frames === \"number\") {\n                    this._frames = frames;\n                    return getFrameManager().frameBuffer(frames);\n                }\n\n                return;\n            }\n\n            return this._frames;\n        };\n        proto.$tracer.minArgs = 0;\n\n        proto.$delay = function(delay) {\n            if (delay !== undefined) {\n                return this.$tracer(undefined, delay);\n            }\n\n            return this._delay === undefined ? OPTIMAL_FRAME_RATE : this._delay;\n        };\n\n        proto._setworldcoordinates = function(llx, lly, urx, ury) {\n            var world     = this,\n                turtles = getFrameManager().turtles();\n\n            this.setUpWorld(llx, lly, urx, ury);\n\n            if (this._sprites) {\n                applyWorld(this, this._sprites);\n            }\n\n            if (this._background) {\n                applyWorld(this, this._background);\n            }\n\n            return this.$clear();\n        };\n\n        proto.$setworldcoordinates = function(llx, lly, urx, ury) {\n            this._mode = \"world\";\n            return this._setworldcoordinates(llx, lly, urx, ury);\n        };\n\n        proto.$clear = proto.$clearscreen = function() {\n            this.reset();\n            return this.$reset();\n        };\n\n        proto.$update = function() {\n            return getFrameManager().update();\n        };\n\n        proto.$reset = proto.$resetscreen = function() {\n            var self = this,\n                turtles = getFrameManager().turtles();\n\n            return getFrameManager().addFrame(function() {\n                applyWorld(self, self._sprites);\n                applyWorld(self, self._background);\n                for(var i = 0; i < turtles.length; i++) {\n                    turtles[i].reset();\n                    applyWorld(self, turtles[i]._paper);\n                }\n            }, true);\n        };\n\n        proto.$window_width = function() {\n            return getWidth();\n        };\n\n        proto.$window_height = function() {\n            return getHeight();\n        };\n        proto.$delay.minArgs = 0;\n\n        proto.$turtles = function() {\n            return getFrameManager().turtles();\n        };\n        proto.$turtles.returnType = Types.TURTLE_LIST;\n\n        proto.$bgcolor = function(color, g, b, a) {\n            if (arguments.length) {\n                this._bgcolor = createColor(color, g, b, a);\n                clearLayer(this.bgLayer(), this._bgcolor);\n                return;\n            }\n\n            return hexToRGB(this._bgcolor);\n        };\n        proto.$bgcolor.minArgs = 0;\n        proto.$bgcolor.returnType = Types.COLOR;\n\n        // no-op - just defined for consistency with python version\n        proto.$mainloop = proto.$done = function() {\n            return undefined;\n        };\n\n        proto.$bye = function() {\n            return Sk.TurtleGraphics.reset();\n        };\n\n        proto.$exitonclick = function() {\n            this._exitOnClick = true;\n            return this.getManager(\"mousedown\").addHandler(function() {\n                resetTurtle();\n            }, false);\n        };\n\n        proto.$onclick = function(method,btn,add) {\n            if (this._exitOnClick) return;\n            this.getManager(\"mousedown\").addHandler(method, add);\n        };\n        proto.$onclick.minArgs = 1;\n        proto.$onclick.keywordArgs = [\"btn\",\"add\"];\n\n        var KEY_MAP = {\n            \"8\"  : /^back(space)?$/i,\n            \"9\"  : /^tab$/i,\n            \"13\" : /^(enter|return)$/i,\n            \"16\" : /^shift$/i,\n            \"17\" : /^(ctrl|control)$/i,\n            \"18\" : /^alt$/i,\n            \"27\" : /^esc(ape)?$/i,\n            \"32\" : /^space$/i,\n            \"33\" : /^page[\\s\\-]?up$/i,\n            \"34\" : /^page[\\s\\-]?down$/i,\n            \"35\" : /^end$/i,\n            \"36\" : /^home$/i,\n            \"37\" : /^left([\\s\\-]?arrow)?$/i,\n            \"38\" : /^up([\\s\\-]?arrow)?$/i,\n            \"39\" : /^right([\\s\\-]?arrow)?$/i,\n            \"40\" : /^down([\\s\\-]?arrow)?$/i,\n            \"45\" : /^insert$/i,\n            \"46\" : /^del(ete)?$/i\n        };\n\n        proto._createKeyRepeater = function(key, code) {\n            var self = this;\n            // set a timeout for 333ms and if key has not yet been\n            // released, fire another event and continue firing\n            // at a rate of ~20 times per second until key is released\n            self._keyLogger[code] = window.setTimeout(function() {\n                // trigger the first repeat after the longer delay\n                self._keyListeners[key]();\n                // set up the repeat interval with the quick delay\n                self._keyLogger[code] = window.setInterval(function() {\n                    self._keyListeners[key]();\n                }, 50);\n            }, 333);\n        };\n\n        proto._createKeyDownListener = function() {\n            var self = this;\n\n            if (this._keyDownListener) return;\n\n            this._keyDownListener = function(e) {\n                if (!focusTurtle()) return;\n\n                var code    = e.charCode || e.keyCode,\n                    pressed = String.fromCharCode(code).toLowerCase(),\n                    key, inKeyMap;\n\n                if (self._keyLogger[code]) return;\n\n                for (key in self._keyListeners) {\n                    inKeyMap = (key.length > 1 && KEY_MAP[code] && KEY_MAP[code].test(key));\n                    if (key === pressed || inKeyMap) {\n                        // trigger the intial keydown handler\n                        self._keyListeners[key]();\n                        self._createKeyRepeater(key, code);\n                        e.preventDefault();\n                        break;\n                    }\n                }\n            };\n\n            getTarget().addEventListener(\"keydown\", this._keyDownListener);\n        };\n\n        proto._createKeyUpListener = function() {\n            var self = this;\n\n            if (this._keyUpListener) return;\n\n            this._keyUpListener = function(e) {\n                var interval = self._keyLogger[e.charCode || e.keyCode];\n                if (interval !== undefined) {\n                    e.preventDefault();\n                    window.clearInterval(interval);\n                    window.clearTimeout(interval);\n                    delete(self._keyLogger[e.charCode || e.keyCode]);\n                }\n            };\n            \n            getTarget().addEventListener(\"keyup\", this._keyUpListener);\n        };\n\n        proto.$listen = function() {\n            this._createKeyUpListener();\n            this._createKeyDownListener();\n        };\n\n        proto.$onkey = function(method, keyValue) {\n            if (typeof keyValue === \"function\") {\n                var temp = method;\n                method   = keyValue;\n                keyValue = temp;\n            }\n\n            keyValue = String(keyValue).toLowerCase();\n\n            if (method && typeof method === \"function\") {\n                if (!this._keyListeners) this._keyListeners = {};\n                this._keyListeners[keyValue] = method;\n            }\n            else {\n                delete this._keyListeners[keyValue];\n            }\n        };\n\n        proto.$onscreenclick = function(method,btn,add) {\n            this.getManager(\"mousedown\").addHandler(method, add);\n        };\n        proto.$onscreenclick.minArgs = 1;\n        proto.$onscreenclick.keywordArgs = [\"btn\",\"add\"];\n\n        proto.$ontimer = function(method, interval) {\n            if (this._timer) {\n                window.clearTimeout(this._timer);\n                this._timer = undefined;\n            }\n\n            if (method && typeof interval === \"number\") {\n                this._timer = window.setTimeout(method, Math.max(0, interval|0));\n            }\n        };\n        proto.$ontimer.minArgs = 0;\n\n    })(Screen.prototype);\n\n    function ensureAnonymous() {\n        if (!_anonymousTurtle) {\n            _anonymousTurtle = Sk.misceval.callsim(_module.Turtle);\n        }\n\n        return _anonymousTurtle.instance;\n    }\n\n    function getTarget() {\n        return _target;\n    }\n\n    function getScreen() {\n        if (!_screenInstance) {\n            _screenInstance = new Screen();\n        }\n        return _screenInstance;\n    }\n\n    function getMouseHandler() {\n        if (!_mouseHandler) {\n            _mouseHandler = new MouseHandler();\n        }\n        return _mouseHandler;\n    }\n\n    function getWidth() {\n        return (\n            (_screenInstance && _screenInstance._width) ||\n            _config.width ||\n            getTarget().clientWidth\n        ) | 0;\n    }\n\n    function getHeight() {\n        return (\n            (_screenInstance && _screenInstance._height) ||\n            _config.height ||\n            getTarget().clientHeight\n        ) | 0;\n    }\n\n    function createLayer(zIndex, isHidden) {\n        var canvas = document.createElement(\"canvas\"),\n            width  = getWidth(),\n            height = getHeight(),\n            offset = getTarget().firstChild ? (-height) + \"px\" : \"0\",\n            context;\n\n        canvas.width          = width;\n        canvas.height         = height;\n        canvas.style.position = \"relative\";\n        canvas.style.display  = \"block\";\n        canvas.style.setProperty(\"margin-top\",offset);\n        canvas.style.setProperty(\"z-index\", zIndex);\n        if (isHidden) {\n            canvas.style.display = \"none\";\n        }\n\n        getTarget().appendChild(canvas);\n\n        context = canvas.getContext(\"2d\");\n        context.lineCap = \"round\";\n        context.lineJoin = \"round\";\n\n        applyWorld(getScreen(), context);\n\n        return context;\n    }\n\n    function cancelAnimationFrame() {\n        if (_frameRequest) {\n            (window.cancelAnimationFrame || window.mozCancelAnimationFrame)(_frameRequest);\n            _frameRequest = undefined;\n        }\n        if (_frameRequestTimeout) {\n            window.clearTimeout(_frameRequestTimeout);\n            _frameRequestTimeout = undefined;\n        }\n    }\n\n    function applyWorld(world, context) {\n        var llx    = world.llx,\n            lly    = world.lly,\n            urx    = world.urx,\n            ury    = world.ury,\n            xScale = world.xScale,\n            yScale = world.yScale;\n\n        if (!context) return;\n\n        clearLayer(context);\n\n        context.restore();\n        context.save();\n        context.scale(1 / xScale, 1 / yScale);\n        if (lly === 0) {\n            context.translate(-llx, lly - (ury - lly));\n        } else if (lly > 0) {\n            context.translate(-llx, -lly * 2);\n        } else {\n            context.translate(-llx, -ury);\n        }\n    }\n\n    function pushUndo(turtle) {\n        var properties, undoState, i;\n\n        if (!_config.allowUndo || !turtle._bufferSize) {\n            return;\n        }\n\n        if (!turtle._undoBuffer) {\n            turtle._undoBuffer = [];\n        }\n\n        while(turtle._undoBuffer.length > turtle._bufferSize) {\n            turtle._undoBuffer.shift();\n        }\n\n        undoState  = {};\n        properties = \"x y angle radians color fill down filling shown shape size\".split(\" \");\n        for(i = 0; i < properties.length; i++) {\n            undoState[properties[i]] = turtle[\"_\" + properties[i]];\n        }\n\n        turtle._undoBuffer.push(undoState);\n\n        return turtle.addUpdate(function() {\n            undoState.fillBuffer = this.fillBuffer ? this.fillBuffer.slice() : undefined;\n            if (turtle._paper && turtle._paper.canvas) {\n                undoState.image = turtle._paper.canvas.toDataURL();\n            }\n        }, false);\n    }\n\n    var undoImage = new Image();\n    function popUndo(turtle) {\n        var undoState;\n\n        if (!turtle._bufferSize || !turtle._undoBuffer) {\n            return;\n        }\n\n        undoState = turtle._undoBuffer.pop();\n\n        if (!undoState) {\n            return;\n        }\n\n        for(var key in undoState) {\n            if (key === \"image\" || key === \"fillBuffer\") continue;\n            turtle[\"_\" + key] = undoState[key];\n        }\n\n        return turtle.addUpdate(function() {\n            var img;\n            if (undoState.image) {\n                undoImage.src = undoState.image;\n                img = undoImage;\n            }\n\n            clearLayer(this.context(), false, undoImage);\n            delete undoState.image;\n        }, true, undoState);\n    }\n\n    function removeLayer(layer) {\n        if (layer && layer.canvas && layer.canvas.parentNode) {\n            layer.canvas.parentNode.removeChild(layer.canvas);\n        }\n    }\n\n    function clearLayer(context, color, image) {\n        if (!context) return;\n\n        context.save();\n        context.setTransform(1,0,0,1,0,0);\n        if (color) {\n            context.fillStyle = color;\n            context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n        }\n        else {\n            context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n        }\n\n        if (image) {\n            context.drawImage(image, 0, 0);\n        }\n\n        context.restore();\n    }\n\n    function drawTurtle(state, context) {\n        var shape  = SHAPES[state.shape],\n            world  = getScreen(),\n            width  = getWidth(),\n            height = getHeight(),\n            xScale = world.xScale,\n            yScale = world.yScale,\n            x, y, bearing;\n\n        if (!context) return;\n\n        x       = Math.cos(state.radians) / xScale;\n        y       = Math.sin(state.radians) / yScale;\n        bearing = Math.atan2(y, x) - Math.PI/2;\n\n        context.save();\n        context.translate(state.x, state.y);\n        context.scale(xScale,yScale);\n        context.rotate(bearing);\n        context.beginPath();\n        context.lineWidth   = 1;\n        context.strokeStyle = state.color;\n        context.fillStyle   = state.fill;\n        context.moveTo(shape[0][0], shape[0][1]);\n        for(var i = 1; i < shape.length; i++) {\n            context.lineTo(shape[i][0], shape[i][1]);\n        }\n        context.closePath();\n        context.fill();\n        context.stroke();\n        context.restore();\n    }\n\n    function drawDot(size, color) {\n        var context = this.context(),\n            screen  = getScreen(),\n            xScale  = screen.xScale,\n            yScale  = screen.yScale;\n\n        if (!context) return;\n        context.beginPath();\n        context.moveTo(this.x, this.y);\n        size = size * Math.min(Math.abs(xScale),Math.abs(yScale));\n        context.arc(this.x, this.y, size, 0, Turtle.RADIANS);\n        context.closePath();\n        context.fillStyle = color || this.color;\n        context.fill();\n    }\n\n    var textMeasuringContext = document.createElement(\"canvas\").getContext(\"2d\");\n    function measureText(message, font) {\n        if (font) {\n            textMeasuringContext.font = font;\n        }\n        return textMeasuringContext.measureText(message).width;\n    }\n\n    function drawText(message, align, font) {\n        var context = this.context();\n\n        if (!context) return;\n\n        context.save();\n        if (font) {\n            context.font = font;\n        }\n        if (align && align.match(/^(left|right|center)$/)) {\n            context.textAlign = align;\n        }\n\n        context.scale(1,-1);\n        context.fillStyle = this.fill;\n        context.fillText(message, this.x, -this.y);\n        context.restore();\n    }\n\n    function drawLine(loc, beginPath, endPath) {\n        // TODO: make steps in path use square ends of lines\n        // and open and close path at the right times.\n        // See if we can minimize calls to stroke\n        var context = this.context();\n\n        if (!context) return;\n\n        if (beginPath) {\n            context.beginPath();\n            context.moveTo(this.x, this.y);\n        }\n\n        context.lineWidth   = this.size * getScreen().lineScale;\n        context.strokeStyle = this.color;\n        context.lineTo(loc.x, loc.y);\n        context.stroke();\n    }\n\n    function drawFill() {\n        var context = this.context(),\n            path  = this.fillBuffer,\n            i;\n\n        if (!context || !path || !path.length) return;\n\n        context.save();\n        context.beginPath();\n        context.moveTo(path[0].x,path[0].y);\n        for(i = 1; i < path.length; i++) {\n            context.lineTo(path[i].x, path[i].y);\n        }\n        context.closePath();\n        context.fillStyle = this.fill;\n        context.fill();\n        for(i = 1; i < path.length; i++) {\n            if (!path[i].stroke) {\n                continue;\n            }\n\n            context.beginPath();\n            context.moveTo(path[i-1].x, path[i-1].y);\n            context.lineWidth   = path[i].size * getScreen().lineScale;\n            context.strokeStyle = path[i].color;\n            context.lineTo(path[i].x, path[i].y);\n            context.stroke();\n        }\n        context.restore();\n    }\n\n    function partialTranslate(turtle, x, y, beginPath, countAsFrame) {\n        return function() {\n            return turtle.addUpdate(\n                function(loc) {\n                    if (this.down) {\n                        drawLine.call(this, loc, beginPath);\n                    }\n                },\n                countAsFrame,\n                {x : x, y : y},\n                beginPath\n            );\n        };\n    }\n\n    function translate(turtle, startX, startY, dx, dy, beginPath, isCircle) {\n        // speed is in pixels per ms\n        var speed   = turtle._computed_speed,\n            screen  = getScreen(),\n            xScale  = Math.abs(screen.xScale),\n            yScale  = Math.abs(screen.yScale),\n            x       = startX,\n            y       = startY,\n            pixels  = Math.sqrt(dx * dx * xScale + dy * dy * yScale),\n            // TODO: allow fractional frame updates?\n            frames  = speed ? Math.round(Math.max(1, pixels / speed)) : 1,\n            xStep   = dx / frames,\n            yStep   = dy / frames,\n            promise = getFrameManager().willRenderNext() ?\n                Promise.resolve() :\n                new InstantPromise(),\n            countAsFrame = (!speed && isCircle) ? false : true,\n            i;\n\n        turtle.addUpdate(function() {\n            if (this.filling) {\n                this.fillBuffer.push({\n                    x        : this.x,\n                    y      : this.y,\n                    stroke : this.down,\n                    color  : this.color,\n                    size   : this.size\n                });\n            }\n        }, false);\n\n        for(i = 0; i < frames; i++) {\n            x = startX + xStep * (i+1);\n            y = startY + yStep * (i+1);\n            promise = promise.then(\n                partialTranslate(turtle, x, y, beginPath, countAsFrame)\n            );\n            beginPath = false;\n        }\n\n        return promise.then(function() {\n            return [startX + dx, startY + dy];\n        });\n    }\n\n    function partialRotate(turtle, angle, radians, countAsFrame) {\n        return function() {\n            return turtle.addUpdate(undefined, countAsFrame, {angle:angle, radians:radians});\n        };\n    }\n\n    function rotate(turtle, startAngle, delta, isCircle) {\n        var speed        = turtle._computed_speed,\n            degrees    = delta / turtle._fullCircle * 360,\n            frames     = speed ? Math.round(Math.max(1, Math.abs(degrees) / speed)) : 1,\n            dAngle     = delta / frames,\n            heading    = {},\n            countAsFrame = (!speed && isCircle) ? false : true,\n            promise    = getFrameManager().willRenderNext() ?\n                Promise.resolve() :\n                new InstantPromise(),\n            i;\n\n        // TODO: request how many frames are remaining and only queue up\n        // a single rotation per screen update\n\n        for(i = 0; i < frames; i++) {\n            calculateHeading(turtle, startAngle + dAngle * (i+1), heading);\n            promise = promise.then(\n                partialRotate(turtle, heading.angle, heading.radians, countAsFrame)\n            );\n        }\n\n        return promise.then(function() {\n            return calculateHeading(turtle, startAngle + delta);\n        });\n    }\n\n    function getCoordinates(x, y) {\n        if (y === undefined) {\n            y = (x && (x.y || x._y || x[1])) || 0;\n            x = (x && (x.x || x._x || x[0])) || 0;\n        }\n        return {x:x, y:y};\n    }\n\n    // Modified solution of Tim Down's version from stackoverflow\n    // http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n    function hexToRGB(hex) {\n        var rgbForm, hexForm, result;\n\n        if (rgbForm = /^rgba?\\((\\d+),(\\d+),(\\d+)(?:,([.\\d]+))?\\)$/.exec(hex)) {\n            result = [\n                parseInt(rgbForm[1]),\n                parseInt(rgbForm[2]),\n                parseInt(rgbForm[3])\n            ];\n            if (rgbForm[4]) {\n                result.push(parseFloat(rgbForm[4]));\n            }\n        }\n        else if (/^#?[a-f\\d]{3}|[a-f\\d]{6}$/i.exec(hex)) {\n            if (hex.length === 4) {\n                // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n                hex = hex.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i, function(m, r, g, b) {\n                        return r + r + g + g + b + b;\n                });\n            }\n\n            hexForm = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n            result = [\n                parseInt(hexForm[1], 16),\n                parseInt(hexForm[2], 16),\n                parseInt(hexForm[3], 16)\n            ];\n        }\n        else {\n            result = hex;\n        }\n\n        return result;\n    }\n\n    function createColor(color, g, b, a) {\n        var i;\n\n        if (g !== undefined) {\n            color = [color, g, b, a];\n        }\n\n        if (color.constructor === Array && color.length) {\n            for(i = 0; i < 3; i++) {\n                color[i] = (typeof color[i] === \"number\") ?\n                    Math.max(0, Math.min(255, parseInt(color[i]))) :\n                    0;\n            }\n            if (typeof color[i] === \"number\") {\n                color[3] = Math.max(0, Math.min(1, color[i]));\n                color = \"rgba(\" + color.join(\",\") + \")\";\n            }\n            else {\n                color = \"rgb(\" + color.slice(0,3).join(\",\") + \")\";\n            }\n        }\n        else if (typeof color === \"string\" && !color.match(/\\s*url\\s*\\(/i)) {\n            color = color.replace(/\\s+/g, \"\");\n        }\n        else {\n            return \"black\";\n        }\n\n        return color;\n    }\n\n    function calculateHeading(turtle, value, heading) {\n        var angle   = turtle._angle   || 0,\n            radians = turtle._radians || 0;\n\n        heading || (heading = {});\n\n        if (typeof value === \"number\") {\n            if (turtle._isRadians) {\n                angle = radians = value % Turtle.RADIANS;\n            }\n            else if (turtle._fullCircle) {\n                angle   = (value % turtle._fullCircle);\n                radians = angle / turtle._fullCircle * Turtle.RADIANS;\n            }\n            else {\n                angle = radians = 0;\n            }\n\n            if (angle < 0) {\n                angle   += turtle._fullCircle;\n                radians += Turtle.RADIANS;\n            }\n        }\n\n        heading.angle   = angle;\n        heading.radians = radians;\n\n        return heading;\n    }\n\n    function pythonToJavascriptFunction(pyValue, scope) {\n        return function() {\n            var argsJs = Array.prototype.slice.call(arguments),\n                argsPy = argsJs.map(\n                    function(argJs) {return Sk.ffi.remapToPy(argJs);}\n                );\n\n            if (typeof(scope) !== \"undefined\") {\n                argsPy.unshift(scope);\n            }\n            return Sk.misceval.applyAsync(\n                undefined, pyValue, undefined, undefined, undefined, argsPy\n            ).catch(Sk.uncaughtException);\n        };\n    }\n\n    function addModuleMethod(klass, module, method, scopeGenerator) {\n        var publicMethodName = method.replace(/^\\$/, \"\"),\n            displayName      = publicMethodName.replace(/_\\$[a-z]+\\$$/i, \"\"),\n            maxArgs          = klass.prototype[method].length,\n            minArgs          = klass.prototype[method].minArgs,\n            keywordArgs      = klass.prototype[method].keywordArgs,\n            returnType       = klass.prototype[method].returnType,\n            isSk             = klass.prototype[method].isSk,\n            wrapperFn;\n\n        if (minArgs === undefined) {\n            minArgs = maxArgs;\n        }\n\n        wrapperFn = function() {\n            var args     = Array.prototype.slice.call(arguments, 0),\n                instance = scopeGenerator ? scopeGenerator() : args.shift().instance,\n                i, result, susp, resolution, lengthError;\n\n            if (args.length < minArgs || args.length > maxArgs) {\n                lengthError = minArgs === maxArgs ?\n                    \"exactly \" + maxArgs :\n                    \"between \" + minArgs + \" and \" + maxArgs;\n\n                throw new Sk.builtin.TypeError(displayName + \"() takes \" + lengthError + \" positional argument(s) (\" + args.length + \" given)\");\n            }\n\n            for (i = args.length; --i >= 0;) {\n                if (args[i] !== undefined) {\n                    if (args[i] instanceof Sk.builtin.func) {\n                        args[i] = pythonToJavascriptFunction(args[i]);\n                    }\n                    else if (args[i] instanceof Sk.builtin.method) {\n                        args[i] = pythonToJavascriptFunction(args[i].im_func, args[i].im_self);\n                    }\n                    else if (args[i] && args[i].$d instanceof Sk.builtin.dict && args[i].instance) {\n                        args[i] = args[i].instance;\n                    }\n                    else {\n                        args[i] = Sk.ffi.remapToJs(args[i]);\n                    }\n                }\n            }\n\n            try {\n                result = instance[method].apply(instance, args);\n            } catch(e) {\n                if (window && window.console) {\n                    window.console.log(\"wrapped method failed\");\n                    window.console.log(e.stack);\n                }\n                throw e;\n            }\n\n            if (result instanceof InstantPromise) {\n                result = result.lastResult;\n            }\n\n            if (result instanceof Promise) {\n                result = result.catch(function(e) {\n                    if (window && window.console) {\n                        window.console.log(\"promise failed\");\n                        window.console.log(e.stack);\n                    }\n                    throw e;\n                });\n\n                susp = new Sk.misceval.Suspension();\n\n                susp.resume = function() {\n                    return (resolution === undefined) ?\n                        Sk.builtin.none.none$ :\n                        Sk.ffi.remapToPy(resolution);\n                };\n\n                susp.data = {\n                    type: \"Sk.promise\",\n                    promise: result.then(function(value) {\n                        resolution = value;\n                        return value;\n                    })\n                };\n\n                return susp;\n            }\n            else {\n                if (result === undefined) return Sk.builtin.none.none$;\n                if (isSk) return result;\n                if (typeof returnType === \"function\") {\n                    return returnType(result);\n                }\n\n                return Sk.ffi.remapToPy(result);\n            }\n        };\n\n        if (keywordArgs) {\n            wrapperFn.co_varnames = keywordArgs.slice();\n            // make room for required arguments\n            for(var i = 0; i < minArgs; i++) {\n                wrapperFn.co_varnames.unshift(\"\");\n            }\n            if (!scopeGenerator) {\n                // make room for the \"self\" argument\n                wrapperFn.co_varnames.unshift(\"\");\n            }\n        }\n\n        module[publicMethodName] = new Sk.builtin.func(wrapperFn);\n    }\n\n    function TurtleWrapper($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self) {\n            self.instance = new Turtle();\n            self.instance.skInstance = self;\n        });\n\n        for(var key in Turtle.prototype) {\n            if (/^\\$[a-z_]+/.test(key)) {\n                addModuleMethod(Turtle, $loc, key);\n            }\n        }\n    }\n\n    function ScreenWrapper($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self) {\n            self.instance = getScreen();\n        });\n\n        for(var key in Screen.prototype) {\n            if (/^\\$[a-z_]+/.test(key)) {\n                addModuleMethod(Screen, $loc, key);\n            }\n        }\n    }\n\n    for(var key in Turtle.prototype) {\n        if (/^\\$[a-z_]+/.test(key)) {\n            addModuleMethod(Turtle, _module, key, ensureAnonymous);\n        }\n    }\n\n    // add Screen method aliases to the main turtle module\n    // to allow things like:\n    //   import turtle\n    //   turtle.mainloop()\n    addModuleMethod(Screen, _module, \"$mainloop\", getScreen);\n    addModuleMethod(Screen, _module, \"$done\", getScreen);\n    addModuleMethod(Screen, _module, \"$bye\", getScreen);\n    addModuleMethod(Screen, _module, \"$tracer\", getScreen);\n    addModuleMethod(Screen, _module, \"$update\", getScreen);\n    addModuleMethod(Screen, _module, \"$delay\", getScreen);\n    addModuleMethod(Screen, _module, \"$window_width\", getScreen);\n    addModuleMethod(Screen, _module, \"$window_height\", getScreen);\n\n    _module.Turtle = Sk.misceval.buildClass(_module, TurtleWrapper, \"Turtle\", []);\n    _module.Screen = Sk.misceval.buildClass(_module, ScreenWrapper, \"Screen\", []);\n\n    // Calling focus(false) will block turtle key/mouse events\n    // until focus(true) is called again or until the turtle DOM target\n    // is clicked/tabbed into.\n    function focusTurtle(value) {\n        if (value !== undefined) {\n            _focus = !!value;\n            if (_focus) {\n                getTarget().focus();\n            }\n            else {\n                getTarget().blur();\n            }\n        }\n\n        return _focus;\n    }\n\n    function resetTurtle() {\n        cancelAnimationFrame();\n        getScreen().reset();\n        getFrameManager().reset();\n\n        while (_target.firstChild) {\n            _target.removeChild(_target.firstChild);\n        }\n\n        if (_mouseHandler) {\n            _mouseHandler.reset();\n        }\n\n        _durationSinceRedraw = 0;\n        _screenInstance      = undefined;\n        _anonymousTurtle     = undefined;\n        _mouseHandler        = undefined;\n        TURTLE_COUNT         = 0;\n    }\n\n    function stopTurtle() {\n        cancelAnimationFrame();\n\n        if (_mouseHandler) {\n            _mouseHandler.reset();\n        }\n\n        _durationSinceRedraw = 0;\n        _screenInstance      = undefined;\n        _anonymousTurtle     = undefined;\n        _mouseHandler        = undefined;\n        TURTLE_COUNT         = 0;\n    }\n\n    return {\n        skModule : _module,\n        reset    : resetTurtle,\n        stop     : stopTurtle,\n        focus    : focusTurtle,\n        Turtle   : Turtle,\n        Screen   : Screen\n    };\n}\n\n// See if the TurtleGraphics module has already been loaded\n// for the currently configured DOM target element.\nvar currentTarget = getConfiguredTarget();\n\nif (!currentTarget.turtleInstance) {\n    currentTarget.turtleInstance = generateTurtleModule(currentTarget);\n}\nelse {\n    currentTarget.turtleInstance.reset();\n}\n\nSk.TurtleGraphics.module = currentTarget.turtleInstance.skModule;\nSk.TurtleGraphics.reset  = currentTarget.turtleInstance.reset;\nSk.TurtleGraphics.stop   = currentTarget.turtleInstance.stop;\nSk.TurtleGraphics.focus  = currentTarget.turtleInstance.focus;\nSk.TurtleGraphics.raw = {\n    Turtle : currentTarget.turtleInstance.Turtle,\n    Screen : currentTarget.turtleInstance.Screen\n};\n\nreturn currentTarget.turtleInstance.skModule;\n\n};\n", "src/lib/sets.py": "raise NotImplementedError(\"sets is not yet implemented in Skulpt\")\n", "src/lib/socket.py": "raise NotImplementedError(\"socket is not yet implemented in Skulpt\")\n", "src/lib/ihooks.py": "raise NotImplementedError(\"ihooks is not yet implemented in Skulpt\")\n", "src/lib/platform.js": "var $builtinmodule = function(name){\n    var mod = {};\n    var inBrowser = (typeof window != \"undefined\") && (typeof window.navigator != \"undefined\");\n\n    mod.python_implementation = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"python_implementation\", arguments, 0, 0);\n        return new Sk.builtin.str(\"Skulpt\");\n    });\n\n    mod.node = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"node\", arguments, 0, 0);\n        return new Sk.builtin.str(\"\");\n    });\n\n    mod.version = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"version\", arguments, 0, 0);\n        return new Sk.builtin.str(\"\");\n    });\n\n    mod.python_version = new Sk.builtin.func(function() {\n        var vers;\n        Sk.builtin.pyCheckArgs(\"python_version\", arguments, 0, 0);\n        if (Sk.python3) {\n            vers = \"3.2.0\";\n        }\n        else {\n            vers = \"2.7.0\";\n        }\n        return new Sk.builtin.str(vers);\n    });\n\n    mod.system = new Sk.builtin.func(function() {\n        var sys;\n        Sk.builtin.pyCheckArgs(\"system\", arguments, 0, 0);\n        if (inBrowser) {\n            sys = window.navigator.appCodeName;\n        }\n        else {\n            sys = \"\";\n        }\n        return new Sk.builtin.str(sys);\n    });\n\n    mod.machine = new Sk.builtin.func(function() {\n        var plat;\n        Sk.builtin.pyCheckArgs(\"machine\", arguments, 0, 0);\n        if (inBrowser) {\n            plat = window.navigator.platform;\n        }\n        else {\n            plat = \"\";\n        }\n        return new Sk.builtin.str(plat);\n    });\n\n    mod.release = new Sk.builtin.func(function() {\n        var appVers;\n        Sk.builtin.pyCheckArgs(\"release\", arguments, 0, 0);\n        if (inBrowser) {\n            appVers = window.navigator.appVersion;\n        }\n        else {\n            appVers = \"\";\n        }\n        return new Sk.builtin.str(appVers);\n    });\n\n    mod.architecture = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"architecture\", arguments, 0, 0);\n        return new Sk.builtin.tuple([new Sk.builtin.str(\"64bit\"),\n                                     new Sk.builtin.str(\"\")]);\n    });\n\n    mod.processor = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"processor\", arguments, 0, 0);\n        return new Sk.builtin.str(\"\");\n    });\n\n    return mod;\n};\n", "src/lib/datetime.py": "\"\"\"Concrete date/time and related types -- prototype implemented in Python.\n\nSee http://www.zope.org/Members/fdrake/DateTimeWiki/FrontPage\n\nSee also http://dir.yahoo.com/Reference/calendars/\n\nFor a primer on DST, including many current DST rules, see\nhttp://webexhibits.org/daylightsaving/\n\nFor more about DST than you ever wanted to know, see\nftp://elsie.nci.nih.gov/pub/\n\nSources for time zone and DST data: http://www.twinsun.com/tz/tz-link.htm\n\nThis was originally copied from the sandbox of the CPython CVS repository.\nThanks to Tim Peters for suggesting using it.\n\nThis was then copied from PyPy v5.1.0 into Skulpt by Meredydd Luff, removing\n'from __future__ import division' (and replacing division operators accordingly)\nand pickle support (which requires 'struct', which Skulpt does not currently\n[as of 31/8/2016] have)\n\"\"\"\n\nimport time as _time\nimport math as _math\n\n_SENTINEL = object()\n\ndef _cmp(x, y):\n    return 0 if x == y else 1 if x > y else -1\n\ndef _round(x):\n    return int(_math.floor(x + 0.5) if x >= 0.0 else _math.ceil(x - 0.5))\n\nMINYEAR = 1\nMAXYEAR = 9999\n_MINYEARFMT = 1900\n\n_MAX_DELTA_DAYS = 999999999\n\n# Utility functions, adapted from Python's Demo/classes/Dates.py, which\n# also assumes the current Gregorian calendar indefinitely extended in\n# both directions.  Difference:  Dates.py calls January 1 of year 0 day\n# number 1.  The code here calls January 1 of year 1 day number 1.  This is\n# to match the definition of the \"proleptic Gregorian\" calendar in Dershowitz\n# and Reingold's \"Calendrical Calculations\", where it's the base calendar\n# for all computations.  See the book for algorithms for converting between\n# proleptic Gregorian ordinals and many other calendar systems.\n\n_DAYS_IN_MONTH = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n_DAYS_BEFORE_MONTH = [-1]\ndbm = 0\nfor dim in _DAYS_IN_MONTH[1:]:\n    _DAYS_BEFORE_MONTH.append(dbm)\n    dbm += dim\ndel dbm, dim\n\ndef _is_leap(year):\n    \"year -> 1 if leap year, else 0.\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef _days_before_year(year):\n    \"year -> number of days before January 1st of year.\"\n    y = year - 1\n    return y*365 + y//4 - y//100 + y//400\n\ndef _days_in_month(year, month):\n    \"year, month -> number of days in that month in that year.\"\n    assert 1 <= month <= 12, month\n    if month == 2 and _is_leap(year):\n        return 29\n    return _DAYS_IN_MONTH[month]\n\ndef _days_before_month(year, month):\n    \"year, month -> number of days in year preceding first day of month.\"\n    assert 1 <= month <= 12, 'month must be in 1..12'\n    return _DAYS_BEFORE_MONTH[month] + (month > 2 and _is_leap(year))\n\ndef _ymd2ord(year, month, day):\n    \"year, month, day -> ordinal, considering 01-Jan-0001 as day 1.\"\n    assert 1 <= month <= 12, 'month must be in 1..12'\n    dim = _days_in_month(year, month)\n    assert 1 <= day <= dim, ('day must be in 1..%d' % dim)\n    return (_days_before_year(year) +\n            _days_before_month(year, month) +\n            day)\n\n_DI400Y = _days_before_year(401)    # number of days in 400 years\n_DI100Y = _days_before_year(101)    #    \"    \"   \"   \" 100   \"\n_DI4Y   = _days_before_year(5)      #    \"    \"   \"   \"   4   \"\n\n# A 4-year cycle has an extra leap day over what we'd get from pasting\n# together 4 single years.\nassert _DI4Y == 4 * 365 + 1\n\n# Similarly, a 400-year cycle has an extra leap day over what we'd get from\n# pasting together 4 100-year cycles.\nassert _DI400Y == 4 * _DI100Y + 1\n\n# OTOH, a 100-year cycle has one fewer leap day than we'd get from\n# pasting together 25 4-year cycles.\nassert _DI100Y == 25 * _DI4Y - 1\n\n_US_PER_US = 1\n_US_PER_MS = 1000\n_US_PER_SECOND = 1000000\n_US_PER_MINUTE = 60000000\n_SECONDS_PER_DAY = 24 * 3600\n_US_PER_HOUR = 3600000000\n_US_PER_DAY = 86400000000\n_US_PER_WEEK = 604800000000\n\ndef _ord2ymd(n):\n    \"ordinal -> (year, month, day), considering 01-Jan-0001 as day 1.\"\n\n    # n is a 1-based index, starting at 1-Jan-1.  The pattern of leap years\n    # repeats exactly every 400 years.  The basic strategy is to find the\n    # closest 400-year boundary at or before n, then work with the offset\n    # from that boundary to n.  Life is much clearer if we subtract 1 from\n    # n first -- then the values of n at 400-year boundaries are exactly\n    # those divisible by _DI400Y:\n    #\n    #     D  M   Y            n              n-1\n    #     -- --- ----        ----------     ----------------\n    #     31 Dec -400        -_DI400Y       -_DI400Y -1\n    #      1 Jan -399         -_DI400Y +1   -_DI400Y      400-year boundary\n    #     ...\n    #     30 Dec  000        -1             -2\n    #     31 Dec  000         0             -1\n    #      1 Jan  001         1              0            400-year boundary\n    #      2 Jan  001         2              1\n    #      3 Jan  001         3              2\n    #     ...\n    #     31 Dec  400         _DI400Y        _DI400Y -1\n    #      1 Jan  401         _DI400Y +1     _DI400Y      400-year boundary\n    n -= 1\n    n400, n = divmod(n, _DI400Y)\n    year = n400 * 400 + 1   # ..., -399, 1, 401, ...\n\n    # Now n is the (non-negative) offset, in days, from January 1 of year, to\n    # the desired date.  Now compute how many 100-year cycles precede n.\n    # Note that it's possible for n100 to equal 4!  In that case 4 full\n    # 100-year cycles precede the desired day, which implies the desired\n    # day is December 31 at the end of a 400-year cycle.\n    n100, n = divmod(n, _DI100Y)\n\n    # Now compute how many 4-year cycles precede it.\n    n4, n = divmod(n, _DI4Y)\n\n    # And now how many single years.  Again n1 can be 4, and again meaning\n    # that the desired day is December 31 at the end of the 4-year cycle.\n    n1, n = divmod(n, 365)\n\n    year += n100 * 100 + n4 * 4 + n1\n    if n1 == 4 or n100 == 4:\n        assert n == 0\n        return year-1, 12, 31\n\n    # Now the year is correct, and n is the offset from January 1.  We find\n    # the month via an estimate that's either exact or one too large.\n    leapyear = n1 == 3 and (n4 != 24 or n100 == 3)\n    assert leapyear == _is_leap(year)\n    month = (n + 50) >> 5\n    preceding = _DAYS_BEFORE_MONTH[month] + (month > 2 and leapyear)\n    if preceding > n:  # estimate is too large\n        month -= 1\n        preceding -= _DAYS_IN_MONTH[month] + (month == 2 and leapyear)\n    n -= preceding\n    assert 0 <= n < _days_in_month(year, month)\n\n    # Now the year and month are correct, and n is the offset from the\n    # start of that month:  we're done!\n    return year, month, n+1\n\n# Month and day names.  For localized versions, see the calendar module.\n_MONTHNAMES = [None, \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                     \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n_DAYNAMES = [None, \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]\n\n\ndef _build_struct_time(y, m, d, hh, mm, ss, dstflag):\n    wday = (_ymd2ord(y, m, d) + 6) % 7\n    dnum = _days_before_month(y, m) + d\n    return _time.struct_time((y, m, d, hh, mm, ss, wday, dnum, dstflag))\n\ndef _format_time(hh, mm, ss, us):\n    # Skip trailing microseconds when us==0.\n    result = \"%02d:%02d:%02d\" % (hh, mm, ss)\n    if us:\n        result += \".%06d\" % us\n    return result\n\n# Correctly substitute for %z and %Z escapes in strftime formats.\ndef _wrap_strftime(object, format, timetuple):\n    year = timetuple[0]\n    if year < _MINYEARFMT:\n        raise ValueError(\"year=%d is before %d; the datetime strftime() \"\n                         \"methods require year >= %d\" %\n                         (year, _MINYEARFMT, _MINYEARFMT))\n    # Don't call utcoffset() or tzname() unless actually needed.\n    freplace = None  # the string to use for %f\n    zreplace = None  # the string to use for %z\n    Zreplace = None  # the string to use for %Z\n\n    # Scan format for %z and %Z escapes, replacing as needed.\n    newformat = []\n    push = newformat.append\n    i, n = 0, len(format)\n    while i < n:\n        ch = format[i]\n        i += 1\n        if ch == '%':\n            if i < n:\n                ch = format[i]\n                i += 1\n                if ch == 'f':\n                    if freplace is None:\n                        freplace = '%06d' % getattr(object,\n                                                    'microsecond', 0)\n                    newformat.append(freplace)\n                elif ch == 'z':\n                    if zreplace is None:\n                        zreplace = \"\"\n                        if hasattr(object, \"_utcoffset\"):\n                            offset = object._utcoffset()\n                            if offset is not None:\n                                sign = '+'\n                                if offset < 0:\n                                    offset = -offset\n                                    sign = '-'\n                                h, m = divmod(offset, 60)\n                                zreplace = '%c%02d%02d' % (sign, h, m)\n                    assert '%' not in zreplace\n                    newformat.append(zreplace)\n                elif ch == 'Z':\n                    if Zreplace is None:\n                        Zreplace = \"\"\n                        if hasattr(object, \"tzname\"):\n                            s = object.tzname()\n                            if s is not None:\n                                # strftime is going to have at this: escape %\n                                Zreplace = s.replace('%', '%%')\n                    newformat.append(Zreplace)\n                else:\n                    push('%')\n                    push(ch)\n            else:\n                push('%')\n        else:\n            push(ch)\n    newformat = \"\".join(newformat)\n    return _time.strftime(newformat, timetuple)\n\n# Just raise TypeError if the arg isn't None or a string.\ndef _check_tzname(name):\n    if name is not None and not isinstance(name, str):\n        raise TypeError(\"tzinfo.tzname() must return None or string, \"\n                        \"not '%s'\" % type(name))\n\n# name is the offset-producing method, \"utcoffset\" or \"dst\".\n# offset is what it returned.\n# If offset isn't None or timedelta, raises TypeError.\n# If offset is None, returns None.\n# Else offset is checked for being in range, and a whole # of minutes.\n# If it is, its integer value is returned.  Else ValueError is raised.\ndef _check_utc_offset(name, offset):\n    assert name in (\"utcoffset\", \"dst\")\n    if offset is None:\n        return\n    if not isinstance(offset, timedelta):\n        raise TypeError(\"tzinfo.%s() must return None \"\n                        \"or timedelta, not '%s'\" % (name, type(offset)))\n    days = offset.days\n    if days < -1 or days > 0:\n        offset = 1440  # trigger out-of-range\n    else:\n        seconds = days * 86400 + offset.seconds\n        minutes, seconds = divmod(seconds, 60)\n        if seconds or offset.microseconds:\n            raise ValueError(\"tzinfo.%s() must return a whole number \"\n                             \"of minutes\" % name)\n        offset = minutes\n    if not -1440 < offset < 1440:\n        raise ValueError(\"%s()=%d, must be in -1439..1439\" % (name, offset))\n    return offset\n\ndef _check_int_field(value):\n    if isinstance(value, int):\n        return int(value)\n    if not isinstance(value, float):\n        try:\n            value = value.__int__()\n        except AttributeError:\n            pass\n        else:\n            if isinstance(value, int):\n                return int(value)\n            elif isinstance(value, long):\n                return int(long(value))\n            raise TypeError('__int__ method should return an integer')\n        raise TypeError('an integer is required')\n    raise TypeError('integer argument expected, got float')\n\ndef _check_date_fields(year, month, day):\n    year = _check_int_field(year)\n    month = _check_int_field(month)\n    day = _check_int_field(day)\n    if not MINYEAR <= year <= MAXYEAR:\n        raise ValueError('year must be in %d..%d' % (MINYEAR, MAXYEAR), year)\n    if not 1 <= month <= 12:\n        raise ValueError('month must be in 1..12', month)\n    dim = _days_in_month(year, month)\n    if not 1 <= day <= dim:\n        raise ValueError('day must be in 1..%d' % dim, day)\n    return year, month, day\n\ndef _check_time_fields(hour, minute, second, microsecond):\n    hour = _check_int_field(hour)\n    minute = _check_int_field(minute)\n    second = _check_int_field(second)\n    microsecond = _check_int_field(microsecond)\n    if not 0 <= hour <= 23:\n        raise ValueError('hour must be in 0..23', hour)\n    if not 0 <= minute <= 59:\n        raise ValueError('minute must be in 0..59', minute)\n    if not 0 <= second <= 59:\n        raise ValueError('second must be in 0..59', second)\n    if not 0 <= microsecond <= 999999:\n        raise ValueError('microsecond must be in 0..999999', microsecond)\n    return hour, minute, second, microsecond\n\ndef _check_tzinfo_arg(tz):\n    if tz is not None and not isinstance(tz, tzinfo):\n        raise TypeError(\"tzinfo argument must be None or of a tzinfo subclass\")\n\n\n# Notes on comparison:  In general, datetime module comparison operators raise\n# TypeError when they don't know how to do a comparison themself.  If they\n# returned NotImplemented instead, comparison could (silently) fall back to\n# the default compare-objects-by-comparing-their-memory-addresses strategy,\n# and that's not helpful.  There are two exceptions:\n#\n# 1. For date and datetime, if the other object has a \"timetuple\" attr,\n#    NotImplemented is returned.  This is a hook to allow other kinds of\n#    datetime-like objects a chance to intercept the comparison.\n#\n# 2. Else __eq__ and __ne__ return False and True, respectively.  This is\n#    so opertaions like\n#\n#        x == y\n#        x != y\n#        x in sequence\n#        x not in sequence\n#        dict[x] = y\n#\n#    don't raise annoying TypeErrors just because a datetime object\n#    is part of a heterogeneous collection.  If there's no known way to\n#    compare X to a datetime, saying they're not equal is reasonable.\n\ndef _cmperror(x, y):\n    raise TypeError(\"can't compare '%s' to '%s'\" % (\n                    type(x).__name__, type(y).__name__))\n\ndef _normalize_pair(hi, lo, factor):\n    if not 0 <= lo <= factor-1:\n        inc, lo = divmod(lo, factor)\n        hi += inc\n    return hi, lo\n\ndef _normalize_datetime(y, m, d, hh, mm, ss, us, ignore_overflow=False):\n    # Normalize all the inputs, and store the normalized values.\n    ss, us = _normalize_pair(ss, us, 1000000)\n    mm, ss = _normalize_pair(mm, ss, 60)\n    hh, mm = _normalize_pair(hh, mm, 60)\n    d, hh = _normalize_pair(d, hh, 24)\n    y, m, d = _normalize_date(y, m, d, ignore_overflow)\n    return y, m, d, hh, mm, ss, us\n\ndef _normalize_date(year, month, day, ignore_overflow=False):\n    # That was easy.  Now it gets muddy:  the proper range for day\n    # can't be determined without knowing the correct month and year,\n    # but if day is, e.g., plus or minus a million, the current month\n    # and year values make no sense (and may also be out of bounds\n    # themselves).\n    # Saying 12 months == 1 year should be non-controversial.\n    if not 1 <= month <= 12:\n        year, month = _normalize_pair(year, month-1, 12)\n        month += 1\n        assert 1 <= month <= 12\n\n    # Now only day can be out of bounds (year may also be out of bounds\n    # for a datetime object, but we don't care about that here).\n    # If day is out of bounds, what to do is arguable, but at least the\n    # method here is principled and explainable.\n    dim = _days_in_month(year, month)\n    if not 1 <= day <= dim:\n        # Move day-1 days from the first of the month.  First try to\n        # get off cheap if we're only one day out of range (adjustments\n        # for timezone alone can't be worse than that).\n        if day == 0:    # move back a day\n            month -= 1\n            if month > 0:\n                day = _days_in_month(year, month)\n            else:\n                year, month, day = year-1, 12, 31\n        elif day == dim + 1:    # move forward a day\n            month += 1\n            day = 1\n            if month > 12:\n                month = 1\n                year += 1\n        else:\n            ordinal = _ymd2ord(year, month, 1) + (day - 1)\n            year, month, day = _ord2ymd(ordinal)\n\n    if not ignore_overflow and not MINYEAR <= year <= MAXYEAR:\n        raise OverflowError(\"date value out of range\")\n    return year, month, day\n\ndef _accum(tag, sofar, num, factor, leftover):\n    if isinstance(num, (int, long)):\n        prod = num * factor\n        rsum = sofar + prod\n        return rsum, leftover\n    if isinstance(num, float):\n        fracpart, intpart = _math.modf(num)\n        prod = int(intpart) * factor\n        rsum = sofar + prod\n        if fracpart == 0.0:\n            return rsum, leftover\n        assert isinstance(factor, (int, long))\n        fracpart, intpart = _math.modf(factor * fracpart)\n        rsum += int(intpart)\n        return rsum, leftover + fracpart\n    raise TypeError(\"unsupported type for timedelta %s component: %s\" %\n                    (tag, type(num)))\n\nclass timedelta(object):\n    \"\"\"Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int/long\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    \"\"\"\n    __slots__ = '_days', '_seconds', '_microseconds', '_hashcode'\n\n    def __new__(cls, days=_SENTINEL, seconds=_SENTINEL, microseconds=_SENTINEL,\n                milliseconds=_SENTINEL, minutes=_SENTINEL, hours=_SENTINEL, weeks=_SENTINEL):\n        x = 0\n        leftover = 0.0\n        if microseconds is not _SENTINEL:\n            x, leftover = _accum(\"microseconds\", x, microseconds, _US_PER_US, leftover)\n        if milliseconds is not _SENTINEL:\n            x, leftover = _accum(\"milliseconds\", x, milliseconds, _US_PER_MS, leftover)\n        if seconds is not _SENTINEL:\n            x, leftover = _accum(\"seconds\", x, seconds, _US_PER_SECOND, leftover)\n        if minutes is not _SENTINEL:\n            x, leftover = _accum(\"minutes\", x, minutes, _US_PER_MINUTE, leftover)\n        if hours is not _SENTINEL:\n            x, leftover = _accum(\"hours\", x, hours, _US_PER_HOUR, leftover)\n        if days is not _SENTINEL:\n            x, leftover = _accum(\"days\", x, days, _US_PER_DAY, leftover)\n        if weeks is not _SENTINEL:\n            x, leftover = _accum(\"weeks\", x, weeks, _US_PER_WEEK, leftover)\n        if leftover != 0.0:\n            x += _round(leftover)\n        return cls._from_microseconds(x)\n\n    @classmethod\n    def _from_microseconds(cls, us):\n        s, us = divmod(us, _US_PER_SECOND)\n        d, s = divmod(s, _SECONDS_PER_DAY)\n        return cls._create(d, s, us, False)\n\n    @classmethod\n    def _create(cls, d, s, us, normalize):\n        if normalize:\n            s, us = _normalize_pair(s, us, 1000000)\n            d, s = _normalize_pair(d, s, 24*3600)\n\n        if not -_MAX_DELTA_DAYS <= d <= _MAX_DELTA_DAYS:\n            raise OverflowError(\"days=%d; must have magnitude <= %d\" % (d, _MAX_DELTA_DAYS))\n\n        self = object.__new__(cls)\n        self._days = d\n        self._seconds = s\n        self._microseconds = us\n        self._hashcode = -1\n        return self\n\n    def _to_microseconds(self):\n        return ((self._days * _SECONDS_PER_DAY + self._seconds) * _US_PER_SECOND +\n                self._microseconds)\n\n    def __repr__(self):\n        module = \"datetime.\" if self.__class__ is timedelta else \"\"\n        if self._microseconds:\n            return \"%s(%d, %d, %d)\" % (module + self.__class__.__name__,\n                                       self._days,\n                                       self._seconds,\n                                       self._microseconds)\n        if self._seconds:\n            return \"%s(%d, %d)\" % (module + self.__class__.__name__,\n                                   self._days,\n                                   self._seconds)\n        return \"%s(%d)\" % (module + self.__class__.__name__, self._days)\n\n    def __str__(self):\n        mm, ss = divmod(self._seconds, 60)\n        hh, mm = divmod(mm, 60)\n        s = \"%d:%02d:%02d\" % (hh, mm, ss)\n        if self._days:\n            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\"\n            s = (\"%d day%s, \" % plural(self._days)) + s\n        if self._microseconds:\n            s = s + \".%06d\" % self._microseconds\n        return s\n\n    def total_seconds(self):\n        \"\"\"Total seconds in the duration.\"\"\"\n        return self._to_microseconds() / 10.0**6\n\n    # Read-only field accessors\n    @property\n    def days(self):\n        \"\"\"days\"\"\"\n        return self._days\n\n    @property\n    def seconds(self):\n        \"\"\"seconds\"\"\"\n        return self._seconds\n\n    @property\n    def microseconds(self):\n        \"\"\"microseconds\"\"\"\n        return self._microseconds\n\n    def __add__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta._create(self._days + other._days,\n                                     self._seconds + other._seconds,\n                                     self._microseconds + other._microseconds,\n                                     True)\n        return NotImplemented\n\n    def __sub__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta._create(self._days - other._days,\n                                     self._seconds - other._seconds,\n                                     self._microseconds - other._microseconds,\n                                     True)\n        return NotImplemented\n\n    def __neg__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta._create(-self._days,\n                                 -self._seconds,\n                                 -self._microseconds,\n                                 True)\n\n    def __pos__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta._create(self._days,\n                                 self._seconds,\n                                 self._microseconds,\n                                 False)\n\n    def __abs__(self):\n        if self._days < 0:\n            return -self\n        else:\n            return self\n\n    def __mul__(self, other):\n        if not isinstance(other, (int, long)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        return timedelta._from_microseconds(usec * other)\n\n    __rmul__ = __mul__\n\n    def __div__(self, other):\n        if not isinstance(other, (int, long)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        return timedelta._from_microseconds(usec // other)\n\n    __floordiv__ = __div__\n\n    # Comparisons of timedelta objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) == 0\n        else:\n            return False\n\n    def __ne__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) != 0\n        else:\n            return True\n\n    def __le__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) <= 0\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) < 0\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) >= 0\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) > 0\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, timedelta)\n        return _cmp(self._getstate(), other._getstate())\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    def __nonzero__(self):\n        return (self._days != 0 or\n                self._seconds != 0 or\n                self._microseconds != 0)\n\ntimedelta.min = timedelta(-_MAX_DELTA_DAYS)\ntimedelta.max = timedelta(_MAX_DELTA_DAYS, 24*3600-1, 1000000-1)\ntimedelta.resolution = timedelta(microseconds=1)\n\nclass date(object):\n    \"\"\"Concrete date type.\n\n    Constructors:\n\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n\n    Operators:\n\n    __repr__, __str__\n    __cmp__, __hash__\n    __add__, __radd__, __sub__ (add/radd only with timedelta arg)\n\n    Methods:\n\n    timetuple()\n    toordinal()\n    weekday()\n    isoweekday(), isocalendar(), isoformat()\n    ctime()\n    strftime()\n\n    Properties (readonly):\n    year, month, day\n    \"\"\"\n    __slots__ = '_year', '_month', '_day', '_hashcode'\n\n    def __new__(cls, year, month=None, day=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        year, month, day (required, base 1)\n        \"\"\"\n        year, month, day = _check_date_fields(year, month, day)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hashcode = -1\n        return self\n\n    # Additional constructors\n\n    @classmethod\n    def fromtimestamp(cls, t):\n        \"Construct a date from a POSIX timestamp (like time.time()).\"\n        y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)\n        return cls(y, m, d)\n\n    @classmethod\n    def today(cls):\n        \"Construct a date from time.time().\"\n        t = _time.time()\n        return cls.fromtimestamp(t)\n\n    @classmethod\n    def fromordinal(cls, n):\n        \"\"\"Contruct a date from a proleptic Gregorian ordinal.\n\n        January 1 of year 1 is day 1.  Only the year, month and day are\n        non-zero in the result.\n        \"\"\"\n        y, m, d = _ord2ymd(n)\n        return cls(y, m, d)\n\n    # Conversions to string\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> dt = datetime(2010, 1, 1)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0)'\n\n        >>> dt = datetime(2010, 1, 1, tzinfo=timezone.utc)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)'\n        \"\"\"\n        module = \"datetime.\" if self.__class__ is date else \"\"\n        return \"%s(%d, %d, %d)\" % (module + self.__class__.__name__,\n                                   self._year,\n                                   self._month,\n                                   self._day)\n\n    # XXX These shouldn't depend on time.localtime(), because that\n    # clips the usable dates to [1970 .. 2038).  At least ctime() is\n    # easily done without using strftime() -- that's better too because\n    # strftime(\"%c\", ...) is locale specific.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d 00:00:00 %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day, self._year)\n\n    def strftime(self, format):\n        \"Format using strftime().\"\n        return _wrap_strftime(self, format, self.timetuple())\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, (str, unicode)):\n            raise ValueError(\"__format__ expects str or unicode, not %s\" %\n                             fmt.__class__.__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    def isoformat(self):\n        \"\"\"Return the date formatted according to ISO.\n\n        This is 'YYYY-MM-DD'.\n\n        References:\n        - http://www.w3.org/TR/NOTE-datetime\n        - http://www.cl.cam.ac.uk/~mgk25/iso-time.html\n        \"\"\"\n        return \"%04d-%02d-%02d\" % (self._year, self._month, self._day)\n\n    __str__ = isoformat\n\n    # Read-only field accessors\n    @property\n    def year(self):\n        \"\"\"year (1-9999)\"\"\"\n        return self._year\n\n    @property\n    def month(self):\n        \"\"\"month (1-12)\"\"\"\n        return self._month\n\n    @property\n    def day(self):\n        \"\"\"day (1-31)\"\"\"\n        return self._day\n\n    # Standard conversions, __cmp__, __hash__ (and helpers)\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        return _build_struct_time(self._year, self._month, self._day,\n                                  0, 0, 0, -1)\n\n    def toordinal(self):\n        \"\"\"Return proleptic Gregorian ordinal for the year, month and day.\n\n        January 1 of year 1 is day 1.  Only the year, month and day values\n        contribute to the result.\n        \"\"\"\n        return _ymd2ord(self._year, self._month, self._day)\n\n    def replace(self, year=None, month=None, day=None):\n        \"\"\"Return a new date with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self._year\n        if month is None:\n            month = self._month\n        if day is None:\n            day = self._day\n        return date(year, month, day)\n\n    # Comparisons of date objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) == 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            return False\n\n    def __ne__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) != 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            return True\n\n    def __le__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) <= 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) < 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) >= 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) > 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, date)\n        y, m, d = self._year, self._month, self._day\n        y2, m2, d2 = other._year, other._month, other._day\n        return _cmp((y, m, d), (y2, m2, d2))\n\n    def __hash__(self):\n        \"Hash.\"\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    # Computations\n\n    def _add_timedelta(self, other, factor):\n        y, m, d = _normalize_date(\n            self._year,\n            self._month,\n            self._day + other.days * factor)\n        return date(y, m, d)\n\n    def __add__(self, other):\n        \"Add a date to a timedelta.\"\n        if isinstance(other, timedelta):\n            return self._add_timedelta(other, 1)\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"\"\"Subtract two dates, or a date and a timedelta.\"\"\"\n        if isinstance(other, date):\n            days1 = self.toordinal()\n            days2 = other.toordinal()\n            return timedelta._create(days1 - days2, 0, 0, False)\n        if isinstance(other, timedelta):\n            return self._add_timedelta(other, -1)\n        return NotImplemented\n\n    def weekday(self):\n        \"Return day of the week, where Monday == 0 ... Sunday == 6.\"\n        return (self.toordinal() + 6) % 7\n\n    # Day-of-the-week and week-of-the-year, according to ISO\n\n    def isoweekday(self):\n        \"Return day of the week, where Monday == 1 ... Sunday == 7.\"\n        # 1-Jan-0001 is a Monday\n        return self.toordinal() % 7 or 7\n\n    def isocalendar(self):\n        \"\"\"Return a 3-tuple containing ISO year, week number, and weekday.\n\n        The first ISO week of the year is the (Mon-Sun) week\n        containing the year's first Thursday; everything else derives\n        from that.\n\n        The first week is 1; Monday is 1 ... Sunday is 7.\n\n        ISO calendar algorithm taken from\n        http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm\n        \"\"\"\n        year = self._year\n        week1monday = _isoweek1monday(year)\n        today = _ymd2ord(self._year, self._month, self._day)\n        # Internally, week and day have origin 0\n        week, day = divmod(today - week1monday, 7)\n        if week < 0:\n            year -= 1\n            week1monday = _isoweek1monday(year)\n            week, day = divmod(today - week1monday, 7)\n        elif week >= 52:\n            if today >= _isoweek1monday(year+1):\n                year += 1\n                week = 0\n        return year, week+1, day+1\n\n_date_class = date  # so functions w/ args named \"date\" can get at the class\n\ndate.min = date(1, 1, 1)\ndate.max = date(9999, 12, 31)\ndate.resolution = timedelta(days=1)\n\nclass tzinfo(object):\n    \"\"\"Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n\n    def utcoffset(self, dt):\n        \"datetime -> minutes east of UTC (negative for west of UTC)\"\n        raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n\n    def dst(self, dt):\n        \"\"\"datetime -> DST offset in minutes east of UTC.\n\n        Return 0 if DST not in effect.  utcoffset() must include the DST\n        offset.\n        \"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override dst()\")\n\n    def fromutc(self, dt):\n        \"datetime in UTC -> datetime in local time.\"\n\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # See the long comment block at the end of this file for an\n        # explanation of this algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n        if delta:\n            dt = dt + delta\n            dtdst = dt.dst()\n            if dtdst is None:\n                raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")\n        if dtdst:\n            return dt + dtdst\n        else:\n            return dt\n\n_tzinfo_class = tzinfo\n\nclass time(object):\n    \"\"\"Time with time zone.\n\n    Constructors:\n\n    __new__()\n\n    Operators:\n\n    __repr__, __str__\n    __cmp__, __hash__\n\n    Methods:\n\n    strftime()\n    isoformat()\n    utcoffset()\n    tzname()\n    dst()\n\n    Properties (readonly):\n    hour, minute, second, microsecond, tzinfo\n    \"\"\"\n    __slots__ = '_hour', '_minute', '_second', '_microsecond', '_tzinfo', '_hashcode'\n\n    def __new__(cls, hour=0, minute=0, second=0, microsecond=0, tzinfo=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        hour, minute (required)\n        second, microsecond (default to zero)\n        tzinfo (default to None)\n        \"\"\"\n        hour, minute, second, microsecond = _check_time_fields(\n            hour, minute, second, microsecond)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    # Standard conversions, __hash__ (and helpers)\n\n    # Comparisons of time objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) == 0\n        else:\n            return False\n\n    def __ne__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) != 0\n        else:\n            return True\n\n    def __le__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) <= 0\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) < 0\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) >= 0\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) > 0\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, time)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self._utcoffset()\n            otoff = other._utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            raise TypeError(\"can't compare offset-naive and offset-aware times\")\n        myhhmm = self._hour * 60 + self._minute - myoff\n        othhmm = other._hour * 60 + other._minute - otoff\n        return _cmp((myhhmm, self._second, self._microsecond),\n                    (othhmm, other._second, other._microsecond))\n\n    def __hash__(self):\n        \"\"\"Hash.\"\"\"\n        if self._hashcode == -1:\n            tzoff = self._utcoffset()\n            if not tzoff:  # zero or None\n                self._hashcode = hash(self._getstate()[0])\n            else:\n                h, m = divmod(self.hour * 60 + self.minute - tzoff, 60)\n                if 0 <= h < 24:\n                    self._hashcode = hash(time(h, m, self.second, self.microsecond))\n                else:\n                    self._hashcode = hash((h, m, self.second, self.microsecond))\n        return self._hashcode\n\n    # Conversion to string\n\n    def _tzstr(self, sep=\":\"):\n        \"\"\"Return formatted timezone offset (+xx:xx) or None.\"\"\"\n        off = self._utcoffset()\n        if off is not None:\n            if off < 0:\n                sign = \"-\"\n                off = -off\n            else:\n                sign = \"+\"\n            hh, mm = divmod(off, 60)\n            assert 0 <= hh < 24\n            off = \"%s%02d%s%02d\" % (sign, hh, sep, mm)\n        return off\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        if self._microsecond != 0:\n            s = \", %d, %d\" % (self._second, self._microsecond)\n        elif self._second != 0:\n            s = \", %d\" % self._second\n        else:\n            s = \"\"\n        module = \"datetime.\" if self.__class__ is time else \"\"\n        s= \"%s(%d, %d%s)\" % (module + self.__class__.__name__,\n                             self._hour, self._minute, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        return s\n\n    def isoformat(self):\n        \"\"\"Return the time formatted according to ISO.\n\n        This is 'HH:MM:SS.mmmmmm+zz:zz', or 'HH:MM:SS+zz:zz' if\n        self.microsecond == 0.\n        \"\"\"\n        s = _format_time(self._hour, self._minute, self._second,\n                         self._microsecond)\n        tz = self._tzstr()\n        if tz:\n            s += tz\n        return s\n\n    __str__ = isoformat\n\n    def strftime(self, format):\n        \"\"\"Format using strftime().  The date part of the timestamp passed\n        to underlying strftime should not be used.\n        \"\"\"\n        # The year must be >= _MINYEARFMT else Python's strftime implementation\n        # can raise a bogus exception.\n        timetuple = (1900, 1, 1,\n                     self._hour, self._minute, self._second,\n                     0, 1, -1)\n        return _wrap_strftime(self, format, timetuple)\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, (str, unicode)):\n            raise ValueError(\"__format__ expects str or unicode, not %s\" %\n                             fmt.__class__.__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    # Timezone functions\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset in minutes east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        offset = _check_utc_offset(\"utcoffset\", offset)\n        if offset is not None:\n            offset = timedelta._create(0, offset * 60, 0, True)\n        return offset\n\n    # Return an integer (or None) instead of a timedelta (or None).\n    def _utcoffset(self):\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        offset = _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(None)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (in minutes\n        eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        offset = _check_utc_offset(\"dst\", offset)\n        if offset is not None:\n            offset = timedelta._create(0, offset * 60, 0, True)\n        return offset\n\n    # Return an integer (or None) instead of a timedelta (or None).\n    def _dst(self):\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        offset = _check_utc_offset(\"dst\", offset)\n        return offset\n\n    def replace(self, hour=None, minute=None, second=None, microsecond=None,\n                tzinfo=True):\n        \"\"\"Return a new time with new values for the specified fields.\"\"\"\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        return time(hour, minute, second, microsecond, tzinfo)\n\n    def __nonzero__(self):\n        if self.second or self.microsecond:\n            return True\n        offset = self._utcoffset() or 0\n        return self.hour * 60 + self.minute != offset\n\n_time_class = time  # so functions w/ args named \"time\" can get at the class\n\ntime.min = time(0, 0, 0)\ntime.max = time(23, 59, 59, 999999)\ntime.resolution = timedelta(microseconds=1)\n\nclass datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints or longs.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None):\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond = _check_time_fields(\n            hour, minute, second, microsecond)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @classmethod\n    def fromtimestamp(cls, timestamp, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n        converter = _time.localtime if tz is None else _time.gmtime\n        self = cls._from_timestamp(converter, timestamp, tz)\n        if tz is not None:\n            self = tz.fromutc(self)\n        return self\n\n    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"Construct a UTC datetime from a POSIX timestamp (like time.time()).\"\n        return cls._from_timestamp(_time.gmtime, t, None)\n\n    @classmethod\n    def _from_timestamp(cls, converter, timestamp, tzinfo):\n        t_full = timestamp\n        timestamp = int(_math.floor(timestamp))\n        frac = t_full - timestamp\n        us = _round(frac * 1e6)\n\n        # If timestamp is less than one microsecond smaller than a\n        # full second, us can be rounded up to 1000000.  In this case,\n        # roll over to seconds, otherwise, ValueError is raised\n        # by the constructor.\n        if us == 1000000:\n            timestamp += 1\n            us = 0\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(timestamp)\n        ss = min(ss, 59)    # clamp out leap seconds if the platform has them\n        return cls(y, m, d, hh, mm, ss, us, tzinfo)\n\n    @classmethod\n    def now(cls, tz=None):\n        \"Construct a datetime from time.time() and optional time zone info.\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)\n\n    @classmethod\n    def utcnow(cls):\n        \"Construct a UTC datetime from time.time().\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)\n\n    @classmethod\n    def combine(cls, date, time):\n        \"Construct a datetime from a given date and a given time.\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   time.tzinfo)\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        dst = self._dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)\n\n    def utctimetuple(self):\n        \"Return UTC time tuple compatible with time.gmtime().\"\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        offset = self._utcoffset()\n        if offset:  # neither None nor 0\n            mm -= offset\n            y, m, d, hh, mm, ss, _ = _normalize_datetime(\n                y, m, d, hh, mm, ss, 0, ignore_overflow=True)\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)\n\n    def date(self):\n        \"Return the date part.\"\n        return date(self._year, self._month, self._day)\n\n    def time(self):\n        \"Return the time part, with tzinfo None.\"\n        return time(self.hour, self.minute, self.second, self.microsecond)\n\n    def timetz(self):\n        \"Return the time part, with same tzinfo.\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo)\n\n    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        return datetime(year, month, day, hour, minute, second, microsecond,\n                        tzinfo)\n\n    def astimezone(self, tz):\n        if not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            raise ValueError(\"astimezone() requires an aware datetime\")\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        myoffset = self.utcoffset()\n        if myoffset is None:\n            raise ValueError(\"astimezone() requires an aware datetime\")\n        utc = (self - myoffset).replace(tzinfo=tz)\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)\n\n    # Ways to produce a string.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)\n\n    def isoformat(self, sep='T'):\n        \"\"\"Return the time formatted according to ISO.\n\n        This is 'YYYY-MM-DD HH:MM:SS.mmmmmm', or 'YYYY-MM-DD HH:MM:SS' if\n        self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM' or 'YYYY-MM-DD HH:MM:SS+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n        \"\"\"\n        s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond))\n        off = self._utcoffset()\n        if off is not None:\n            if off < 0:\n                sign = \"-\"\n                off = -off\n            else:\n                sign = \"+\"\n            hh, mm = divmod(off, 60)\n            s += \"%s%02d:%02d\" % (sign, hh, mm)\n        return s\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[-1] == 0:\n            del L[-1]\n        if L[-1] == 0:\n            del L[-1]\n        s = \", \".join(map(str, L))\n        module = \"datetime.\" if self.__class__ is datetime else \"\"\n        s = \"%s(%s)\" % (module + self.__class__.__name__, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        return s\n\n    def __str__(self):\n        \"Convert to string, for str().\"\n        return self.isoformat(sep=' ')\n\n    @classmethod\n    def strptime(cls, date_string, format):\n        'string, format -> new datetime parsed from a string (like time.strptime()).'\n        from _strptime import _strptime\n        # _strptime._strptime returns a two-element tuple.  The first\n        # element is a time.struct_time object.  The second is the\n        # microseconds (which are not defined for time.struct_time).\n        struct, micros = _strptime(date_string, format)\n        return cls(*(struct[0:6] + (micros,)))\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset in minutes east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        offset = _check_utc_offset(\"utcoffset\", offset)\n        if offset is not None:\n            offset = timedelta._create(0, offset * 60, 0, True)\n        return offset\n\n    # Return an integer (or None) instead of a timedelta (or None).\n    def _utcoffset(self):\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        offset = _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (in minutes\n        eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        offset = _check_utc_offset(\"dst\", offset)\n        if offset is not None:\n            offset = timedelta._create(0, offset * 60, 0, True)\n        return offset\n\n    # Return an integer (or None) instead of a timedelta (or None).\n    def _dst(self):\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        offset = _check_utc_offset(\"dst\", offset)\n        return offset\n\n    # Comparisons of datetime objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) == 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False\n\n    def __ne__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) != 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            return True\n\n    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            if mytz is not None:\n                myoff = self._utcoffset()\n            if ottz is not None:\n                otoff = other._utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            raise TypeError(\"can't compare offset-naive and offset-aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        diff = self - other     # this will take offsets into account\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0\n\n    def _add_timedelta(self, other, factor):\n        y, m, d, hh, mm, ss, us = _normalize_datetime(\n            self._year,\n            self._month,\n            self._day + other.days * factor,\n            self._hour,\n            self._minute,\n            self._second + other.seconds * factor,\n            self._microsecond + other.microseconds * factor)\n        return datetime(y, m, d, hh, mm, ss, us, tzinfo=self._tzinfo)\n\n    def __add__(self, other):\n        \"Add a datetime and a timedelta.\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        return self._add_timedelta(other, 1)\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"Subtract two datetimes, or a datetime and a timedelta.\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                return self._add_timedelta(other, -1)\n            return NotImplemented\n\n        delta_d = self.toordinal() - other.toordinal()\n        delta_s = (self._hour - other._hour) * 3600 + \\\n                  (self._minute - other._minute) * 60 + \\\n                  (self._second - other._second)\n        delta_us = self._microsecond - other._microsecond\n        base = timedelta._create(delta_d, delta_s, delta_us, True)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self._utcoffset()\n        otoff = other._utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"can't subtract offset-naive and offset-aware datetimes\")\n        return base + timedelta(minutes = otoff-myoff)\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            tzoff = self._utcoffset()\n            if tzoff is None:\n                self._hashcode = hash(self._getstate()[0])\n            else:\n                days = _ymd2ord(self.year, self.month, self.day)\n                seconds = self.hour * 3600 + (self.minute - tzoff) * 60 + self.second\n                self._hashcode = hash(timedelta(days, seconds, self.microsecond))\n        return self._hashcode\n\n\n\ndatetime.min = datetime(1, 1, 1)\ndatetime.max = datetime(9999, 12, 31, 23, 59, 59, 999999)\ndatetime.resolution = timedelta(microseconds=1)\n\n\ndef _isoweek1monday(year):\n    # Helper to calculate the day number of the Monday starting week 1\n    # XXX This could be done more efficiently\n    THURSDAY = 3\n    firstday = _ymd2ord(year, 1, 1)\n    firstweekday = (firstday + 6) % 7  # See weekday() above\n    week1monday = firstday - firstweekday\n    if firstweekday > THURSDAY:\n        week1monday += 7\n    return week1monday\n\n\"\"\"\nSome time zone algebra.  For a datetime x, let\n    x.n = x stripped of its timezone -- its naive time.\n    x.o = x.utcoffset(), and assuming that doesn't raise an exception or\n          return None\n    x.d = x.dst(), and assuming that doesn't raise an exception or\n          return None\n    x.s = x's standard offset, x.o - x.d\n\nNow some derived rules, where k is a duration (timedelta).\n\n1. x.o = x.s + x.d\n   This follows from the definition of x.s.\n\n2. If x and y have the same tzinfo member, x.s = y.s.\n   This is actually a requirement, an assumption we need to make about\n   sane tzinfo classes.\n\n3. The naive UTC time corresponding to x is x.n - x.o.\n   This is again a requirement for a sane tzinfo class.\n\n4. (x+k).s = x.s\n   This follows from #2, and that datimetimetz+timedelta preserves tzinfo.\n\n5. (x+k).n = x.n + k\n   Again follows from how arithmetic is defined.\n\nNow we can explain tz.fromutc(x).  Let's assume it's an interesting case\n(meaning that the various tzinfo methods exist, and don't blow up or return\nNone when called).\n\nThe function wants to return a datetime y with timezone tz, equivalent to x.\nx is already in UTC.\n\nBy #3, we want\n\n    y.n - y.o = x.n                             [1]\n\nThe algorithm starts by attaching tz to x.n, and calling that y.  So\nx.n = y.n at the start.  Then it wants to add a duration k to y, so that [1]\nbecomes true; in effect, we want to solve [2] for k:\n\n   (y+k).n - (y+k).o = x.n                      [2]\n\nBy #1, this is the same as\n\n   (y+k).n - ((y+k).s + (y+k).d) = x.n          [3]\n\nBy #5, (y+k).n = y.n + k, which equals x.n + k because x.n=y.n at the start.\nSubstituting that into [3],\n\n   x.n + k - (y+k).s - (y+k).d = x.n; the x.n terms cancel, leaving\n   k - (y+k).s - (y+k).d = 0; rearranging,\n   k = (y+k).s - (y+k).d; by #4, (y+k).s == y.s, so\n   k = y.s - (y+k).d\n\nOn the RHS, (y+k).d can't be computed directly, but y.s can be, and we\napproximate k by ignoring the (y+k).d term at first.  Note that k can't be\nvery large, since all offset-returning methods return a duration of magnitude\nless than 24 hours.  For that reason, if y is firmly in std time, (y+k).d must\nbe 0, so ignoring it has no consequence then.\n\nIn any case, the new value is\n\n    z = y + y.s                                 [4]\n\nIt's helpful to step back at look at [4] from a higher level:  it's simply\nmapping from UTC to tz's standard time.\n\nAt this point, if\n\n    z.n - z.o = x.n                             [5]\n\nwe have an equivalent time, and are almost done.  The insecurity here is\nat the start of daylight time.  Picture US Eastern for concreteness.  The wall\ntime jumps from 1:59 to 3:00, and wall hours of the form 2:MM don't make good\nsense then.  The docs ask that an Eastern tzinfo class consider such a time to\nbe EDT (because it's \"after 2\"), which is a redundant spelling of 1:MM EST\non the day DST starts.  We want to return the 1:MM EST spelling because that's\nthe only spelling that makes sense on the local wall clock.\n\nIn fact, if [5] holds at this point, we do have the standard-time spelling,\nbut that takes a bit of proof.  We first prove a stronger result.  What's the\ndifference between the LHS and RHS of [5]?  Let\n\n    diff = x.n - (z.n - z.o)                    [6]\n\nNow\n    z.n =                       by [4]\n    (y + y.s).n =               by #5\n    y.n + y.s =                 since y.n = x.n\n    x.n + y.s =                 since z and y are have the same tzinfo member,\n                                    y.s = z.s by #2\n    x.n + z.s\n\nPlugging that back into [6] gives\n\n    diff =\n    x.n - ((x.n + z.s) - z.o) =     expanding\n    x.n - x.n - z.s + z.o =         cancelling\n    - z.s + z.o =                   by #2\n    z.d\n\nSo diff = z.d.\n\nIf [5] is true now, diff = 0, so z.d = 0 too, and we have the standard-time\nspelling we wanted in the endcase described above.  We're done.  Contrarily,\nif z.d = 0, then we have a UTC equivalent, and are also done.\n\nIf [5] is not true now, diff = z.d != 0, and z.d is the offset we need to\nadd to z (in effect, z is in tz's standard time, and we need to shift the\nlocal clock into tz's daylight time).\n\nLet\n\n    z' = z + z.d = z + diff                     [7]\n\nand we can again ask whether\n\n    z'.n - z'.o = x.n                           [8]\n\nIf so, we're done.  If not, the tzinfo class is insane, according to the\nassumptions we've made.  This also requires a bit of proof.  As before, let's\ncompute the difference between the LHS and RHS of [8] (and skipping some of\nthe justifications for the kinds of substitutions we've done several times\nalready):\n\n    diff' = x.n - (z'.n - z'.o) =           replacing z'.n via [7]\n            x.n  - (z.n + diff - z'.o) =    replacing diff via [6]\n            x.n - (z.n + x.n - (z.n - z.o) - z'.o) =\n            x.n - z.n - x.n + z.n - z.o + z'.o =    cancel x.n\n            - z.n + z.n - z.o + z'.o =              cancel z.n\n            - z.o + z'.o =                      #1 twice\n            -z.s - z.d + z'.s + z'.d =          z and z' have same tzinfo\n            z'.d - z.d\n\nSo z' is UTC-equivalent to x iff z'.d = z.d at this point.  If they are equal,\nwe've found the UTC-equivalent so are done.  In fact, we stop with [7] and\nreturn z', not bothering to compute z'.d.\n\nHow could z.d and z'd differ?  z' = z + z.d [7], so merely moving z' by\na dst() offset, and starting *from* a time already in DST (we know z.d != 0),\nwould have to change the result dst() returns:  we start in DST, and moving\na little further into it takes us out of DST.\n\nThere isn't a sane case where this can happen.  The closest it gets is at\nthe end of DST, where there's an hour in UTC with no spelling in a hybrid\ntzinfo class.  In US Eastern, that's 5:MM UTC = 0:MM EST = 1:MM EDT.  During\nthat hour, on an Eastern clock 1:MM is taken as being in standard time (6:MM\nUTC) because the docs insist on that, but 0:MM is taken as being in daylight\ntime (4:MM UTC).  There is no local time mapping to 5:MM UTC.  The local\nclock jumps from 1:59 back to 1:00 again, and repeats the 1:MM hour in\nstandard time.  Since that's what the local clock *does*, we want to map both\nUTC hours 5:MM and 6:MM to 1:MM Eastern.  The result is ambiguous\nin local time, but so it goes -- it's the way the local clock works.\n\nWhen x = 5:MM UTC is the input to this algorithm, x.o=0, y.o=-5 and y.d=0,\nso z=0:MM.  z.d=60 (minutes) then, so [5] doesn't hold and we keep going.\nz' = z + z.d = 1:MM then, and z'.d=0, and z'.d - z.d = -60 != 0 so [8]\n(correctly) concludes that z' is not UTC-equivalent to x.\n\nBecause we know z.d said z was in daylight time (else [5] would have held and\nwe would have stopped then), and we know z.d != z'.d (else [8] would have held\nand we have stopped then), and there are only 2 possible values dst() can\nreturn in Eastern, it follows that z'.d must be 0 (which it is in the example,\nbut the reasoning doesn't depend on the example -- it depends on there being\ntwo possible dst() outcomes, one zero and the other non-zero).  Therefore\nz' must be in standard time, and is the spelling we want in this case.\n\nNote again that z' is not UTC-equivalent as far as the hybrid tzinfo class is\nconcerned (because it takes z' as being in standard time rather than the\ndaylight time we intend here), but returning it gives the real-life \"local\nclock repeats an hour\" behavior when mapping the \"unspellable\" UTC hour into\ntz.\n\nWhen the input is 6:MM, z=1:MM and z.d=0, and we stop at once, again with\nthe 1:MM standard time spelling we want.\n\nSo how can this break?  One of the assumptions must be violated.  Two\npossibilities:\n\n1) [2] effectively says that y.s is invariant across all y belong to a given\n   time zone.  This isn't true if, for political reasons or continental drift,\n   a region decides to change its base offset from UTC.\n\n2) There may be versions of \"double daylight\" time where the tail end of\n   the analysis gives up a step too early.  I haven't thought about that\n   enough to say.\n\nIn any case, it's clear that the default fromutc() is strong enough to handle\n\"almost all\" time zones:  so long as the standard offset is invariant, it\ndoesn't matter if daylight time transition points change from year to year, or\nif daylight time is skipped in some years; it doesn't matter how large or\nsmall dst() may get within its bounds; and it doesn't even matter if some\nperverse time zone returns a negative dst()).  So a breaking case must be\npretty bizarre, and a tzinfo subclass can override fromutc() if it is.\n\"\"\"\n", "src/lib/mhlib.py": "raise NotImplementedError(\"mhlib is not yet implemented in Skulpt\")\n", "src/lib/BaseHTTPServer.py": "raise NotImplementedError(\"BaseHTTPServer is not yet implemented in Skulpt\")\n", "src/lib/ntpath.py": "raise NotImplementedError(\"ntpath is not yet implemented in Skulpt\")\n", "src/lib/tokenize.py": "raise NotImplementedError(\"tokenize is not yet implemented in Skulpt\")\n", "src/lib/stringold.py": "raise NotImplementedError(\"stringold is not yet implemented in Skulpt\")\n", "src/lib/commands.py": "raise NotImplementedError(\"commands is not yet implemented in Skulpt\")\n", "src/lib/uuid.py": "raise NotImplementedError(\"uuid is not yet implemented in Skulpt\")\n", "src/lib/popen2.py": "raise NotImplementedError(\"popen2 is not yet implemented in Skulpt\")\n", "src/lib/ast.js": "var $builtinmodule = function (name) {\n    var mod = {};\n    \n    /**\n     * Consumes an AST Node (JS version). Return a list of tuples of \n     * ``(fieldname, value)`` for each field in ``node._fields`` that is\n     * present on *node*.\n     */\n    var iter_fieldsJs = function(node) {\n        var fieldList = [];\n        for (var i = 0; i < node._fields.length; i += 2) {\n            var field = node._fields[i];\n            if (field in node) {\n                fieldList.push([field, node[field]]);\n            }\n        }\n        return fieldList;\n    }\n    \n    mod.iter_fields = function(node) {\n        return node._fields;\n    };\n    \n    var convertValue = function(value) {\n        if (value === null) {\n            return Sk.builtin.none.none$;\n        } else if (isSpecialPyAst(value)) {\n            var constructorName = functionName(value);\n            return Sk.misceval.callsim(mod[constructorName], constructorName, true);\n        } else if (typeof value == 'number') {\n            return Sk.builtin.assk$(value);\n        } else if (Array === value.constructor) {\n            var subvalues = [];\n            for (var j = 0; j < value.length; j += 1) {\n                var subvalue = value[j];\n                if (isSpecialPyAst(subvalue)) {\n                    var constructorName = functionName(subvalue);\n                    subvalue = Sk.misceval.callsim(mod[constructorName], constructorName, true);\n                    subvalues.push(subvalue);\n                } else if (isJsAst(subvalue)) {\n                    var constructorName = functionName(subvalue.constructor);\n                    subvalue = Sk.misceval.callsim(mod[constructorName], subvalue);\n                    subvalues.push(subvalue);\n                }\n                // No AST nodes have primitive list values, just\n                //  lists of AST nodes\n            }\n            return Sk.builtin.list(subvalues);\n        } else if (isJsAst(value)) {\n            var constructorName = functionName(value.constructor)\n            return Sk.misceval.callsim(mod[constructorName], value);\n        } else {// Else already a Python value\n            return value;\n        }\n    }\n    \n    var isJsAst = function(jsNode) {\n        return jsNode instanceof Object && \"_astname\" in jsNode;\n    }\n    var isSpecialPyAst = function(val) {\n        if (typeof val == \"function\") {\n            switch (functionName(val)) {\n                case \"Add\": case \"Add\": case \"Sub\": case \"Mult\": case \"Div\": \n                case \"Mod\": case \"Pow\": case \"LShift\": case \"RShift\": \n                case \"BitOr\": case \"BitXor\": case \"BitAnd\": case \"FloorDiv\":\n                case \"Store\": case \"Load\": case \"Del\": case \"Param\":\n                case \"And\": case \"Or\": case \"Xor\": case \"Not\":\n                case \"Invert\": case \"UAdd\": case \"USub\":\n                case \"Lt\": case \"Gt\": case \"LtE\": case \"GtE\":\n                case \"NotEq\": case \"Eq\": case \"Is\": case \"IsNot\":\n                case \"In\":  case \"NotIn\":\n                    return true;\n                default: return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    var isPyAst = function(pyValue) {\n        return Sk.misceval.isTrue(Sk.builtin.isinstance(pyValue, mod.AST));\n    };\n    var isPyList = function(pyValue) {\n        return Sk.misceval.isTrue(Sk.builtin.isinstance(pyValue, Sk.builtin.list));\n    };\n    \n    var iter_child_nodesJs = function(node) {\n        var fieldList = iter_fieldsJs(node);\n        var resultList = [];\n        for (var i = 0; i < fieldList.length; i += 1) {\n            var field = fieldList[i][0], value = fieldList[i][1];\n            if (value === null) {\n                continue;\n            }\n            if (\"_astname\" in value) {\n                resultList.push(value);\n            } else if (value.constructor === Array) {\n                for (var j = 0; j < value.length; j += 1) {\n                    var subvalue = value[j];\n                    if (\"_astname\" in subvalue) {\n                        resultList.push(subvalue);\n                    }\n                }\n            }\n        }\n        return resultList;\n    }\n    \n    // Python node\n    mod.iter_child_nodes = function(node) {\n        var fieldList = node._fields.v;\n        var childFields = [];\n        for (var i = 0; i < fieldList.length; i += 1) {\n            var field = Sk.ffi.remapToJs(fieldList[i].v[0]), \n                value = fieldList[i].v[1];\n            if (isSpecialPyAst(value)) {\n                childFields.push(value);\n            } else if (isPyAst(value)) {\n                childFields.push(value);\n            } else if (isPyList(value)) {\n                for (var j = 0; j < value.v.length; j += 1) {\n                    var subvalue = value.v[j];\n                    if (isPyAst(subvalue)) {\n                        childFields.push(subvalue);\n                    }\n                }\n            }\n        }\n        return Sk.builtin.list(childFields);\n    };\n    \n    /**\n     * Dump the tree in a pretty format\n    */\n    mod.dump = function(node, annotate_fields, include_attributes) {\n        // Confirm valid arguments\n        Sk.builtin.pyCheckArgs(\"dump\", arguments, 1, 3);\n        // node argument\n        if (!isPyAst(node)) {\n            throw new Sk.builtin.TypeError(\"expected AST, got \"+Sk.abstr.typeName(node));\n        }\n        // annotate_fields argument\n        if (annotate_fields === undefined) {\n            annotate_fields = true;\n        } else {\n            Sk.builtin.pyCheckType(\"annotate_fields\", \"boolean\", Sk.builtin.checkBool(annotate_fields));\n            annotate_fields = Sk.ffi.remapToJs(annotate_fields);\n        }\n        // include_attributes argument\n        if (include_attributes === undefined) {\n            include_attributes = true;\n        } else {\n            Sk.builtin.pyCheckType(\"include_attributes\", \"boolean\", Sk.builtin.checkBool(include_attributes));\n            include_attributes = Sk.ffi.remapToJs(include_attributes);\n        }\n        // recursive dump\n        var _format = function(node) {\n            if (isSpecialPyAst(node)) {\n                return functionName(node)+\"()\";\n            } else if (isPyAst(node)) {\n                var rv = node.jsNode._astname+\"(\";\n                var fieldList = node._fields.v;\n                var fieldArgs = [];\n                for (var i = 0; i < fieldList.length; i += 1) {\n                    var field = Sk.ffi.remapToJs(fieldList[i].v[0]), \n                        value = fieldList[i].v[1];\n                    value = _format(value);\n                    if (annotate_fields) {\n                        fieldArgs.push(field+\"=\"+value);\n                    } else {\n                        fieldArgs.push(value);\n                    }\n                }\n                var attributeList = node._attributes.v;\n                if (include_attributes) {\n                    for (var i = 0; i < attributeList.length; i += 1) {\n                        var field = Sk.ffi.remapToJs(attributeList[i]);\n                        var value = Sk.ffi.remapToJs(node.jsNode[field])\n                        fieldArgs.push(field+\"=\"+value);\n                    }\n                }\n                fieldArgs = fieldArgs.join(\", \");\n                return rv + fieldArgs + \")\";\n            } else if (isPyList(node)) {\n                var nodes = node.v.map(_format);\n                nodes = nodes.join(', ');\n                return \"[\"+nodes+\"]\";\n            } else {\n                return Sk.ffi.remapToJs(node.$r());\n            }\n        }\n        return Sk.ffi.remapToPy(_format(node, 0));\n    }\n\n    var depth = 0;\n    var NodeVisitor = function($gbl, $loc) {\n        // Takes in Python Nodes, not JS Nodes\n        $loc.visit = new Sk.builtin.func(function(self, node) {\n            depth += 1;\n            /** Visit a node. **/\n            //print(\" \".repeat(depth), \"VISIT\", node.jsNode._astname)\n            var method_name = 'visit_' + node.jsNode._astname;\n            //print(\" \".repeat(depth), \"I'm looking for\", method_name)\n            method_name = Sk.ffi.remapToPy(method_name)\n            method = Sk.builtin.getattr(self, method_name, $loc.generic_visit)\n            if (method.im_self) {\n                //print(method.im_func.func_code)\n                result = Sk.misceval.callsim(method, node);\n                depth -= 1;\n                return result;\n            }else {\n                result = Sk.misceval.callsim(method, self, node);\n                depth -= 1;\n                return result;\n            }\n            \n        });\n        // Takes in Python Nodes, not JS Nodes\n        $loc.generic_visit = new Sk.builtin.func(function(self, node) {\n            /** Called if no explicit visitor function exists for a node. **/\n            //print(\" \".repeat(depth), \"Generically checked\", node.astname)\n            var fieldList = mod.iter_fields(node).v;\n            for (var i = 0; i < fieldList.length; i += 1) {\n                var field = fieldList[i].v[0].v, value = fieldList[i].v[1];\n                if (value === null) {\n                    continue;\n                } else if (isPyList(value)) {\n                    for (var j = 0; j < value.v.length; j += 1) {\n                        var subvalue = value.v[j];\n                        if (isPyAst(subvalue)) {\n                            //print(self.visit)\n                            Sk.misceval.callsim(self.visit, self, subvalue);\n                        }\n                    }\n                } else if (isPyAst(value)) {\n                    //print(self.visit)\n                    Sk.misceval.callsim(self.visit, self, value);\n                }\n            }\n            return Sk.builtin.none.none$;\n        });\n    }\n    mod.NodeVisitor = Sk.misceval.buildClass(mod, NodeVisitor, \"NodeVisitor\", []);\n\n    // Python node\n    mod.walk = function(node) {\n        if (isSpecialPyAst(node)) {\n            return Sk.builtin.list([]);\n        }\n        var resultList = [node];\n        var childList = mod.iter_child_nodes(node);\n        for (var i = 0; i < childList.v.length; i += 1) {\n            var child = childList.v[i];\n            var children = mod.walk(child);\n            resultList = resultList.concat(children.v);\n        }\n        return Sk.builtin.list(resultList);\n    }\n\n    /*NodeVisitor.prototype.visitList = function(nodes) {\n        for (var j = 0; j < nodes.length; j += 1) {\n            var node = nodes[j];\n            if (\"_astname\" in node) {\n                this.visit(node);\n            }\n        }\n    }\n\n    NodeVisitor.prototype.recursive_walk = function(node) {\n        var todo = [node];\n        var result = [];\n        while (todo.length > 0) {\n            node = todo.shift();\n            todo = todo.concat(iter_child_nodes(node))\n            result.push(node);\n        }\n        return result;\n    }*/\n    \n    var depth = 0;\n    AST = function($gbl, $loc) {\n        var copyFromJsNode = function(self, key, jsNode) {\n            if (key in self.jsNode) {\n                Sk.abstr.sattr(self, key, Sk.ffi.remapToPy(jsNode[key]), true);\n                self._attributes.push(Sk.builtin.str(key));\n            }\n        };\n        $loc.__init__ = new Sk.builtin.func(function (self, jsNode, partial) {\n            depth+=1;\n            if (partial === true) {\n                // Alternative constructor for Skulpt's weird nodes\n                //print(\" \".repeat(depth)+\"S:\", jsNode);\n                self.jsNode = {'_astname': jsNode};\n                self.astname = jsNode;\n                self._fields = Sk.builtin.list([]);\n                self._attributes = Sk.builtin.list([]);\n                Sk.abstr.sattr(self, '_fields', self._fields, true);\n                Sk.abstr.sattr(self, '_attributes', self._attributes, true);\n            } else {\n                //print(\" \".repeat(depth)+\"P:\", jsNode._astname);\n                self.jsNode = jsNode;\n                self.astname = jsNode._astname;\n                var fieldListJs = iter_fieldsJs(jsNode);\n                self._fields = [];\n                self._attributes = [];\n                for (var i = 0; i < fieldListJs.length; i += 1) {\n                    var field = fieldListJs[i][0], value = fieldListJs[i][1];\n                    value = convertValue(value);\n                    Sk.abstr.sattr(self, field, value, true);\n                    self._fields.push(Sk.builtin.tuple([Sk.builtin.str(field), value]));\n                }\n                self._fields = Sk.builtin.list(self._fields)\n                Sk.abstr.sattr(self, '_fields', self._fields, true);\n                copyFromJsNode(self, 'lineno', self.jsNode);\n                copyFromJsNode(self, 'col_offset', self.jsNode);\n                copyFromJsNode(self, 'endlineno', self.jsNode);\n                copyFromJsNode(self, 'col_endoffset', self.jsNode);\n                self._attributes = Sk.builtin.list(self._attributes);\n                Sk.abstr.sattr(self, '_attributes', self._attributes, true);\n            }\n            depth -= 1;\n        });\n        $loc.__str__ = new Sk.builtin.func(function (self) {\n            return Sk.builtin.str(\"<_ast.\"+self.astname+\" object>\");\n        });\n        $loc.__repr__ = $loc.__str__;\n    }\n    mod.AST = Sk.misceval.buildClass(mod, AST, \"AST\", []);\n    \n    //mod.literal_eval\n    // Implementation wouldn't be hard, but it does require a lot of Skulpting\n    \n    mod.parse = function parse(source, filename) {\n        if (!(/\\S/.test(source))) {\n            return Sk.misceval.callsim(mod.Module, new Sk.INHERITANCE_MAP.mod[0]([]));\n        }\n        if (filename === undefined) {\n            filename = '<unknown>';\n        }\n        var parse = Sk.parse(filename, Sk.ffi.remapToJs(source));\n        ast = Sk.astFromParse(parse.cst, filename, parse.flags);\n        return Sk.misceval.callsim(mod.Module, ast);\n        // Walk tree and create nodes (lazily?)\n    }\n    \n    /*\n    mod.Module = function ($gbl, $loc) {\n        Sk.abstr.superConstructor(mod.OrderedDict, this, items);\n    }*/\n    \n    function functionName(fun) {\n        var ret = fun.toString();\n        ret = ret.substr('function '.length);\n        ret = ret.substr(0, ret.indexOf('('));\n        if (ret == \"In_\") {\n            ret = \"In\";\n        } else if (ret == 'Import_') {\n            ret = 'Import';\n        }\n        return ret;\n    }\n    \n    for (var base in Sk.INHERITANCE_MAP) {\n        var baseClass = function($gbl, $loc) { return this;};\n        mod[base] = Sk.misceval.buildClass(mod, baseClass, base, [mod.AST]);\n        for (var i=0; i < Sk.INHERITANCE_MAP[base].length; i++) {\n            var nodeType = Sk.INHERITANCE_MAP[base][i];\n            var nodeName = functionName(nodeType);\n            var nodeClass = function($gbl, $loc) { return this;};\n            mod[nodeName] = Sk.misceval.buildClass(mod, nodeClass, nodeName, [mod[base]])\n        }\n    }\n    \n    return mod;\n};", "src/lib/xmllib.py": "raise NotImplementedError(\"xmllib is not yet implemented in Skulpt\")\n", "src/lib/smtpd.py": "raise NotImplementedError(\"smtpd is not yet implemented in Skulpt\")\n", "src/lib/mutex.py": "raise NotImplementedError(\"mutex is not yet implemented in Skulpt\")\n", "src/lib/mailcap.py": "raise NotImplementedError(\"mailcap is not yet implemented in Skulpt\")\n", "src/lib/aifc.py": "raise NotImplementedError(\"aifc is not yet implemented in Skulpt\")\n", "src/lib/struct.py": "raise NotImplementedError(\"struct is not yet implemented in Skulpt\")\n", "src/lib/asynchat.py": "raise NotImplementedError(\"asynchat is not yet implemented in Skulpt\")\n", "src/lib/os2emxpath.py": "raise NotImplementedError(\"os2emxpath is not yet implemented in Skulpt\")\n", "src/lib/md5.py": "raise NotImplementedError(\"md5 is not yet implemented in Skulpt\")\n", "src/lib/document.js": "var $builtinmodule = function (name) {\n    var elementClass;\n    var mod = {};\n\n    mod.getElementById = new Sk.builtin.func(function (id) {\n        var result = document.getElementById(id.v);\n        if (result) {\n            return Sk.misceval.callsim(mod.Element, result);\n        }\n        return Sk.builtin.none.none$;\n    });\n\n    mod.createElement = new Sk.builtin.func(function (eName) {\n        var r = document.createElement(eName.v);\n        if (r) {\n            return Sk.misceval.callsim(mod.Element, r);\n        }\n    });\n\n\n    mod.getElementsByTagName = new Sk.builtin.func(function (tag) {\n        var r = document.getElementsByTagName(tag.v)\n        var reslist = [];\n        for (var i = r.length - 1; i >= 0; i--) {\n            reslist.push(Sk.misceval.callsim(mod.Element, r[i]))\n        }\n        return new Sk.builtin.list(reslist)\n    });\n\n    mod.getElementsByClassName = new Sk.builtin.func(function (cname) {\n        var r = document.getElementsByClassName(cname.v);\n        var reslist = [];\n        for (var i = 0; i < r.length; i++) {\n            reslist.push(Sk.misceval.callsim(mod.Element, r[i]));\n        }\n        ;\n        return new Sk.builtin.list(reslist);\n    });\n\n    mod.getElementsByName = new Sk.builtin.func(function (cname) {\n        var r = document.getElementsByName(cname.v);\n        var reslist = [];\n        for (var i = 0; i < r.length; i++) {\n            reslist.push(Sk.misceval.callsim(mod.Element, r[i]));\n        }\n        ;\n        return new Sk.builtin.list(reslist);\n    });\n\n    mod.currentDiv = new Sk.builtin.func(function () {\n        if (Sk.divid !== undefined) {\n            return new Sk.builtin.str(Sk.divid)\n        }\n        else {\n            throw new Sk.builtin.AttributeError(\"There is no value set for divid\");\n        }\n    })\n\n    elementClass = function ($gbl, $loc) {\n        /*\n         Notes:  self['$d'] is the dictionary used by the GenericGetAttr mechanism for an object.\n         for various reasons  if you create a class in Javascript and have self.xxxx instance\n         variables, you cannot say instance.xxx and get the value of the instance variable unless\n         it is stored in the self['$d'] object.  This seems like a duplication of storage to me\n         but that is how it works right now  (5/2013)\n\n         Writing your own __getattr__ is also an option but this gets very tricky when an attr is\n         a method...\n         */\n        $loc.__init__ = new Sk.builtin.func(function (self, elem) {\n            self.v = elem\n            self.innerHTML = elem.innerHTML\n            self.innerText = elem.innerText\n            if (elem.value !== undefined) {\n                self.value = elem.value\n                Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str('value'), new Sk.builtin.str(self.value))\n            }\n\n            if (elem.checked !== undefined) {\n                self.checked = elem.checked\n                Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str('checked'), new Sk.builtin.str(self.checked))\n            }\n\n            Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str('innerHTML'), new Sk.builtin.str(self.innerHTML))\n            Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str('innerText'), new Sk.builtin.str(self.innerText))\n\n        })\n\n        $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n        $loc.__setattr__ = new Sk.builtin.func(function (self, key, value) {\n            key = Sk.ffi.remapToJs(key);\n            if (key === 'innerHTML') {\n                self.innerHTML = value\n                self.v.innerHTML = value.v\n                Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str('innerHTML'), value)\n            }\n            if (key === 'innerText') {\n                self.innerText = value\n                self.v.innerText = value.v\n                Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str('innerText'), value)\n            }\n        });\n\n\n        $loc.appendChild = new Sk.builtin.func(function (self, ch) {\n            self.v.appendChild(ch.v);\n        });\n\n        $loc.removeChild = new Sk.builtin.func(function (self, node) {\n            self.v.removeChild(node.v)\n        })\n\n        // getCSS\n\n        $loc.getCSS = new Sk.builtin.func(function (self, key) {\n            return new Sk.builtin.str(self.v.style[key.v]);\n        });\n\n\n        $loc.setCSS = new Sk.builtin.func(function (self, attr, value) {\n            self.v.style[attr.v] = value.v\n\n        })\n\n        $loc.getAttribute = new Sk.builtin.func(function (self, key) {\n            var res = self.v.getAttribute(key.v)\n            if (res) {\n                return new Sk.builtin.str(res)\n            } else {\n                return Sk.builtin.none.none$;\n            }\n        });\n\n        $loc.setAttribute = new Sk.builtin.func(function (self, attr, value) {\n            self.v.setAttribute(attr.v, value.v)\n        });\n\n        $loc.getProperty = new Sk.builtin.func(function (self, key) {\n            var res = self.v[key.v]\n            if (res) {\n                return new Sk.builtin.str(res)\n            } else {\n                return Sk.builtin.none.none$;\n            }\n        });\n\n        $loc.__str__ = new Sk.builtin.func(function (self) {\n            console.log(self.v.tagName);\n            return new Sk.builtin.str(self.v.tagName)\n        })\n\n        $loc.__repr__ = new Sk.builtin.func(function (self) {\n            return new Sk.builtin.str('[DOM Element]')\n        })\n\n\n    };\n\n    mod.Element = Sk.misceval.buildClass(mod, elementClass, 'Element', []);\n\n    return mod;\n\n}\n", "src/lib/sre_parse.py": "raise NotImplementedError(\"sre_parse is not yet implemented in Skulpt\")\n", "src/lib/cookielib.py": "raise NotImplementedError(\"cookielib is not yet implemented in Skulpt\")\n", "src/lib/dbhash.py": "raise NotImplementedError(\"dbhash is not yet implemented in Skulpt\")\n", "src/lib/abc.py": "raise NotImplementedError(\"abc is not yet implemented in Skulpt\")\n", "src/lib/runpy.py": "raise NotImplementedError(\"runpy is not yet implemented in Skulpt\")\n", "src/lib/lib-dynload/__init__.py": "raise NotImplementedError(\"lib-dynload is not yet implemented in Skulpt\")\n", "src/lib/encodings/__init__.py": "raise NotImplementedError(\"encodings is not yet implemented in Skulpt\")\n", "src/lib/cisc108/__init__.py": "from cisc108.assertions import assert_equal, QUIET, student_tests\n", "src/lib/cisc108/assertions.py": "'''\nCISC106 Module that includes some basic helper functions such as assert_equal().\n\nVersions:\n0.2.1 - 2019-JAN-23, Austin Cory Bart\n + Keep track of tests' counts in student_tests\n + Improve make_type_name for BlockPy compatibility\n0.2 - 2019-JAN-02, Modified by Austin Cory Bart\n + Renamed functions to be in line with common Python convention\n + Packaged into an actual library on PyPI, with tests and stuff.\n + Replaced type(X) checks with isinstance\n + Changed string interpolation to .format\n + Extracted out string messages\n0.142 - 2014-APR-23, Modified by Jon Leighton\n + Modified success and failure messages to print \"SUCCESS\" and \"FAILURE\" at the\n   beginning of each result. This makes it much easier to quickly discern the\n   outcome visually.\n0.141 - 2014-MAR-26, Modified by Jon Leighton\n + Removed unused function print_verbose().\n + Appended text to FAILURE message for incompatible types to indicate that types\n   involved can't be compared.\n0.14 - 2014-MAR-26, Modified by Andrew Roosen\n + Modified assert_equal() to return False on failure and True on success.\n + Introduced QUITE option to supress output on SUCCESS.\n + Modified FAILURE message for incompatible data types to be consistent with\n + FAILURE message for unequal values.\n + Modified names of internal functions isEqual() and isseqtype() to _is_equal()\n   and _is_seq_type(), respectively\n0.13 - 2014-MAR-25, Modified by Jon Leighton\n + added elif clause to _is_equal(), to avoid comparing ints and floats to anything\n   that is not an int or a float, and to return None in this case. The previous\n   comparison tried to subtract these quantities from each other, causing a\n   runtime error.\n + Modified assert_equal() to check for _is_equal() returning None, which now\n   indicates an attempt to compare unrelated data types. Failure message is\n   modified in this case to report the attempt to compare unrelated types.\n + Removed unused global variables fail and success.\n + Added version numbers to Paul Amer's modifications, and bumped version number to\n   reflect my modifications.\n + Changed version number to string, to match recommended practice.\n0.122 - 2012-APR-17, Modified by Paul Amer\n + removed graphics stuff; just kept assert_equal\n0.121 - 2011-SEP-08, Modified by Paul Amer\n +improved success-failure messages\n0.12\n + display can be called multiple times\n + assert_equal supports PIL.Image.Image\n0.1\n + Initial assert_equal, display, animate, bind\n'''\n__version__ = '0.2.1'\n\n# Number encapsulates bool, int, float, complex, decimal.Decimal, etc.\ntry:\n    from numbers import Number\nexcept:\n    Number = (bool, int, float, complex)\n    \ntry:\n    bytes\nexcept NameError:\n    bytes = str\n\ntry:\n    frozenset()\nexcept:\n    frozenset = tuple()\n    \ndef make_type_name(value):\n    try:\n        return type(value).__name__\n    except Exception:\n        return str(type(value))[8:-2]\n\ndef get_line_code():\n    # Load in extract_stack, or provide shim for environments without it.\n    try:\n        from traceback import extract_stack\n        trace = extract_stack()\n        frame = trace[len(trace) - 3]\n        line = frame[1]\n        code = frame[3]\n        return line, code\n    except Exception:\n        return None, None\n\n\n# Don't print message from assert_equal on success\nQUIET = False\n\nSET_GENERATOR_TYPES = (type({}.keys()), type({}.values()), type({}.items()))\n\nLIST_GENERATOR_TYPES = (type(map(bool, [])), type(filter(bool, [])),\n                        type(range(0)), type(reversed([])), type(zip()),\n                        type(enumerate([])))\n\nMESSAGE_LINE_CODE = \" - [line {line}] {code}\"\nMESSAGE_UNRELATED_TYPES = (\n    \"FAILURE{context}, predicted answer was {y!r} ({y_type!r}), \"\n    \"computed answer was {x!r} ({x_type!r}). \"\n    \"You attempted to compare unrelated data types.\")\nMESSAGE_GENERIC_FAILURE = (\n    \"FAILURE{context}, predicted answer was {y!r}, \"\n    \"computed answer was {x!r}.\")\nMESSAGE_GENERIC_SUCCESS = (\n    \"TEST PASSED{context}\")\n\nclass StudentTestReport:\n    def __init__(self):\n        self.reset()\n    def __repr__(self):\n        return str(self)\n    def __str__(self):\n        return ('<failures={failures}'\n                ',successes={successes}'\n                ',tests={tests},lines={lines}>'\n        ).format(\n            failures=self.failures, successes=self.successes, tests=self.tests,\n            lines=', '.join(self.lines)\n        )\n    def reset(self):\n        self.failures = 0\n        self.successes = 0\n        self.tests = 0\n        self.lines = []\n    \nstudent_tests = StudentTestReport()\n\ndef assert_equal(x, y, precision=4, exact_strings=False, *args):\n    \"\"\"\n    Checks an expected value using the _is_equal function.\n    Prints a message if the test case passed or failed.\n\n    Args:\n        x (Any): Any kind of python value. Should have been computed by\n            the students' code (their actual answer).\n        y (Any): Any kind of python value. The expected value to be produced,\n            precalculated (their expected answer).\n        precision (int): Optional. Indicates how many decimal places to use\n            when comparing floating point values.\n        exact_strings (bool): Whether or not strings should be matched perfectly\n            character-by-character, or if you should ignore capitalization,\n            whitespace, and symbols.\n    Returns:\n        bool: Whether or not the assertion passed.\n    \"\"\"\n\n    # Can we add in the line number and code?\n    line, code = get_line_code()\n    if None in (line, code):\n        context = \"\"\n    else:\n        context = MESSAGE_LINE_CODE.format(line=line, code=code)\n        student_tests.lines.append(line)\n\n    result = _is_equal(x, y, precision, exact_strings, *args)\n    student_tests.tests += 1\n    if result is None:\n        student_tests.failures += 1\n        print(MESSAGE_UNRELATED_TYPES.format(context=context,\n                                             x=repr(x), x_type=make_type_name(x),\n                                             y=repr(y), y_type=make_type_name(y)))\n        return False\n    elif not result:\n        student_tests.failures += 1\n        print(MESSAGE_GENERIC_FAILURE.format(context=context, x=repr(x), y=repr(y)))\n        return False\n    elif not QUIET:\n        print(MESSAGE_GENERIC_SUCCESS.format(context=context))\n    student_tests.successes += 1\n    return True\n\n# Hack to allow anyone with an assert_equal reference to get the results\n#   since they are global across all calls. Weird strategy!\nassert_equal.student_tests = student_tests\n\ndef _is_equal(x, y, precision, exact_strings, *args):\n    \"\"\"\n    _is_equal : thing thing -> boolean\n    _is_equal : number number number -> boolean\n    Determines whether the two arguments are equal, or in the case of\n    floating point numbers, within a specified number of decimal points\n    precision (by default, checks to with 4 decimal points for floating\n    point numbers). Returns None when attempting to compare ints and floats\n    to anything other than ints and floats.\n\n    Examples:\n    >>> _is_equal('ab', 'a'+'b')\n     True\n\n    >>> _is_equal(12.34, 12.35)\n     False\n\n    >>> _is_equal(12.3456, 12.34568, 4)\n     True\n\n    >>> _is_equal(12.3456, 12.34568w5)\n     False\n    \"\"\"\n    \n    # Check if generators\n    if isinstance(x, SET_GENERATOR_TYPES):\n        x = set(x)\n    elif isinstance(x, LIST_GENERATOR_TYPES):\n        x = list(x)\n    if isinstance(y, SET_GENERATOR_TYPES):\n        y = set(y)\n    elif isinstance(y, LIST_GENERATOR_TYPES):\n        y = list(y)\n    \n    if isinstance(x, float) and isinstance(y, float):\n        error = 10 ** (-precision)\n        return abs(x - y) < error\n    elif isinstance(x, Number) and isinstance(y, Number) and isinstance(x, type(y)):\n        return x == y\n    elif ((isinstance(x, str) and isinstance(y, str)) or\n          (isinstance(x, bytes) and isinstance(y, bytes))):\n        if exact_strings:\n            return x == y\n        else:\n            return _normalize_string(x) == _normalize_string(y)\n    elif isinstance(x, list) and isinstance(y, list):\n        return _are_sequences_equal(x, y, precision, exact_strings)\n    elif isinstance(x, tuple) and isinstance(y, tuple):\n        return _are_sequences_equal(x, y, precision, exact_strings)\n    elif isinstance(x, set) and isinstance(y, set):\n        return _are_sets_equal(x, y, precision, exact_strings)\n    elif isinstance(x, frozenset) and isinstance(y, frozenset):\n        return _are_sets_equal(x, y, precision, exact_strings)\n    elif isinstance(x, dict) and isinstance(y, dict):\n        primary_keys = set(x.keys())\n        if not _are_sets_equal(primary_keys, set(y.keys()),\n                               precision, exact_strings):\n            return False\n        for key in primary_keys:\n            if not _is_equal(x[key], y[key], precision, exact_strings):\n                return False\n        return True\n    elif not isinstance(x, type(y)):\n        return None\n    else:\n        return x == y\n\n\ndef _normalize_string(text):\n    '''\n    For strings:\n    - strips whitespace from each line\n    - lower cases\n    '''\n    # Lowercase\n    text = text.lower()\n    # Strip whitespace from each line\n    lines = text.split(\"\\n\")\n    lines = [line.strip() for line in lines if line.strip()]\n    text = \"\\n\".join(lines)\n    # Return result\n    return text\n\n\ndef _are_sequences_equal(x, y, precision, exact_strings):\n    '''\n    For sequences that support __len__, __iter__, and should have the same\n    order.\n    '''\n    if len(x) != len(y):\n        return False\n    for x_element, y_element in zip(x, y):\n        if not _is_equal(x_element, y_element, precision, exact_strings):\n            return False\n    return True\n\n\ndef _set_contains(needle, haystack, precision, exact_strings):\n    '''\n    Tests if the given needle is one of the elements of haystack, using\n    the _is_equal function.\n    '''\n    for element in haystack:\n        if _is_equal(element, needle, precision, exact_strings):\n            return True\n    return False\n\n\ndef _are_sets_equal(x, y, precision, exact_strings):\n    '''\n    For sequences that support __len__, __iter__, but order does not matter.\n    '''\n    if len(x) != len(y):\n        return False\n    for x_element in x:\n        if not _set_contains(x_element, y, precision, exact_strings):\n            return False\n    return True\n", "src/lib/distutils/__init__.py": "raise NotImplementedError(\"distutils is not yet implemented in Skulpt\")\n", "src/lib/distutils/tests/__init__.py": "raise NotImplementedError(\"tests is not yet implemented in Skulpt\")\n", "src/lib/distutils/command/__init__.py": "raise NotImplementedError(\"command is not yet implemented in Skulpt\")\n", "src/lib/lib-tk/__init__.py": "raise NotImplementedError(\"lib-tk is not yet implemented in Skulpt\")\n", "src/lib/ctypes/__init__.py": "raise NotImplementedError(\"ctypes is not yet implemented in Skulpt\")\n", "src/lib/ctypes/macholib/__init__.py": "raise NotImplementedError(\"macholib is not yet implemented in Skulpt\")\n", "src/lib/unittest/__init__.py": "__author__ = 'bmiller'\n'''\nThis is the start of something that behaves like\nthe unittest module from cpython.\n\n'''\n\nclass TestCase:\n    def __init__(self):\n        self.numPassed = 0\n        self.numFailed = 0\n        self.assertPassed = 0\n        self.assertFailed = 0\n        self.verbosity = 1\n        self.tlist = []\n        testNames = {}\n        for name in dir(self):\n            if name[:4] == 'test' and name not in testNames:\n                self.tlist.append(getattr(self,name))\n                testNames[name]=True\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n    \n    def cleanName(self,funcName):\n    # work around skulpts lack of an __name__\n        funcName = str(funcName)\n        funcName = funcName[13:]\n        funcName = funcName[:funcName.find('<')-3]\n        return funcName\n\n    def main(self):\n\n        for func in self.tlist:\n            if self.verbosity > 1:\n                print('Running %s' % self.cleanName(func))\n            try:\n                self.setUp()\n                self.assertPassed = 0\n                self.assertFailed = 0\n                func()\n                self.tearDown()\n                if self.assertFailed == 0:\n                    self.numPassed += 1\n                else:\n                    self.numFailed += 1\n                    print('Tests failed in %s ' % self.cleanName(func))\n            except Exception as e:\n                self.assertFailed += 1\n                self.numFailed += 1\n                print('Test threw exception in %s (%s)' % (self.cleanName(func), e))\n        self.showSummary()\n\n    def assertEqual(self, actual, expected, feedback=\"\"):\n        res = actual==expected\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to equal %s\" % (str(actual),str(expected))\n        self.appendResult(res, actual ,expected, feedback)\n\n    def assertNotEqual(self, actual, expected, feedback=\"\"):\n        res = actual != expected\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not equal %s\" % (str(actual),str(expected))\n        self.appendResult(res, actual, expected, feedback)\n\n    def assertTrue(self,x, feedback=\"\"):\n        res = bool(x) is True\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be True\" % (str(x))\n        self.appendResult(res, x, True, feedback)\n\n    def assertFalse(self,x, feedback=\"\"):\n        res = not bool(x)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be False\" % (str(x))\n        self.appendResult(res, x, False, feedback)\n\n    def assertIs(self,a,b, feedback=\"\"):\n        res = a is b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be the same object as %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsNot(self,a,b, feedback=\"\"):\n        res = a is not b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be the same object as %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsNone(self,x, feedback=\"\"):\n        res = x is None\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be None\" % (str(x))\n        self.appendResult(res, x, None, feedback)\n\n    def assertIsNotNone(self,x, feedback=\"\"):\n        res = x is not None\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be None\" % (str(x))\n        self.appendResult(res, x, None, feedback)\n\n    def assertIn(self, a, b, feedback=\"\"):\n        res = a in b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be in %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotIn(self, a, b, feedback=\"\"):\n        res = a not in b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be in %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsInstance(self,a,b, feedback=\"\"):\n        res = isinstance(a,b)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be an instance of %s\" % (str(a), str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotIsInstance(self,a,b, feedback=\"\"):\n        res = not isinstance(a,b)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be an instance of %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertAlmostEqual(self, a, b, places=7, feedback=\"\", delta=None):\n\n        if delta is not None:\n            res = abs(a-b) <= delta\n        else:\n            if places is None:\n                places = 7\n            res = round(a-b, places) == 0\n        \n        if not res and feedback == \"\":\n            feedback = \"Expected %s to equal %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotAlmostEqual(self, a, b, places=7, feedback=\"\", delta=None):\n\n        if delta is not None:\n            res = not (a == b) and abs(a - b) > delta\n        else:\n            if places is None:\n                places = 7\n            res = round(a-b, places) != 0\n\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not equal %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n\n    def assertGreater(self,a,b, feedback=\"\"):\n        res = a > b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be greater than %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertGreaterEqual(self,a,b, feedback=\"\"):\n        res = a >= b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be >= %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertLess(self, a, b, feedback=\"\"):\n        res = a < b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be less than %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertLessEqual(self,a,b, feedback=\"\"):\n        res = a <= b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be <= %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def appendResult(self,res,actual,expected,feedback):\n        if res:\n            msg = 'Pass'\n            self.assertPassed += 1\n        else:\n            msg = 'Fail: ' +  feedback\n            print(msg)\n            self.assertFailed += 1\n\n    def assertRaises(self, exception, callable=None, *args, **kwds):\n        # with is currently not supported hence we just try and catch\n        if callable is None:\n            raise NotImplementedError(\"assertRaises does currently not support assert contexts\")\n        if kwds:\n            raise NotImplementedError(\"assertRaises does currently not support **kwds\")\n\n        res = False\n        actualerror = str(exception())\n        try:\n            callable(*args)\n        except exception as ex:\n            res = True\n        except Exception as inst:\n            actualerror = str(inst)\n            print(\"ACT = \", actualerror, str(exception()))\n        else:\n            actualerror = \"No Error\"\n\n        self.appendResult(res, str(exception()), actualerror, \"\")\n\n    def fail(self, msg=None):\n        if msg is None:\n            msg = 'Fail'\n        else:\n            msg = 'Fail: ' + msg\n        print(msg)\n        self.assertFailed += 1\n\n    def showSummary(self):\n        pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n        print(\"Ran %d tests, passed: %d failed: %d\\n\" % (self.numPassed+self.numFailed,\n                                               self.numPassed, self.numFailed))\n\n\n\ndef main(verbosity=1):\n    glob = globals() # globals() still needs work\n    for name in glob:\n        if issubclass(glob[name],TestCase):\n            try:\n                tc = glob[name]()\n                tc.verbosity = verbosity\n                tc.main()\n            except:\n                print(\"Uncaught Error in: \", name)\n", "src/lib/unittest/gui.py": "import document\nfrom unittest import TestCase\n\nclass TestCaseGui(TestCase):\n     def __init__(self):\n          TestCase.__init__(self)\n          self.divid = document.currentDiv()\n          self.mydiv = document.getElementById(self.divid)\n          res = document.getElementById(self.divid+'_unit_results')\n          if res:\n              self.resdiv = res\n              res.innerHTML = ''\n          else:\n              self.resdiv = document.createElement('div')\n              self.resdiv.setAttribute('id',self.divid+'_unit_results')\n              self.resdiv.setAttribute('class','unittest-results')\n              self.mydiv.appendChild(self.resdiv)\n\n\n     def main(self):\n         t = document.createElement('table')\n         self.resTable = t\n         self.resdiv.appendChild(self.resTable)\n\n         headers = ['Result','Actual Value','Expected Value','Notes']\n         row = document.createElement('tr')\n         for item in headers:\n             head = document.createElement('th')\n             head.setAttribute('class','ac-feedback')\n             head.innerHTML = item\n             head.setCSS('text-align','center')\n             row.appendChild(head)\n         self.resTable.appendChild(row)\n\n         for func in self.tlist:\n             try:\n                 self.setUp()\n                 func()\n                 self.tearDown()\n             except Exception as e:\n                 self.appendResult('Error', None, None, e)\n                 self.numFailed += 1\n                 self.showSummary()\n\n     def appendResult(self,res,actual,expected,param):\n         trimActual = False\n         if len(str(actual)) > 15:\n             trimActual = True\n             actualType = type(actual)\n         trimExpected = False\n         if len(str(expected)) > 15:\n             trimExpected = True\n             expectedType = type(expected)\n         row = document.createElement('tr')\n         err = False\n         if res == 'Error':\n             err = True\n             msg = 'Error: %s' % param\n             errorData = document.createElement('td')\n             errorData.setAttribute('class','ac-feedback')\n             errorData.innerHTML = 'ERROR'\n             errorData.setCSS('background-color','#de8e96')\n             errorData.setCSS('text-align','center')\n             row.appendChild(errorData)\n         elif res:\n             passed = document.createElement('td')\n             passed.setAttribute('class','ac-feedback')\n             passed.innerHTML = 'Pass'\n             passed.setCSS('background-color','#83d382')\n             passed.setCSS('text-align','center')\n             row.appendChild(passed)\n             self.numPassed += 1\n         else:\n             fail = document.createElement('td')\n             fail.setAttribute('class','ac-feedback')\n             fail.innerHTML = 'Fail'\n             fail.setCSS('background-color','#de8e96')\n             fail.setCSS('text-align','center')\n             row.appendChild(fail)\n             self.numFailed += 1\n\n\n         act = document.createElement('td')\n         act.setAttribute('class','ac-feedback')\n         if trimActual:\n             actHTML = str(actual)[:5] + \"...\" + str(actual)[-5:]\n             if actualType == str:\n                 actHTML = repr(actHTML)\n             act.innerHTML = actHTML\n         else:\n             act.innerHTML = repr(actual)\n         act.setCSS('text-align','center')\n         row.appendChild(act)\n\n         expect = document.createElement('td')\n         expect.setAttribute('class','ac-feedback')\n\n         if trimExpected:\n             expectedHTML = str(expected)[:5] + \"...\" + str(expected)[-5:]\n             if expectedType == str:\n                 expectedHTML = repr(expectedHTML)\n             expect.innerHTML = expectedHTML\n         else:\n             expect.innerHTML = repr(expected)\n         expect.setCSS('text-align','center')\n         row.appendChild(expect)\n         inp = document.createElement('td')\n         inp.setAttribute('class','ac-feedback')\n\n         if err:\n             inp.innerHTML = msg\n         else:\n             inp.innerHTML = param\n         inp.setCSS('text-align','center')\n         row.appendChild(inp)\n         self.resTable.appendChild(row)\n\n\n     def showSummary(self):\n         pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n         pTag = document.createElement('p')\n         pTag.innerHTML = \"You passed: \" + str(pct) + \"% of the tests\"\n         self.resdiv.appendChild(pTag)\n", "src/lib/curses/__init__.py": "raise NotImplementedError(\"curses is not yet implemented in Skulpt\")\n", "src/lib/test/test_support.py": "\"\"\"Supporting definitions for the Python regression tests.\"\"\"\n\nif __name__ != 'test.test_support':\n    raise ImportError('test_support must be imported from the test package')\n\nimport unittest\n\n\n# def run_unittest(*classes):\n#     \"\"\"Run tests from unittest.TestCase-derived classes.\"\"\"\n#     valid_types = (unittest.TestSuite, unittest.TestCase)\n#     suite = unittest.TestSuite()\n#     for cls in classes:\n#         if isinstance(cls, str):\n#             if cls in sys.modules:\n#                 suite.addTest(unittest.findTestCases(sys.modules[cls]))\n#             else:\n#                 raise ValueError(\"str arguments must be keys in sys.modules\")\n#         elif isinstance(cls, valid_types):\n#             suite.addTest(cls)\n#         else:\n#             suite.addTest(unittest.makeSuite(cls))\n#     _run_suite(suite)\n\ndef run_unittest(*classes):\n    \"\"\"Run tests from unittest.TestCase-derived classes.\"\"\"\n    for cls in classes:\n        print cls\n        if issubclass(cls, unittest.TestCase):\n            cls().main()\n        else:\n            print \"Don't know what to do with \", cls\n", "src/lib/test/__init__.py": "__author__ = 'bmiller'\n\ndef testEqual(actual, expected):\n    if type(expected) == type(1):\n        if actual == expected:\n            print('Pass')\n            return True\n    elif type(expected) == type(1.11):\n        if abs(actual-expected) < 0.00001:\n            print('Pass')\n            return True\n    else:\n        if actual == expected:\n            print('Pass')\n            return True\n    print('Test Failed: expected ' + str(expected) + ' but got ' + str(actual))\n    return False\n\ndef testNotEqual(actual, expected):\n    pass\n\n", "src/lib/test/decimaltestdata/__init__.py": "raise NotImplementedError(\"decimaltestdata is not yet implemented in Skulpt\")\n", "src/lib/config/__init__.py": "raise NotImplementedError(\"config is not yet implemented in Skulpt\")\n", "src/lib/hotshot/__init__.py": "raise NotImplementedError(\"hotshot is not yet implemented in Skulpt\")\n", "src/lib/pedal/__init__.py": "\"\"\"\nA package for analyzing student code.\n\"\"\"\n\n# Probably want to import useful stuff from:\n#   report\n#   source\n#   sandbox\n#   tifa\n#   cait\n#   resolver\n#   etc.\n\nfrom pedal.cait import (find_match, find_matches,\n                        parse_program,\n                        find_submatches, find_expr_sub_matches,\n                        def_use_error, data_state, data_type,\n                        expire_cait_cache)\nfrom pedal.report.imperative import (suppress, explain, compliment,\n                                     give_partial, gently, set_success)\nfrom pedal.sandbox.sandbox import run, reset\nfrom pedal.tifa import tifa_analysis\nfrom pedal.source import (set_source, check_section_exists, next_section,\n                          set_source_file)\n", "src/lib/pedal/cait_old/stretchy_tree_matching.py": "import ast\nimport re\nfrom pedal.cait_old.ast_map import *\nfrom pedal.cait_old.easy_node import *\n\n\ndef is_primitive(item):\n    return isinstance(item, (int, float, str, bool)) or item is None\n\n\nclass StretchyTreeMatcher:\n    def __init__(self, code, filename=\"__main__\"):\n        if isinstance(code, str):\n            ast_node = ast.parse(code, filename)\n        else:\n            ast_node = code\n        if ast_node is None:\n            self.rootNode = None\n        elif isinstance(ast_node, EasyNode):\n            self.rootNode = ast_node\n        else:\n            self.rootNode = EasyNode(ast_node, \"none\")\n\n    def find_matches(self, other, filename=\"__main__\", check_meta=True):\n        if isinstance(other, str):\n            other_tree = ast.parse(other, filename)\n        else:\n            other_tree = other\n        if isinstance(other_tree, EasyNode):\n            easy_other = other_tree\n        else:\n            easy_other = EasyNode(other_tree, \"none\")\n        explore_root = self.rootNode\n        if self.rootNode is not None:\n            while (len(explore_root.children) == 1 and\n                   explore_root.ast_name in [\"Expr\", \"Module\"]):\n                explore_root = explore_root.children[0]\n                explore_root.field = \"none\"\n        # return self.any_node_match(self.rootNode, easy_other, check_meta=check_meta)\n        return self.any_node_match(explore_root, easy_other, check_meta=check_meta)\n\n    '''\n    Finds whether ins_node can be matched to some node in the tree std_node\n    @return a mapping of nodes and a symbol table mapping ins_node to some node in the tree std_node or False if such a \n    matching does not exist\n    '''\n\n    def any_node_match(self, ins_node, std_node, check_meta=True, cut=False):\n        # @TODO: create a more public function that converts ins_node and std_node into EasyNodes\n        # TODO: Create exhaustive any_node_match\n        # matching: an object representing the mapping and the symbol table\n        matching = self.deep_find_match(ins_node, std_node, check_meta)\n        # if a direct matching is found\n        if matching:\n            for match in matching:\n                match.match_root = std_node\n                if len(match.mappings.values) > 1:\n                    match.match_lineno = match.mappings.values[1].lineno\n                else:\n                    match.match_lineno = match.mappings.values[0].lineno\n        else:\n            matching = []\n        #    return matching  # return it\n        # if not matching or exhaust:  # otherwise\n        # try to matching ins_node to each child of std_node, recursively\n        for std_child in std_node.children:\n            matching_c = self.any_node_match(ins_node, std_child, check_meta=check_meta, cut=cut)\n            if matching_c:\n                for match in matching_c:\n                    match.match_root = std_child\n                    if len(match.mappings.values) > 1:\n                        match.match_lineno = match.mappings.values[1].lineno\n                    else:\n                        match.match_lineno = match.mappings.values[0].lineno\n                # return matching\n                matching = matching + matching_c\n        if len(matching) > 0:\n            return matching\n        return False\n\n    def deep_find_match(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        Finds whether ins_node and matches std_node and whether ins_node's children flexibly match std_node's children\n        in order\n        :param ins_node: The instructor ast that should be included in the student AST\n        :param std_node: The student AST that we are searching for the included tree\n        :param check_meta: Flag, if True, check whether the two nodes originated from the same ast field\n        :return: a mapping of nodes and a symbol table mapping ins_node to std_node, or False if no mapping was found\n        \"\"\"\n        method_name = \"deep_find_match_\" + type(ins_node.astNode).__name__\n        target_func = getattr(self, method_name, self.deep_find_match_generic)\n        return target_func(ins_node, std_node, check_meta)\n\n    # noinspection PyPep8Naming\n    def deep_find_match_Name(self, ins_node, std_node, check_meta=True):\n        name_id = ins_node.astNode.id\n        var_match = re.compile('^_[^_].*_$')  # /regex\n        exp_match = re.compile('^__.*__$')  # /regex\n        wild_card = re.compile('^___$')  # /regex\n        mapping = AstMap()\n        matched = False\n        meta_matched = self.metas_match(ins_node, std_node, check_meta)\n        if var_match.match(name_id) and meta_matched:  # if variable\n            # This if body is probably unnecessary.\n            if type(std_node.astNode).__name__ == \"Name\":\n                return self.deep_find_match_generic(ins_node, std_node, check_meta)\n        # could else return False, but shallow_match_generic should do this as well\n        elif exp_match.match(name_id):  # and meta_matched:  # if expression\n            # terminate recursion, the whole subtree should match since expression nodes match to anything\n            mapping.add_exp_to_sym_table(ins_node, std_node)\n            matched = True\n        elif wild_card.match(name_id) and meta_matched:  # if wild card, don't care\n            # terminate the recursion, the whole subtree should match since wild cards match to anything\n            matched = True\n\n        if matched:\n            mapping.add_node_pairing(ins_node, std_node)\n            return [mapping]\n        # else\n        return self.deep_find_match_generic(ins_node, std_node, check_meta)\n\n    # noinspection PyPep8Naming\n    def deep_find_match_BinOp(self, ins_node, std_node, check_meta=True):\n        op = ins_node.astNode.op\n        op = type(op).__name__\n        is_generic = not (op == \"Mult\" or op == \"Add\")\n        if is_generic:\n            return self.deep_find_match_generic(ins_node, std_node, check_meta)\n        else:  # this means that the node is clearly commutative\n            return self.deep_find_match_binflex(ins_node, std_node, False)\n\n    # noinspection PyMethodMayBeStatic\n    def binflex_helper(self, case_left, case_right, new_mappings, base_mappings):\n        \"\"\"\n        adds to new_mappings (return/modify by argument) the mappings for both the left and right subtrees as denoted by\n        case_left and case_right\n        :param case_left: The mappings for the left opperand\n        :param case_right: The mappings for the right opperand\n        :param new_mappings: The new set of mappings to generate\n        :param base_mappings: The original mappings of the binop node\n        \"\"\"\n        if case_left and case_right:\n            for case_l in case_left:\n                new_map = base_mappings[0].new_merged_map(case_l)\n                for case_r in case_right:\n                    both = new_map.new_merged_map(case_r)\n                    if not both.has_conflicts():\n                        new_mappings.append(both)\n\n    def deep_find_match_binflex(self, ins_node, std_node, check_meta=False):\n        base_mappings = self.shallow_match(ins_node, std_node, check_meta)\n        if not base_mappings:\n            return False\n        op_mappings = self.shallow_match(ins_node.children[1], std_node.children[1], check_meta=True)\n        if not op_mappings:\n            return False\n        base_mappings = [base_mappings[0].new_merged_map(op_mappings[0])]\n\n        if base_mappings:\n            ins_left = ins_node.children[0]  # instructor left ast node\n            ins_right = ins_node.children[2]  # instructor right ast node\n            std_left = std_node.children[0]  # student left ast node\n            std_right = std_node.children[2]  # student right ast node\n            new_mappings = []\n            # case 1: ins_left->std_left and ins_right->std_right\n            case_left = self.deep_find_match(ins_left, std_left, False)\n            case_right = self.deep_find_match(ins_right, std_right, False)\n            self.binflex_helper(case_left, case_right, new_mappings, base_mappings)\n            # case 2: ins_left->std_right and ins_right->std_left\n            case_left = self.deep_find_match(ins_left, std_right, False)\n            case_right = self.deep_find_match(ins_right, std_left, False)\n            self.binflex_helper(case_left, case_right, new_mappings, base_mappings)\n            if len(new_mappings) == 0:\n                return False\n            return new_mappings\n        return False\n\n    def deep_find_match_Expr(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        An Expression node (not to be confused with expressions denoted by the instructor nodes in Name ast nodes)\n        checks whether it should be generic, or not\n        :param ins_node: Instructor ast to find in the student ast\n        :param std_node: Student AST to search for the instructor ast in\n        :param check_meta: flag to check whether the fields of the instructor node and the student node should match\n        :return: a mapping between the instructor and student asts, or False if such a mapping doesn't exist\n        \"\"\"\n        # if check_meta and ins_node.field != std_node.field:\n        if not self.metas_match(ins_node, std_node, check_meta):\n            return False\n        mapping = AstMap()\n        value = ins_node.value\n        ast_type = type(value.astNode).__name__\n        if ast_type == \"Name\":\n            name_id = value.astNode.id\n            exp_match = re.compile('^__.*__$')  # /regex\n            wild_card = re.compile('^___$')  # /regex\n            matched = False\n            meta_matched = self.metas_match(ins_node, std_node, check_meta)\n            if exp_match.match(name_id):  # and meta_matched:  # if expression\n                # terminate recursion, the whole subtree should match since expression nodes match to anything\n                mapping.add_exp_to_sym_table(value, std_node)\n                matched = True\n            elif wild_card.match(name_id) and meta_matched:  # if wild card, don't care\n                # terminate the recursion, the whole subtree should match since wild cards match to anything\n                matched = True\n            if matched:\n                mapping.add_node_pairing(ins_node, std_node)\n                return [mapping]\n        return self.deep_find_match_generic(ins_node, std_node, check_meta)\n\n    def deep_find_match_generic(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        This first uses shallow match to find a base map (match) from which to build off. The algorithm then tracks\n        all the possible mappings that match a given child node in the instructor AST, keeping track of which siblings\n        have been visited.\n\n        For each instructor child, when all children of the student node have been iterated through recursively, a\n        helper function is called. This helper function determines which possible children validly can extend the base\n        match to create a set of new base maps through use of the indicies of the sibilings.\n\n        The process repeats itself until no matches can be grown or until each instructor child node has been visited\n\n        :param ins_node: Instructor ast to find in the student ast\n        :param std_node: Student AST to search for the instructor ast in\n        :param check_meta: flag to check whether the fields of the instructor node and the student node should match\n        :return: a mapping between the isntructor and student asts, or False if such a mapping doesn't exist\n        \"\"\"\n        base_mappings = self.shallow_match(ins_node, std_node, check_meta)\n        if base_mappings:\n            # base case this runs 0 times because no children\n            # find each child of ins_node that matches IN ORDER\n            base_sibs = [-1]\n            youngest_sib = 0\n            # for each child\n            for i, insChild in enumerate(ins_node.children):\n                # make a new set of maps\n                running_maps = []\n                running_sibs = []\n                # accumulate all potential matches for current child\n                for j, std_child in enumerate(std_node.children[youngest_sib:], youngest_sib):\n                    std_child = std_node.children[j]\n                    new_mapping = self.deep_find_match(insChild, std_child, check_meta)\n                    if new_mapping:\n                        running_maps.append(new_mapping)\n                        running_sibs.append(j)\n                map_update = self.map_merge(base_mappings, base_sibs, running_maps, running_sibs)\n                if map_update is None:\n                    return False\n                base_mappings = map_update['new_maps']\n                base_sibs = map_update['new_sibs']\n                youngest_sib = map_update['youngest_sib'] + 1\n            return base_mappings\n        return False\n\n    # noinspection PyMethodMayBeStatic\n    def map_merge(self, base_maps, base_sibs, run_maps, run_sibs):\n        \"\"\"\n        Merges base_maps with the current possible maps. Helper method to deep_find_match_generic. checks whether each\n        mapping in run_maps can extend the match to any possible mapping in base_maps.\n\n        :param base_maps: The original mappings\n        :param base_sibs: The corresponding siblings for each mapping in base_maps\n        :param run_maps: The set of maps to merge into the current base_maps\n        :param run_sibs: The corresponding siblings for each mapping in run_maps\n        :return: A new set of maps for all valid extensions of base_maps with running maps\n        \"\"\"\n        # no matching nodes were found\n        if len(run_maps) == 0:\n            return None\n        new_maps = []\n        new_sibs = []\n        youngest_sib = run_sibs[0]\n        for baseMap, base_sib in zip(base_maps, base_sibs):\n            for run_map, runSib in zip(run_maps, run_sibs):\n                if runSib > base_sib:\n                    for run_mapsub in run_map:\n                        new_map = baseMap.new_merged_map(run_mapsub)\n                        if not new_map.has_conflicts():  # if it's a valid mapping\n                            new_maps.append(new_map)\n                            new_sibs.append(runSib)\n        map_update = None\n        if len(new_maps) != 0:\n            map_update = dict()\n            map_update['new_maps'] = new_maps\n            map_update['new_sibs'] = new_sibs\n            map_update['youngest_sib'] = youngest_sib\n        return map_update\n\n    # noinspection PyMethodMayBeStatic,PyPep8Naming,PyUnusedLocal\n    def shallow_match_Module(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        Flexibly matches a module node to a module or a body\n        :return: a mapping of ins_node to std_node, or False if doesn't match\n        \"\"\"\n        if type(std_node.astNode).__name__ == \"Module\" or std_node.field == \"body\":\n            mapping = AstMap()\n            mapping.add_node_pairing(ins_node, std_node)\n            return [mapping]\n        return False\n\n    # noinspection PyPep8Naming\n    def shallow_match_Name(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        Matches ins_node to std_node for different cases of encountering a name node in ins_node\n            case 1: _var_ matches if std_node is a name node and automatically returns a mapping and symbol table\n            case 2: __exp__ matches to any subtree and automatically returns a mapping and symbol table\n            case 3: ___ matches to any subtree and automatically returns a mapping\n            case 4: matches only if the exact names are the same (falls through to shallow_match_generic)\n        @return a mapping of ins_node to std_node and possibly a symbol_table, or False if it doesn't match\n        \"\"\"\n        name_id = ins_node.astNode.id\n        var_match = re.compile('^_[^_].*_$')  # /regex\n        exp_match = re.compile('^__.*__$')  # /regex\n        wild_card = re.compile('^___$')  # /regex\n        mapping = AstMap()\n        matched = False\n        meta_matched = self.metas_match(ins_node, std_node, check_meta)\n        if var_match.match(name_id) and meta_matched:  # variable\n            if type(std_node.astNode).__name__ == \"Name\":\n                mapping.add_var_to_sym_table(ins_node, std_node)  # TODO: Capture result?\n                matched = True\n        # could else return False, but shallow_match_generic should do this as well\n        elif exp_match.match(name_id) and meta_matched:  # expression TODO: In theory this won't run?\n            mapping.add_exp_to_sym_table(ins_node, std_node)\n            matched = True\n        elif wild_card.match(name_id) and meta_matched:  # don't care TODO: In theory this won't run?\n            matched = True\n\n        if matched:\n            mapping.add_node_pairing(ins_node, std_node)\n            return [mapping]\n        # else\n        return self.shallow_match_generic(ins_node, std_node, check_meta)\n\n    # noinspection PyPep8Naming,PyMethodMayBeStatic\n    def shallow_match_Pass(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        An empty body should match to anything\n        :param ins_node: Instructor ast to find in the student ast\n        :param std_node: Student AST to search for the instructor ast in\n        :param check_meta: flag to check whether the fields of the instructor node and the student node should match\n        :return: a mapping between the isntructor and student asts, or False if such a mapping doesn't exist\n        \"\"\"\n        # if check_meta and ins_node.field != std_node.field:\n        if not self.metas_match(ins_node, std_node, check_meta):\n            return False\n        mapping = AstMap()\n        mapping.add_node_pairing(ins_node, std_node)\n        return [mapping]\n\n    # noinspection PyPep8Naming,PyMethodMayBeStatic\n    def shallow_match_Expr(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        An Expression node (not to be confused with expressions denoted by the instructor nodes in Name ast nodes)\n        should match to anything\n        :param ins_node: Instructor ast to find in the student ast\n        :param std_node: Student AST to search for the instructor ast in\n        :param check_meta: flag to check whether the fields of the instructor node and the student node should match\n        :return: a mapping between the instructor and student asts, or False if such a mapping doesn't exist\n        \"\"\"\n        # if check_meta and ins_node.field != std_node.field:\n        if not self.metas_match(ins_node, std_node, check_meta):\n            return False\n        mapping = AstMap()\n        mapping.add_node_pairing(ins_node, std_node)\n        return [mapping]\n\n    # noinspection PyPep8Naming\n    def shallow_match_FunctionDef(self, ins_node, std_node, check_meta=True):\n        ins = ins_node.astNode\n        std = std_node.astNode\n        meta_matched = self.metas_match(ins_node, std_node, check_meta)\n        is_match = type(ins).__name__ == type(std).__name__ and meta_matched\n        mapping = self.shallow_match_main(ins_node, std_node, check_meta, ignores=['name', 'args'])\n        matched = False\n        if is_match and mapping:\n            name = ins.name\n            var_match = re.compile('^_[^_].*_$')  # /regex\n            wild_card = re.compile('^___$')  # /regex\n            if var_match.match(name) and meta_matched:  # variable\n                mapping[0].add_func_to_sym_table(ins_node, std_node)  # TODO: Capture result?\n                matched = True\n            elif wild_card.match(name) and meta_matched:\n                matched = True\n            elif name == std.name and meta_matched:\n                matched = True\n        if matched:\n            return mapping\n        else:\n            return False\n\n    # noinspection PyMethodMayBeStatic\n    def shallow_match_generic(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        Checks that all non astNode attributes are equal between ins_node and std_node\n        :param ins_node: Instructor ast root node\n        :param std_node: Student AST root node\n        :param check_meta: flag to check whether the fields of the instructor node and the student node should match\n        :return: a mapping between the isntructor and student root nodes, or False if such a mapping doesn't exist\n        \"\"\"\n        return self.shallow_match_main(ins_node, std_node, check_meta)\n\n    def shallow_match_main(self, ins_node, std_node, check_meta=True, ignores=[]):\n        \"\"\"\n                Checks that all non astNode attributes are equal between ins_node and std_node\n                :param ins_node: Instructor ast root node\n                :param std_node: Student AST root node\n                :param check_meta: flag to check whether the fields of the instructor node and the student node should match\n                :return: a mapping between the isntructor and student root nodes, or False if such a mapping doesn't exist\n                \"\"\"\n        ins = ins_node.astNode\n        std = std_node.astNode\n        ins_field_list = list(ast.iter_fields(ins))\n        std_field_list = list(ast.iter_fields(std))\n        meta_matched = self.metas_match(ins_node, std_node, check_meta)\n        is_match = len(ins_field_list) == len(std_field_list) and type(ins).__name__ == type(\n            std).__name__ and meta_matched\n        for insTup, stdTup in zip(ins_field_list, std_field_list):\n            if not is_match:\n                break\n\n            ins_field = insTup[0]\n            ins_value = insTup[1]\n            std_field = stdTup[0]\n            std_value = stdTup[1]\n\n            if ins_value is None:\n                continue\n\n            ignore_field = ins_field in ignores\n\n            is_match = (ins_field == std_field) or ignore_field\n\n            if not isinstance(ins_value, list):\n                ins_value = [ins_value]\n\n            if not isinstance(std_value, list):\n                std_value = [std_value]\n\n            # is_match = len(ins_value) == len(std_value)# for stretchy matching this isn't True\n            # Reference ast_node_visitor.js for the original behavior and keep note of it for the purposes of handling\n            # the children noting the special case when the nodes of the array are actually parameters of the node\n            # (e.g. a load function) instead of a child node\n            if not ignore_field:\n                for inssub_value, stdsub_value in zip(ins_value, std_value):\n                    if not is_match:\n                        break\n                    # TODO: make this a smarter comparison, maybe handle dictionaries, f-strings, tuples, etc.\n                    if is_primitive(inssub_value):\n                        is_match = inssub_value == stdsub_value\n        mapping = False\n        if is_match:\n            mapping = AstMap()  # return MAPPING\n            mapping.add_node_pairing(ins_node, std_node)\n            mapping = [mapping]\n        return mapping\n\n    # filter function for various types of nodes\n    def shallow_match(self, ins_node, std_node, check_meta=True):\n        method_name = 'shallow_match_' + type(ins_node.astNode).__name__\n        target_func = getattr(self, method_name, self.shallow_match_generic)\n        return target_func(ins_node, std_node, check_meta)\n\n    @staticmethod\n    def metas_match(ins_node, std_node, check_meta=True):\n        return (check_meta and ins_node.field == std_node.field) or not check_meta or ins_node.field == \"none\"\n\n    # TODO: Possibly add a feature for variable function names?\n", "src/lib/pedal/cait_old/cait_api.py": "from pedal.report import Report, MAIN_REPORT\nfrom pedal.source import set_source\nfrom pedal.tifa import tifa_analysis\nfrom pedal.cait_old.stretchy_tree_matching import *\n\n\nclass Cait:\n    def __init__(self, std_code=None, report=None):\n        if report is None and std_code is None:\n            self.report = MAIN_REPORT\n        elif report is not None and std_code is not None:\n            raise Exception(\"New code should generate new reports\")\n        elif std_code is not None:\n            self.report = Report()\n            set_source(std_code, self.report)\n\n        if 'cait' not in self.report:\n            self._initialize_report()\n\n    def _initialize_report(self):\n        \"\"\"\n        Initialize a successful report with possible set of issues.\n        \"\"\"\n        if self.report[\"source\"][\"success\"]:\n            std_ast = self.report['source']['ast']\n            self.report['cait'] = {}\n            self.report['cait']['std_ast'] = EasyNode(std_ast)\n            tifa_analysis(report=self.report)\n\n\n# noinspection PyBroadException\ndef parse_program():\n    \"\"\"Parses student code (attempts to retrieve from TIFA?)\n\n    :return: student AST\n    \"\"\"\n    try:\n        std_easy = MAIN_REPORT['cait']['std_ast']\n    except KeyError:\n        if MAIN_REPORT[\"source\"][\"success\"]:\n            std_ast = MAIN_REPORT['source']['ast']\n            MAIN_REPORT['cait']['matcher'] = None\n        else:\n            MAIN_REPORT.attach(\"No source code found\", tool='cait', \n                               section=MAIN_REPORT['source']['section'],\n                               category='analyzer')\n            std_ast = ast.parse('')\n        MAIN_REPORT['cait']['std_ast'] = EasyNode(std_ast)\n        std_easy = MAIN_REPORT['cait']['std_ast']\n    return std_easy\n\ndef expire_cait_cache():\n    if 'std_ast' in MAIN_REPORT['cait']:\n        del MAIN_REPORT['cait']['std_ast']\n\ndef def_use_error(node, report=None):\n    \"\"\"Checks if node is a name and has a def_use_error\n\n    :param node: student AST name node\n    :param report: The report object being used for analysis\n    :return: True if the given name has a def_use_error\n    \"\"\"\n    cait_obj = Cait(report)\n    if not isinstance(node, str) and node.ast_name != \"Name\":\n        raise TypeError\n    try:\n        def_use_vars = cait_obj.report['tifa']['issues']['Initialization Problem']\n    except KeyError:\n        return False\n    if not isinstance(node, str):\n        node_id = node.id\n    else:\n        node_id = node\n    has_error = False\n    for issue in def_use_vars:\n        name = issue['name']\n        if name == node_id:\n            has_error = True\n            break\n    return has_error\n\n\n# noinspection PyBroadException\ndef data_state(node, report=None):\n    \"\"\"\n\n    :param node: EasyNode/ast node whose type to retrieve\n    :param report: The report object to retrieve the information from\n    :return: the type of the object (Tifa type) or None if a type doesn't exist\n    \"\"\"\n    cait_obj = Cait(report)\n    if not isinstance(node, str) and node.ast_name != \"Name\":\n        raise TypeError\n    if isinstance(node, str):\n        node_id = node\n    else:\n        node_id = node.id\n    return cait_obj.report['tifa'][\"top_level_variables\"][node_id]\n\n\ndef data_type(node, report=None):\n    return data_state(node, report=report).type\n\n\ndef find_match(ins_code, std_code=None, report=None, cut=False):\n    \"\"\"Apply Tree Inclusion and return first match\n\n    :param ins_code: Instructor defined pattern\n    :param std_code: Student code\n    :param report: The report associated with the find_match function\n    :param cut: set to true to trim root to first branch\n    :return: First match of tree inclusion of instructor in student or None\n    \"\"\"\n    matches = find_matches(ins_code=ins_code, std_code=std_code, report=report, cut=cut)\n    if matches:\n        return matches[0]\n    else:\n        return None\n\n\ndef find_matches(ins_code, std_code=None, report=None, cut=False):\n    \"\"\"Apply Tree Inclusion and return all matches\n\n    :param ins_code: Instructor pattern\n    :param std_code: Student Code\n    :param report: the report to use for finding matches\n    :param cut: set to true to trim root to first branch\n    :return: All matches of tree inclusion of instructor in student\n    \"\"\"\n    cait_obj = Cait(std_code=std_code, report=report)\n    # TODO: Check to make sure the code actually parsed\n    try:\n        std_code = cait_obj.report['cait']['std_ast']\n        matcher = StretchyTreeMatcher(ins_code)\n        cait_obj.report['cait']['matcher'] = matcher\n        matches = cait_obj.report['cait']['matcher'].find_matches(std_code)\n        return matches\n    except KeyError:\n        return False\n\n\ndef find_submatches(ins_expr, std_expr, is_mod=False):\n    return find_expr_sub_matches(ins_expr, std_expr, is_mod)\n\n\ndef find_expr_sub_matches(ins_expr, std_expr, is_mod=False):\n    \"\"\"Finds ins_expr in std_expr\n    # TODO: Add code to make ins_expr accept EasyNodes\n    # TODO: Make this function without so much meta knowledge\n    :param ins_expr: the expression to find (str that MUST evaluate to a Module node with a single child or an AstNode)\n    :param std_expr: student subtree\n    :param as_expr: whether it's an expression match or not, experimental\n    :param is_mod: currently hack for multiline sub matches\n    :param cut: flag for cutting off root until a branch occurs\n    :return: a list of matches or False if no matches found\n    \"\"\"\n    is_node = isinstance(ins_expr, EasyNode)\n    if not isinstance(ins_expr, str) and not is_node:\n        raise TypeError(\"ins_expr expected str or EasyNode, found {0}\".format(type(ins_expr)))\n    matcher = StretchyTreeMatcher(ins_expr)\n    if (not is_node and not is_mod) and len(matcher.rootNode.children) != 1:\n        raise ValueError(\"ins_expr does not evaluate to a singular statement\")\n    return matcher.find_matches(std_expr, check_meta=False)\n", "src/lib/pedal/cait_old/__init__.py": "'''\nA package of tools for capturing student code by matching it against patterns.\n'''\n\nNAME = 'CAIT'\nSHORT_DESCRIPTION = \"Captures instructor code patterns within student code.\"\nDESCRIPTION = '''\n'''\nREQUIRES = ['Source']\nOPTIONALS = ['TIFA']\n\n__all__ = ['NAME', 'SHORT_DESCRIPTION', 'DESCRIPTION', 'REQUIRES', 'OPTIONALS']\n", "src/lib/pedal/cait_old/ast_dump_magic.py": "def load_ipython_extension(ip):\n    from IPython.core.magic import Magics, magics_class, cell_magic\n    from IPython.core import magic_arguments\n    \n    @magics_class\n    class AstMagics(Magics):\n        \n        @magic_arguments.magic_arguments()\n        @magic_arguments.argument(\n            '-m', '--mode', default='exec',\n            help=\"The mode in which to parse the code. Can be exec (the default), \"\n                 \"eval or single.\"\n        )    \n        @cell_magic\n        def dump_ast(self, line, cell):\n            \"\"\"Parse the code in the cell, and pretty-print the AST.\"\"\"\n            args = magic_arguments.parse_argstring(self.dump_ast, line)\n            parseprint(cell, mode=args.mode)\n    \n    ip.register_magics(AstMagics)\n", "src/lib/pedal/cait_old/ast_helpers.py": "\"\"\"\nA pretty-printing dump function for the ast module.  The code was copied from\nthe ast.dump function and modified slightly to pretty-print.\n\nAlex Leone (acleone ~AT~ gmail.com), 2010-01-30\n\nFrom http://alexleone.blogspot.co.uk/2010/01/python-ast-pretty-printer.html\n\"\"\"\n\nfrom ast import *\n\n\ndef dump(node, annotate_fields=True, include_attributes=False, indent='  '):\n    \"\"\"\n    Return a formatted dump of the tree in *node*.  This is mainly useful for\n    debugging purposes.  The returned string will show the names and the values\n    for fields.  This makes the code impossible to evaluate, so if evaluation is\n    wanted *annotate_fields* must be set to False.  Attributes such as line\n    numbers and column offsets are not dumped by default.  If this is wanted,\n    *include_attributes* can be set to True.\n    \"\"\"\n    def _format(node, level=0):\n        if isinstance(node, AST):\n            fields = [(a, _format(b, level)) for a, b in iter_fields(node)]\n            if include_attributes and node._attributes:\n                fields.extend([(a, _format(getattr(node, a), level))\n                               for a in node._attributes])\n            return ''.join([\n                node.__class__.__name__,\n                '(',\n                ', '.join(('%s=%s' % field for field in fields)\n                           if annotate_fields else\n                           (b for a, b in fields)),\n                ')'])\n        elif isinstance(node, list):\n            lines = ['[']\n            lines.extend((indent * (level + 2) + _format(x, level + 2) + ','\n                         for x in node))\n            if len(lines) > 1:\n                lines.append(indent * (level + 1) + ']')\n            else:\n                lines[-1] += ']'\n            return '\\n'.join(lines)\n        return repr(node)\n    \n    if not isinstance(node, AST):\n        raise TypeError('expected AST, got %r' % node.__class__.__name__)\n    return _format(node)\n\n\ndef parseprint(code, filename=\"<string>\", mode=\"exec\", **kwargs):\n    \"\"\"Parse some code from a string and pretty-print it.\"\"\"\n    node = parse(code, mode=mode)   # An ode to the code\n    print(dump(node, **kwargs))\n\n# Short name: pdp = parse, dump, print\npdp = parseprint\n", "src/lib/pedal/cait_old/ct_map.py": "class CtMap:\n    \"\"\"\n    A cache implemented map using linear lists. This is a hold over from the javascript library when we couldn't be sure\n    that a student's javascript could use maps.\n\n    The design pattern used in this map is to always used the cached key/associated index. So methods accessing values\n    will first call update_cache, and then use the fields self.cacheKey or self.cacheIndex.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        :self.keys: The set of keys, each corresponds to the same index in values\n        :self.values: The set of values, each corresponds to the same index in keys\n        :self.cacheKey: the most recently used key, or None, if the value could not be found. This is kept in sync with\n                        self.cacheIndex\n        :self.cacheIndex: The most recently used index, or -1 if the value could not be found. This is kept in sync with\n                            self.cacheKey\n        \"\"\"\n        self.keys = []\n        self.values = []\n        self.cacheKey = None\n        self.cacheIndex = -1\n\n    def update_cache(self, key):\n        \"\"\"\n        Updates the cache\n        :param key: The key to be cached\n        \"\"\"\n        if self.cacheIndex == -1 or self.cacheKey != key:\n            self.cacheKey = key\n            if key in self.keys:\n                self.cacheIndex = self.keys.index(key)\n            else:\n                self.cacheIndex = -1\n\n    def clear_cache(self):\n        self.cacheKey = None\n        self.cacheIndex = -1\n\n    def clear(self):\n        \"\"\"\n        Empties map and clears the cache\n        \"\"\"\n        self.keys = []\n        self.values = []\n        self.clear_cache()\n\n    def delete(self, key):\n        \"\"\"\n        deletes value associated with the key, and then the key, in that order.\n        :param key: The key to be deleted\n        \"\"\"\n        self.update_cache(key)\n        if self.cacheIndex != -1:\n            del self.values[self.cacheIndex]\n            del self.keys[self.cacheIndex]\n        self.clear_cache()\n\n    def get(self, key):\n        self.update_cache(key)\n        if self.cacheIndex == -1:\n            raise IndexError(repr(key))\n        return self.values[self.cacheIndex]\n        \n    def __getitem__(self, key):\n        return self.get(key)\n\n    def has(self, key):\n        self.update_cache(key)\n        return self.cacheIndex >= 0\n        \n    def __contains__(self, key):\n        return self.has(key)\n\n    def keys(self):\n        return self.keys\n\n    def values(self):\n        return self.values\n\n    def set(self, key, value):\n        self.update_cache(key)\n        if self.cacheIndex == -1:\n            self.keys.append(key)\n            self.values.append(value)\n        else:\n            self.values[self.cacheIndex] = value\n\n    def size(self):\n        return len(self.keys)\n\n    def __str__(self):\n        # return ''.join([\"keys = \", self.keys.__str__(), \", values = \", self.values.__str__()])\n        collector = \"\"\n        for key, value in zip(self.keys, self.values):\n            collector += '{}[{}: {}], '.format(collector, key, value)\n            #collector = ''.join([collector, \"[\", key, \": \", value.__str__(), \"], \"])\n        return collector\n\n    def __repr__(self):\n        collector = \"\"\n        for key, value in zip(self.keys, self.values):\n            collector = ''.join([collector, \"[\", key, \": \", value.__str__(), \"], \"])\n        return collector\n", "src/lib/pedal/cait_old/easy_node.py": "import ast\nimport pedal.cait_old.ast_helpers as ast_str\nfrom types import MethodType\nfrom pedal.report import Report, Feedback, MAIN_REPORT\n\nclass EasyNode:\n    \"\"\"\n    A wrapper class for AST nodes. Linearizes access to the children of the ast\n    node and saves the field this AST node\n    originated from.\n\n    TODO: May want to just add fields and methods to the existing AST nodes and\n    use a production pattern instead.\n    \"\"\"\n\n    def __init__(self, ast_node, my_field='', tid=0, lin_tree=None, ancestor=None):\n        \"\"\"\n        :param ast_node: The AST node to be wrapped\n        :param my_field: the field of the parent node that produced this child.\n        \"\"\"\n        self.children = []\n        self.astNode = ast_node\n        self.field = my_field\n        self.tree_id = tid\n        self.parent = ancestor\n        if lin_tree is None:\n            self.linear_tree = [self]\n        else:\n            lin_tree.append(self)\n            self.linear_tree = lin_tree\n\n        # reference to the easy node wrapping the ast_node\n        setattr(ast_node, 'easy_node', self)\n\n        tid_count = tid\n\n        my_field_generator = ast.iter_fields(self.astNode)\n        for item in my_field_generator:\n            field, value = item\n            # if the field doesn't have a value, no child exists\n            if value is None:\n                continue\n\n            # If the children are not in an array, wrap it in an array for\n            # consistency in the code the follows\n            if not isinstance(value, list):\n                value = [value]\n\n            # Reference ast_node_visitor.js for the original behavior and keep note of it for the purposes of handling\n            # the children noting the special case when the nodes of the array are actually parameters of the node\n            # (e.g. a load function) instead of a child node\n            for sub_value in value:\n                if isinstance(sub_value, ast.AST):\n                    new_child = EasyNode(sub_value, my_field=field, \n                                         tid=tid_count + 1, \n                                         lin_tree=self.linear_tree,\n                                         ancestor=self)\n                    self.children.append(new_child)\n                    tid_count = len(self.linear_tree) - 1\n\n    def __str__(self):\n        return ''.join([self.field, \"\\n\", ast_str.dump(self.astNode)])\n\n    def numeric_logic_check(self, mag, expr):\n        \"\"\"\n        If this node is a Compare or BoolOp node, sees if the logic in expr (a javascript string being a logical\n        statement) matches the logic of self. This assumes that we are only comparing numerical values to a single\n        variable\n        TODO: modify this to take multiple variables\n        TODO: modify to support more than +, -, *, and / BinOps\n        TODO: modify to support unary operators other than USub and Not\n        :param mag: the order of magnitude that should be added to numbers to check logic, 1 is usually a good value,\n                    especially when working with the set of integers.\n        :param expr: the \"Compare\" or \"BoolOp\" tree to check self against\n        :return: True if self (typically student node) and expr are equivalent boolean expressions\n        \"\"\"\n\n        def eval_unop(unop_num, unop_node):\n            operand = eval_selector(unop_num, unop_node.operand)\n            op = unop_node.op_name\n\n            return {\"USub\": -operand,\n                    \"Not\": not operand}[op]\n\n        def eval_binop(binop_num, binop_node):\n            left = eval_selector(binop_num, binop_node.left)\n            right = eval_selector(binop_num, binop_node.right)\n            op = binop_node.op_name\n\n            return {\n                \"Add\": left + right,\n                \"Sub\": left - right,\n                \"Mult\": left * right,\n                \"Div\": left/right}[op]\n\n        def eval_selector(op_num, op_expr):\n            op_expr = op_num if op_expr.ast_name == \"Name\" else op_expr\n            if isinstance(op_expr, (int, float)):\n                return op_expr\n            if op_expr.ast_name == \"BinOp\":\n                return eval_binop(op_num, op_expr)\n            if op_expr.ast_name == \"UnaryOp\":\n                return eval_unop(op_num, op_expr)\n            if op_expr.ast_name == \"Num\":\n                return op_expr.n\n            raise NotImplementedError\n\n        def eval_bool_comp(num_list, comp_ast):\n            ops = comp_ast.ops_names\n            comps = comp_ast.comparators\n            results = []\n            current = comp_ast.left\n            left = current\n\n            for num_i in num_list:\n                result = True\n                for op, comp in zip(ops, comps):\n                    current = eval_selector(num_i, current)\n                    comp_p = eval_selector(num_i, comp)\n\n                    res = {\n                        \"Eq\": current == comp_p,\n                        \"NotEq\": current != comp_p,\n                        \"Lt\": current < comp_p,\n                        \"LtE\": current <= comp_p,\n                        \"Gt\": current > comp_p,\n                        \"GtE\": current >= comp_p,\n                    }[op]\n                    current = comp\n                    result = result and res\n                    if not result:\n                        break\n                results.append(result)\n                current = left\n            return results\n\n        def eval_boolop(num_list, boolop_ast):\n            boolop = boolop_ast.op_name\n            values = boolop_ast.values\n            results_c = None\n            is_and = boolop == \"And\"\n            for value in values:\n                if value.ast_name == \"Compare\":\n                    results = eval_bool_comp(num_list, value)\n                else:  # should be boolop\n                    results = eval_boolop(num_list, value)\n                if results_c is None:\n                    results_c = results\n                else:  # compile results\n                    new_result = []\n                    for result1, result2 in zip(results_c, results):\n                        if is_and:\n                            new_result.append(result1 and result2)\n                        else:\n                            new_result.append(result1 or result2)\n                    results_c = new_result\n            return results_c\n        try:\n            ins_expr = EasyNode(ast.parse(expr)).body[0].value\n            ins_nums = ins_expr.find_all(\"Num\")\n            std_nums = self.find_all(\"Num\")\n            test_nums = []\n            for num in ins_nums:\n                raw_num = num.n\n                test_nums.append(raw_num)\n                test_nums.append(raw_num + mag)\n                test_nums.append(raw_num - mag)\n            for num in std_nums:\n                raw_num = num.n\n                test_nums.append(raw_num)\n                test_nums.append(raw_num + mag)\n                test_nums.append(raw_num - mag)\n\n            if self.ast_name == \"Compare\":\n                std_res = eval_bool_comp(test_nums, self)\n            elif self.ast_name == \"BoolOp\":\n                std_res = eval_boolop(test_nums, self)\n            else:\n                return False\n\n            if ins_expr.ast_name == \"Compare\":\n                ins_res = eval_bool_comp(test_nums, ins_expr)\n            elif ins_expr.ast_name == \"BoolOp\":\n                ins_res = eval_boolop(test_nums, ins_expr)\n            else:\n                raise TypeError\n            return ins_res == std_res\n        except:\n            return False\n\n    def get_next_tree(self):\n        \"\"\"Gets the next tree in the AST\n        This method gets the next AST node that is of equal or higher level than self. Returns None if the end of the\n        tree is reached\n        TODO: Create a get sibling method.\n        :return: The next tree in the AST\n        \"\"\"\n\n        # adding function to track tree ids\n        def visit_counter(self, node):\n            self.counter += 1\n            self.generic_visit(node)\n\n        node_counter = ast.NodeVisitor()\n        setattr(node_counter, 'counter', self.tree_id)\n        node_counter.visit = MethodType(visit_counter, node_counter)\n\n        # getting ids\n        node_counter.visit(self.astNode)\n        out_of_tree = node_counter.counter >= len(self.linear_tree)  # check if out of bounds\n        # len(self.children) > 0 and self.children[-1] == node_counter\n        if out_of_tree:\n            return None\n        return self.linear_tree[node_counter.counter]\n\n    def get_child(self, node):\n        \"\"\"\n\n        :param node: a non-EasyNode ast node\n        :return: the corresponding easy node to the child\n        \"\"\"\n        if isinstance(node, ast.AST):\n            for child in self.children:\n                if child.astNode == node:\n                    return child\n        elif isinstance(node, int):\n            return self.children(node)\n        return None\n\n    @staticmethod\n    def get_ast_name(node):\n        return type(node).__name__\n\n    def __getattr__(self, item):\n        key = item\n        '''\n        Non-ast node attributes based on ast_node attributes\n        '''\n        node_name = EasyNode.get_ast_name(self.astNode)\n        if node_name == \"Assign\" and key == \"target\":\n            key = \"targets\"\n        if item in AST_SINGLE_FUNCTIONS:\n            key = item[:-5]  # strip suffix '_name'\n        if item in AST_ARRAYS_OF_FUNCTIONS:\n            key = item[:-6]  # strip suffix '_names'\n\n        '''\n        Non-ast node attributes\n        '''\n        if key == 'next_tree':\n            return self.get_next_tree()\n        if key == 'ast_name':\n            return node_name\n        elif key == '_name':\n            return self.astNode.name\n        else:  # ast node attributes or derivative attributes\n            if hasattr(self.astNode, key):\n                # noinspection PyBroadException\n                try:\n                    field = self.astNode.__getattribute__(key)\n                except Exception:\n                    field = None\n                if node_name == \"Assign\" and item != key:\n                    if item == \"target\":\n                        return field[0].easy_node  # Get's the relevant ast node\n                    elif item == \"targets\" and isinstance(field, list):\n                        easy_array = []\n                        for node in field:\n                            easy_array.append(node.easy_node)\n                        return easy_array\n                    else:\n                        return field\n                elif item in AST_SINGLE_FUNCTIONS:\n                    return type(field).__name__\n                elif item in AST_ARRAYS_OF_FUNCTIONS:\n                    str_ops_list = []\n                    for op in field:\n                        str_ops_list.append(type(op).__name__)\n                        return str_ops_list\n                elif isinstance(field, ast.AST):\n                    return field.easy_node\n                elif isinstance(field, list):\n                    try:\n                        return [f.easy_node for f in field]\n                    except AttributeError:\n                        # This can only happen in NonLocals, which has a list\n                        # of raw strings in the `names` property\n                        return field\n                else:\n                    return field\n\n    def find_all(self, node_type):\n        \"\"\"Finds all nodes defined by string node_type\n\n        :param node_type: the string representing the \"type\" of node to look for\n        :return: a list of Ast Nodes (easy_nodes) of self that are of the specified type (including self if self\n                    meets that criteria)\n        \"\"\"\n        items = []\n        visitor = ast.NodeVisitor()\n        # setattr(visitor, \"current_id\", self.tree_id - 1)\n        setattr(visitor, \"items\", items)\n        func_name = 'visit_' + node_type\n\n        def main_visit(self, node):\n            self.items.append(node.easy_node)\n            return self.generic_visit(node)\n\n        func_ref = main_visit\n        setattr(visitor, func_name, MethodType(func_ref, visitor))\n        visitor.visit(self.astNode)\n        return visitor.items\n    \n    def has(self, node):\n        if isinstance(node, (int, float)):\n            visitor = ast.NodeVisitor()\n            has_num = []\n\n            def visit_Num(self, potential):\n                has_num.append(node == potential.n)\n                return self.generic_visit(potential)\n            visitor.visit_Num = MethodType(visit_Num, visitor)\n            visitor.visit(self.astNode)\n            return any(has_num)\n        elif node.ast_name != \"Name\":\n            return False\n        visitor = ast.NodeVisitor()\n        has_name = []\n\n        def visit_Name(self, potential):\n            has_name.append(node.id == potential.id)\n            return self.generic_visit(potential)\n        visitor.visit_Name = MethodType(visit_Name, visitor)\n        visitor.visit(self.astNode)\n        return any(has_name)\n\n    def is_before(self, other):\n        try:\n            return self.tree_id < other.tree_id and self.linear_tree == other.linear_tree\n        except Exception:\n            raise TypeError\n    \n    def is_ast(self, ast_name):\n        if not isinstance(ast_name, str):\n            ast_name = EasyNode.get_ast_name(ast_name.astNode)\n        return EasyNode.get_ast_name(self.astNode).lower() == ast_name.lower()\n\n    def is_method(self):\n        # Check if I'm a FunctionDef, and if any of my parents are ClassDef.\n        pass\n\nAST_SINGLE_FUNCTIONS = [\"ctx_name\", \"op_name\"]\nAST_ARRAYS_OF_FUNCTIONS = [\"ops_names\"]\n", "src/lib/pedal/cait_old/ast_map.py": "from pedal.cait_old.ct_map import *\nfrom pedal.cait_old.easy_node import *\n\n\nclass AstSymbol:\n    def __init__(self, _id=\"\", _node=None):\n        self.id = _id\n        self.astNode = _node\n\n    def __str__(self):\n        return ''.join([\"id = \", self.id.__str__(), \", astNode = \", type(self.astNode).__name__])\n\n    def __repr__(self):\n        return ''.join([\"id = \", self.id.__str__(), \", astNode = \", type(self.astNode).__name__])\n\n\nclass AstMap:\n    def __init__(self):\n        self.mappings = CtMap()\n        self.symbol_table = CtMap()\n        self.exp_table = CtMap()\n        self.func_table = CtMap()\n        self.conflict_keys = []\n        self.match_root = None\n        self.match_lineno = -1\n\n    def add_func_to_sym_table(self, ins_node, std_node):\n        \"\"\"\n        Adds ins_node.name to the symbol table if it doesn't already exist, mapping it to a set of ins_node. Updates a\n        second dictionary that maps ins_node to an std_node, and overwrites the current std_node since there should only\n        be one mapping.\n        :param ins_node: instructor node or str representing a function name\n        :param std_node: student node representing function\n        :return: number of conflicts generated\n        \"\"\"\n        if not isinstance(std_node, EasyNode):\n            raise TypeError\n        if isinstance(ins_node, str):\n            key = ins_node\n        else:\n            key = ins_node.astNode.name\n        value = AstSymbol(std_node.astNode.name, std_node)\n        if self.func_table.has(key):\n            new_list = self.func_table.get(key)\n            new_list.append(value)\n            if not (key in self.conflict_keys):\n                for other in new_list:\n                    if value.name != other.name:\n                        self.conflict_keys.append(key)\n                        break\n        else:\n            new_list = [value]\n\n        self.func_table.set(key, new_list)\n        return len(self.conflict_keys)\n\n    def add_var_to_sym_table(self, ins_node, std_node):\n        \"\"\"\n        Adds ins_node.id to the symbol table if it doesn't already exist, mapping it to a set of ins_node. Updates a\n        second dictionary that maps ins_node to an std_node, and overwrites the current std_node since there should only\n        be one mapping.\n        :param ins_node: instructor node or str representing variable\n        :param std_node: student node representing variable\n        :return: number of conflicts generated\n        \"\"\"\n        if not isinstance(std_node, EasyNode):\n            raise TypeError\n        if isinstance(ins_node, str):\n            key = ins_node\n        else:\n            key = ins_node.astNode.id\n        value = AstSymbol(std_node.astNode.id, std_node)\n        if self.symbol_table.has(key):\n            new_list = self.symbol_table.get(key)\n            new_list.append(value)\n            if not (key in self.conflict_keys):\n                for other in new_list:\n                    if value.id != other.id:\n                        self.conflict_keys.append(key)\n                        break\n        else:\n            new_list = [value]\n\n        self.symbol_table.set(key, new_list)\n        return len(self.conflict_keys)\n\n    def add_exp_to_sym_table(self, ins_node, std_node):\n        \"\"\"Adds mapping of expression symbol to student node\n        This function does NOT check for conflicts at the moment and probably should at some point.\n        TODO: Check for conflicts\n        :param ins_node: Instructor node representing an expression\n        :param std_node: student ast subtree corresponding to the symbol\n        :return: nothing\n        \"\"\"\n        if not isinstance(std_node, EasyNode):\n            raise TypeError\n        self.exp_table.set(ins_node.astNode.id, std_node)\n\n    def add_node_pairing(self, ins_node, std_node):\n        \"\"\"\n        Adds a mapping of instructor ast node to a specific student ast node\n        :param ins_node: instructor pattern ast node\n        :param std_node: student ast node\n        :return: nothing\n        \"\"\"\n        if not isinstance(std_node, EasyNode):\n            raise TypeError\n        self.mappings.set(ins_node, std_node)\n\n    def has_conflicts(self):\n        \"\"\"\n        :return: returns number of conflicts\n        \"\"\"\n        return len(self.conflict_keys) > 0\n\n    def new_merged_map(self, other):\n        \"\"\"\n        Returns a newly merged map consisting of this and other\n        without modifying self.\n        :param other: (type AstMap) the other AstMap to be merged with\n        :return: self modified by adding the contents of other\n        \"\"\"\n        new_map = AstMap()\n        new_map.merge_map_with(self)\n        new_map.merge_map_with(other)\n        return new_map\n\n    def merge_map_with(self, other):\n        \"\"\"\n        Returns a newly merged map consisting of this and other\n        by modifying this\n        :param other: (type AstMap) the other AstMap to be merged with\n        :return: self modified by adding the contents of other\n        \"\"\"\n        if type(other) != type(self):\n            raise TypeError\n\n        # merge all mappings\n        other_map = other.mappings\n        for other_map_key, other_map_value in zip(other_map.keys, other_map.values):\n            self.mappings.set(other_map_key, other_map_value)\n\n        # merge all expressions\n        other_exp = other.exp_table\n        for other_expKey, other_expValue in zip(other_exp.keys, other_exp.values):\n            self.exp_table.set(other_expKey, other_expValue)\n\n        # merge all symbols\n        other_sym = other.symbol_table\n        for key, value in zip(other_sym.keys, other_sym.values):\n            for sub_value in value:\n                self.add_var_to_sym_table(key, sub_value.astNode)\n\n        # merge all functions\n        other_func = other.func_table\n        for key, value in zip(other_func.keys, other_func.values):\n            for sub_value in value:\n                self.add_func_to_sym_table(key, sub_value.astNode)\n\n    def get_std_name(self, ins_id):\n        \"\"\"Return student node associated with ins_id\n\n        :param ins_id: the instructor variable defined in the pattern\n        :return: the associated student name node\n        \"\"\"\n        if isinstance(ins_id, str):\n            # noinspection PyBroadException\n            try:\n                return self.symbol_table.get(ins_id)\n            except Exception:\n                return None\n\n    def get_exp_name(self, ins_id):\n        \"\"\"Return student subtree associated with ins_id\n\n        :param ins_id: the instructor variable defined in the pattern\n        :return: the associated student subtree node\n        \"\"\"\n        if isinstance(ins_id, str):\n            # noinspection PyBroadException\n            try:\n                return self.exp_table.get(ins_id)\n            except Exception:\n                return None\n    \n    def __getitem__(self, id):\n        if id.startswith('__'):\n            return self.exp_table[id]\n        else:\n            if id in self.symbol_table:\n                return self.symbol_table[id]\n            else:\n                return self.func_table[id]\n    \n    def __contains__(self, id):\n        if id.startswith('__'):\n            return id in self.exp_table\n        else:\n            exists = id in self.symbol_table\n            if exists:\n                return exists\n            else:\n                return id in self.func_table\n", "src/lib/pedal/cait_old/node_refactory.py": "import ast\nimport pedal.cait_old.ast_helpers as ast_str\nfrom types import MethodType\n\n\ndef node_refactory(ast_node, my_field='', tid=0, lin_tree=None, ancestor=None):\n    \"\"\"Alternative Implementation.\n    Instead of creating an object wrapper, we can also modify the ast_nodes directly to add desired methods and fields to\n    the ast nodes.\n    :param ast_node:\n    :param my_field:\n    :param tid:\n    :param lin_tree:\n    :param ancestor:\n    :return:\n    \"\"\"\n    children = []\n    setattr(ast_node, \"field\", my_field)  # self.field = my_field\n    setattr(ast_node, \"tree_id\", tid)  # self.tree_id = tid\n    setattr(ast_node, \"parent\", ancestor)  # self.parent = ancestor\n    setattr(ast_node, \"children\", children)\n    if lin_tree is not None:\n        lin_tree.append(ast_node)\n    else:\n        lin_tree = [ast_node]\n    setattr(ast_node, \"linear_tree\", lin_tree)\n\n    setattr(ast_node, \"numeric_logic_check\", MethodType(_numeric_logic_check, ast_node))\n    setattr(ast_node, \"get_data_type\", MethodType(_get_data_type, ast_node))\n    setattr(ast_node, \"get_next_tree\", MethodType(_get_next_tree, ast_node))\n    setattr(ast_node, \"get_child\", MethodType(_get_child, ast_node))\n    setattr(ast_node, \"find_all\", MethodType(_find_all, ast_node))\n    # setattr(the_instance, func_name, MethodType(func_ref, the_instance))\n\n    tid_count = tid\n\n    my_field_generator = ast.iter_fields(ast_node)\n    for item in my_field_generator:\n        field, value = item\n        # if the field doesn't have a value, no child exists\n        if value is None:\n            continue\n\n        # If the children are not in an array, wrap it in an array for consistency in the code the follows\n        if not isinstance(value, list):\n            value = [value]\n\n        # Reference ast_node_visitor.js for the original behavior and keep note of it for the purposes of handling\n        # the children noting the special case when the nodes of the array are actually parameters of the node\n        # (e.g. a load function) instead of a child node\n        for sub_value in value:\n            if isinstance(sub_value, ast.AST):\n                new_child = node_refactory(sub_value, my_field=field, tid=tid_count + 1, lin_tree=ast_node.linear_tree,\n                                           ancestor=ast_node)\n                ast_node.children.append(new_child)\n                tid_count = len(ast_node.linear_tree) - 1\n        return ast_node\n\n\ndef _numeric_logic_check(self, mag, expr):\n    \"\"\"\n    If this node is a Compare or BoolOp node, sees if the logic in expr (a javascript string being a logical\n    statement) matches the logic of self.  This assumes that we are only comparing numerical values to a single\n    variable\n    TODO: modify this to take multiple variables over multiple BoolOps\n    :param mag: the order of magnitude that should be added to numbers to check logic, 1 is usually a good value,\n                especially when working with the set of integers.\n    :param expr: the \"Compare\" or \"BoolOp\" tree to check self against\n    :return: True if self (typically student node) and expr are equivalent boolean expressions\n    \"\"\"\n    raise NotImplementedError\n\n\ndef _get_data_type(self):\n    # TODO: TIFA\n    raise NotImplementedError\n\n\ndef _get_next_tree(self):\n    \"\"\"Gets the next tree in the AST\n    This method gets the next AST node that is of equal or higher level than self. Returns None if the end of the\n    tree is reached\n    TODO: Create a get sibling method.\n    :return: The next tree in the AST\n    \"\"\"\n\n    # adding function to track tree ids\n    def visit_counter(self, node):\n        self.counter += 1\n        self.generic_visit(node)\n\n    node_counter = ast.NodeVisitor()\n    setattr(node_counter, 'counter', self.tree_id)\n    node_counter.visit = MethodType(visit_counter, node_counter)\n\n    # getting ids\n    node_counter.visit(self.astNode)\n    out_of_tree = node_counter.counter >= len(self.linear_tree)  # check if out of bounds\n    # len(self.children) > 0 and self.children[-1] == node_counter\n    if out_of_tree:\n        return None\n    return self.linear_tree[node_counter.counter]\n\n\ndef _get_child(self, node):\n    \"\"\"\n\n    :param node: a non-EasyNode ast node\n    :return: the corresponding easy node to the child\n    \"\"\"\n    if isinstance(node, ast.AST):\n        for child in self.children:\n            if child.astNode == node:\n                return child\n    elif isinstance(node, int):\n        return self.children(node)\n    return None\n\n\ndef get_ast_name(node):\n    return type(node).__name__\n\n\ndef my__getattr__(self, item):\n    if item == 'data_type':\n        return self.get_data_type()\n    if item == 'next_tree':\n        return self.get_next_tree()\n    if item == 'ast_name':\n        return get_ast_name(self)\n    else:\n        if hasattr(self.astNode, item):\n            # noinspection PyBroadException\n            try:\n                field = self.astNode.__getattribute__(item)\n            except Exception:\n                return None\n            if get_ast_name(self) == \"Assign\" and item == \"targets\":\n                return self.children[0]\n            elif isinstance(field, ast.AST):\n                return self.get_child(field)\n            else:\n                return field\n\n\ndef _find_all(self, node_type):\n    \"\"\"Finds all nodes defined by string node_type\n\n    :param node_type: the string representing the \"type\" of node to look for\n    :return: a list of Ast Nodes (easy_nodes) of self that are of the specified type (including self if self\n                meets that criteria)\n    \"\"\"\n    items = []\n    visitor = ast.NodeVisitor()\n    # setattr(visitor, \"current_id\", self.tree_id - 1)\n    setattr(visitor, \"items\", items)\n    func_name = 'visit_' + node_type\n\n    def main_visit(self, node):\n        self.items.append(node.easy_node)\n        return self.generic_visit(node)\n\n    func_ref = main_visit\n    setattr(visitor, func_name, MethodType(func_ref, visitor))\n    visitor.visit(self.astNode)\n    return visitor.items\n", "src/lib/pedal/plugins/vpl_unittest.py": "from unittest.util import safe_repr\nfrom pedal import gently\nfrom pedal.assertions.assertions import _normalize_string\n\n\nclass UnitTestedAssignment:\n    DELTA = .001\n\n    class AssertionException(Exception):\n        def __init__(self, message):\n            self.message = message\n\n    def __init__(self):\n        pass\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def _run_all_tests(self):\n        methods = [func for func in dir(self)\n                   if callable(getattr(self, func)) and\n                   func.startswith('test_')]\n        all_passed = True\n        for method in methods:\n            self.setUp()\n            try:\n                getattr(self, method)()\n            except UnitTestedAssignment.AssertionException as e:\n                gently(e.message)\n                all_passed = False\n            self.tearDown()\n        return all_passed\n\n    def assertSimilarStrings(self, first, second, msg):\n        if _normalize_string(first) != _normalize_string(second):\n            return self.assertEqual(first, second, msg, exact=True)\n\n    def assertNotSimilarStrings(self, first, second, msg):\n        if _normalize_string(first) == _normalize_string(second):\n            return self.assertEqual(first, second, msg, exact=True)\n\n    def assertLessEqual(self, val1, val2, msg=None):\n        if not (val1 <= val2):\n            self.fail(msg, \"{} is not less than or equal to {}\".format(safe_repr(val1), safe_repr(val2)))\n\n    def assertGreaterEqual(self, val1, val2, msg=None):\n        if not (val1 >= val2):\n            self.fail(msg, \"{} is not greater than or equal to {}\".format(safe_repr(val1), safe_repr(val2)))\n\n    def assertNotEqual(self, val1, val2, msg=None, exact=False):\n        if val1 != val2:\n            return\n        if not exact and isinstance(val1, str) and isinstance(val2, str):\n            self.assertNotSimilarStrings(val1, val2, msg)\n        elif (not exact and isinstance(val1, (int, float)) and\n              isinstance(val2, (int, float))):\n            if abs(val2 - val1) > UnitTestedAssignment.DELTA:\n                return\n        standardMsg = \"{} == {}\".format(safe_repr(val1), safe_repr(val2))\n        self.fail(msg, standardMsg)\n\n    def assertEqual(self, val1, val2, msg=None, exact=False):\n        if val1 == val2:\n            return\n        if not exact and isinstance(val1, str) and isinstance(val2, str):\n            self.assertSimilarStrings(val1, val2, msg)\n        elif (not exact and isinstance(val1, (int, float)) and\n              isinstance(val2, (int, float))):\n            if abs(val2 - val1) <= UnitTestedAssignment.DELTA:\n                return\n        standardMsg = \"{} != {}\".format(safe_repr(val1), safe_repr(val2))\n        self.fail(msg, standardMsg)\n\n    def assertIn(self, member, container, msg=None):\n        if member not in container:\n            standardMsg = \"{} not found in {}\".format(safe_repr(member),\n                                                      safe_repr(container))\n            self.fail(msg, standardMsg)\n\n    def assertNotIn(self, member, container, msg=None):\n        if member in container:\n            standardMsg = \"{} found in {}\".format(safe_repr(member),\n                                                  safe_repr(container))\n            self.fail(msg, standardMsg)\n\n    def assertTrue(self, value, msg=None):\n        if not value:\n            self.fail(msg, \"{} is not true\".format(value))\n\n    def assertFalse(self, value, msg=None):\n        if value:\n            self.fail(msg, \"{} is not false\".format(value))\n\n    def assertSandbox(self, sandbox, msg=None):\n        if sandbox.exception is not None:\n            self.fail(msg, sandbox.format_exception())\n\n    def assertIsInstance(self, value, parent, msg=None):\n        if not isinstance(value, parent):\n            self.fail(msg, \"{} is not an instance of {}\".format(safe_repr(value), safe_repr(parent)))\n\n    def assertHasAttr(self, object, attr, msg=None):\n        if not hasattr(object, attr):\n            self.fail(msg, \"{} does not have an attribute named {}\".format(safe_repr(object), safe_repr(attr)))\n\n    def fail(self, message, standardMsg):\n        if message is None:\n            message = standardMsg\n        raise UnitTestedAssignment.AssertionException(message)\n", "src/lib/pedal/plugins/check_references.py": "# Runner\nfrom pedal.report.imperative import clear_report\nimport sys\nimport os\nfrom io import StringIO\nfrom contextlib import redirect_stdout\nimport unittest\nfrom unittest.mock import patch, mock_open\n\n# Arguments\nGRADER_PATH = sys.argv[1]\nREFERENCE_SOLUTIONS_DIR = \"reference_solutions/\"\n\n# Load grader file\nwith open(GRADER_PATH, 'r') as grader_file:\n    grader_code = grader_file.read()\n\n# Load Pedal from dev location\nPEDAL_DIR = r\"C:/Users/acbart/projects/pedal/\"\nsys.path.insert(0, PEDAL_DIR)\n\n\n# Load reference solutions\n\n\nclass TestReferenceSolutions(unittest.TestCase):\n    maxDiff = None\n\n\ndef add_test(class_, name, python_file, expected_output):\n    def _inner_test(self):\n        captured_output = StringIO()\n        with redirect_stdout(captured_output):\n            # TODO: mock_open will only work if we are not anticipating\n            # the student or instructor to open files...\n            with patch('builtins.open', mock_open(read_data=python_file),\n                       create=True):\n                clear_report()\n                compile(grader_code, GRADER_PATH, 'exec')\n                exec(grader_code, globals())\n        actual_output = captured_output.getvalue()\n        self.assertEqual(actual_output, expected_output)\n\n    setattr(class_, 'test_' + name, _inner_test)\n\n\nfor filename in os.listdir(REFERENCE_SOLUTIONS_DIR):\n    path = os.path.join(REFERENCE_SOLUTIONS_DIR, filename)\n    if path.endswith(\".py\"):\n        text_path = path[:-2] + \"txt\"\n        with open(path, 'r') as python_file:\n            python = python_file.read()\n        with open(text_path, 'r') as output_file:\n            output = output_file.read()\n        add_test(TestReferenceSolutions, filename[:-3], python, output)\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "src/lib/pedal/plugins/blockpy_compatibility.py": "class GracefulExit(Exception):\n    pass\n\n\nclass StudentData:\n    def __init__(self):\n        pass\n\n    def get_names_by_type(self, type, exclude_builtins):\n        pass\n\n    def get_values_by_type(self, type, exclude_builtins):\n        pass\n\n\nstudent = StudentData()\n\n\ndef get_output():\n    pass\n\n\ndef reset_output():\n    pass\n\n\ndef queue_input(*inputs):\n    pass\n\n\ndef get_program():\n    pass\n\n\ndef parse_program():\n    pass\n\n\ndef had_execution_time_error():\n    pass\n\n\ndef limit_execution_time():\n    pass\n\n\ndef unlimit_execution_time():\n    pass\n\n\ndef analyze_program():\n    pass\n\n\ndef def_use_error(AstNode):\n    pass\n\n\nclass CorruptedAstNode:\n    def __init__(self):\n        pass\n\n\ndef find_match(instructor_code):\n    pass\n\n\ndef find_matches(instructor_code):\n    pass\n\n\nclass ASTMap:\n    def __init__(self, JSAstMap):\n        pass\n\n    def get_std_name(self, id):\n        pass\n\n    def get_std_exp(self, id):\n        pass\n\n\nclass AstNode:\n    def __init__(self, id):\n        pass\n\n    def __eq__(self, other):\n        pass\n\n    def numeric_logic_check(self, mag, expr):\n        pass\n\n    def __str__(self):\n        pass\n\n    def __repr__(self):\n        pass\n\n    def __getattr__(self, key):\n        pass\n\n    def has(self, AstNode):\n        pass\n\n    def find_all(self, type):\n        pass\n", "src/lib/pedal/plugins/__init__.py": "\n'''\ndef default_pipeline(tifa=False, cait=True, sandbox=True):\n    next_section()\n    results = []\n    if tifa:\n        results.append(tifa_analysis())\n    if cait:\n        results.append(parse_program())\n    if sandbox:\n        results.append(execute())\n    return tuple(results)\n'''\n", "src/lib/pedal/plugins/vpl.py": "from pedal.plugins.vpl_unittest import UnitTestedAssignment\n\n\"\"\"\nSome kind of function to break up the sections\n\"\"\"\nimport re\nimport sys\nfrom html.parser import HTMLParser\n\nfrom pedal.report import MAIN_REPORT\nfrom pedal import source\nfrom pedal.resolvers import sectional\nfrom pedal.cait.cait_api import expire_cait_cache\n\n\nclass VPLStyler(HTMLParser):\n    HEADERS = (\"h1\", \"h2\", \"h3\", \"h4\", \"h5\")\n\n    def __init__(self):\n        super().__init__()\n        self.reset()\n        self.fed = []\n        self.inside_pre = False\n\n    def convert(self, html):\n        self.feed(html)\n        return self.get_data()\n\n    @property\n    def text(self):\n        return ''.join(self.fed)\n\n    def get_data(self):\n        return self.text\n\n    def force_new_line(self):\n        if self.text and self.text[-1] not in (\"\\n\", \"\\r\"):\n            self.fed.append(\"\\n\")\n\n    def handle_starttag(self, tag, attrs):\n        if tag in self.HEADERS:\n            self.force_new_line()\n            self.fed.append(\"-\")\n        elif tag in (\"pre\",):\n            self.force_new_line()\n            self.fed.append(\">\")\n            self.inside_pre = True\n\n    def handle_data(self, data):\n        if self.inside_pre:\n            # Need to prepend \">\" to the start of new lines.\n            self.fed.append(data.replace(\"\\n\", \"\\n>\"))\n        else:\n            self.fed.append(data)\n\n    def handle_endtag(self, tag):\n        if tag in self.HEADERS:\n            self.fed.append(\"\")\n        elif tag in (\"pre\",):\n            self.fed.append(\"\")\n            self.inside_pre = False\n\n\ndef strip_tags(html):\n    return VPLStyler().convert(html)\n\n\ndef set_maximum_score(number, cap=True, report=None):\n    if report is None:\n        report = MAIN_REPORT\n    report['vpl']['score_maximum'] = number\n    report['vpl']['score_cap'] = cap\n\n\ndef resolve(report=None, custom_success_message=None):\n    if report is None:\n        report = MAIN_REPORT\n    print(\"<|--\")\n    success, score, hc, messages_by_group = sectional.resolve(report)\n    last_group = 0\n    for group, messages in sorted(messages_by_group.items()):\n        if group != last_group:\n            for intermediate_section in range(last_group, group, 2):\n                print(\"-\" + report['source']['sections'][1 + intermediate_section])\n        printed_first_bad = False\n        for message in messages:\n            if message['priority'] in ('positive', 'instructions'):\n                print(strip_tags(message['message']))\n            elif not printed_first_bad:\n                print(strip_tags(message['message']))\n                printed_first_bad = True\n        last_group = group\n    print(\"-Overall\")\n    if success:\n        if custom_success_message is None:\n            print(\"Complete! Great job!\")\n        else:\n            print(custom_success_message)\n    else:\n        print(\"Incomplete\")\n    print(\"--|>\")\n    print(\"Grade :=>>\", round(score))\n\n\nclass SectionalAssignment:\n    max_points = 1\n    sections = None\n\n    def __init__(self, filename=None, max_points=None, report=None):\n        self.report = MAIN_REPORT if report is None else report\n        find_file(filename if filename else self.filename,\n                  sections=True, report=report)\n        set_maximum_score(self.max_points\n                          if max_points is None else max_points)\n        source.check_section_exists(self.sections)\n\n    def pre_test(self):\n        source.next_section()\n        verified = source.verify_section()\n        expire_cait_cache()\n        return verified\n\n    def post_test(self):\n        return True\n\n    def resolve(self):\n        checks = ((self.pre_test() and\n                   getattr(self, attr)() and\n                   self.post_test())\n                  for attr in dir(self)\n                  if attr.startswith('test_') and\n                  callable(getattr(self, attr)))\n        if all(checks):\n            self.report.set_success()\n        resolve(report=self.report)\n\n\nfrom pedal.plugins.vpl_unittest import UnitTestedAssignment\n\n\ndef unittest_resolver(phases, report=None, custom_success_message=None):\n    success = True\n    for title, phase in phases:\n        outcome = phase()._run_all_tests()\n        if not outcome:\n            break\n        success = success and outcome\n    resolve(custom_success_message=custom_success_message)\n", "src/lib/pedal/plugins/vpl_safe_runner.py": "from pedal import run\nfrom pedal import set_source_file\nimport sys\n\nif __name__ == \"__main__\":\n    set_source_file(sys.argv[1] if len(sys.argv) > 1 else 'main.py')\n    student = run(context=False)\n    print(student.raw_output)\n    if student.exception:\n        print(student.exception_formatted, file=sys.stderr)\n", "src/lib/pedal/plugins/test_reference_solution.py": "'''\nTool for running a Grading script through a series of student reference\nsolutions.\n\npython -m pedal.plugins.test_reference_solution <path to grade script>\n'''\n\n# Runner\nfrom pedal.report.imperative import clear_report, MAIN_REPORT\nfrom pedal.cait import parse_program\nimport sys\nimport os\nfrom io import StringIO\nfrom contextlib import redirect_stdout\nimport unittest\nfrom unittest.mock import patch, mock_open\nimport argparse\n\n# Arguments\nDEFAULT_REFERENCE_SOLUTIONS_DIR = \"reference_solutions/\"\n\n\nclass TestReferenceSolutions(unittest.TestCase):\n    maxDiff = None\n\n\ndef substitute_args(arg, student_path, seed):\n    if arg == \"$_STUDENT_MAIN\":\n        return student_path\n    elif arg == \"$_STUDENT_NAME\":\n        return seed\n    return arg\n\n\ndef add_test(class_, name, python_file,\n             expected_output_path, expected_output,\n             grader_code, grader_path, grader_args, student_path):\n    seed = find_seed(python_file)\n    grader_args = [substitute_args(arg, student_path, seed) for arg in grader_args]\n    def _inner_test(self):\n        captured_output = StringIO()\n        with redirect_stdout(captured_output):\n            # TODO: mock_open will only work if we are not anticipating\n            # the student or instructor to open files...\n            with patch('builtins.open', mock_open(read_data=python_file),\n                       create=True):\n                with patch.object(sys, 'argv', grader_args):\n                    clear_report()\n                    grader_exec = compile(grader_code, grader_path, 'exec')\n                    exec(grader_exec, globals())\n                    #print(repr(MAIN_REPORT.feedback[0].mistake['error']))\n        actual_output = captured_output.getvalue()\n        if expected_output is None:\n            print(\"File not found:\", expected_output_path)\n            with open(expected_output_path, 'w') as out:\n                out.write(actual_output)\n            print(\"\\tCreated missing file with current output\")\n        else:\n            self.assertEqual(actual_output, expected_output)\n    setattr(class_, 'test_' + name, _inner_test)\n\ndef find_seed(python_code):\n    try:\n        ast = parse_program(python_code)\n        for assign in ast.find_all(\"Assign\"):\n            if assign.targets[0].ast_name != \"Name\":\n                continue\n            if assign.targets[0].id == \"__STUDENT_SEED__\":\n                if assign.value.ast_name == \"Str\":\n                    return assign.value.s\n                elif assign.value.ast_name == \"Num\":\n                    return assign.value.n\n                elif assign.value.ast_name == \"List\":\n                    return [e.n for e in assign.value.elts]\n    except SyntaxError:\n        return 0\n    return 0\n\n# Load reference solutions\ndef add_all_tests(grader_path, reference_solutions_dir, grader_args, limit):\n    # Load grader file\n    with open(grader_path, 'r') as grader_file:\n        grader_code = grader_file.read()\n    for filename in os.listdir(reference_solutions_dir):\n        if limit is not None and limit != filename:\n            continue\n        path = os.path.join(reference_solutions_dir, filename)\n        if path.endswith(\".py\"):\n            text_path = path[:-2] + \"txt\"\n            with open(path, 'r') as python_file:\n                python = python_file.read()\n            if os.path.exists(text_path):\n                with open(text_path, 'r') as output_file:\n                    output = output_file.read()\n            else:\n                output = None\n            add_test(TestReferenceSolutions, filename[:-3], python,\n                     text_path, output, \n                     grader_code, grader_path, grader_args, path)\n\n\ndef run_tests():\n    unittest.main(argv=['first-arg-is-ignored'])\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description='Run instructor grading script on a collection of reference solutions')\n    parser.add_argument('grader', help='The path to the instructor grading script.')\n    parser.add_argument('--path', '-p',\n                        help='The path to the student reference files. If not given, assumed to be in the same folder '\n                             'as the instructor grading script.',\n                        default=DEFAULT_REFERENCE_SOLUTIONS_DIR)\n    parser.add_argument('--args', '-a',\n                        help='Pass in arguments that the grading script will use. '\n                             'Variable substitutions include \"$_STUDENT_MAIN\".',\n                        default='test_reference_solution.py,$_STUDENT_MAIN,$_STUDENT_NAME')\n    parser.add_argument('--limit', '-l', help='Limit to a specific file.', default=None)\n    args = parser.parse_args()\n    \n    # Turn the reference solutions path into an absolute filename\n    if os.path.isabs(args.path):\n        reference_solutions_path = args.path\n    else:\n        reference_solutions_path = os.path.join(os.path.dirname(args.grader), args.path)\n    \n    # If no reference solutions folder, let's make it\n    if not os.path.exists(reference_solutions_path):\n        os.mkdir(reference_solutions_path)\n    \n    # Fix up the passed in args\n    grader_args = args.args.split(\",\")\n    \n    # Check that we actually have some files to try out\n    if not os.listdir(reference_solutions_path):\n        print(\"No reference solutions found\")\n    else:\n        add_all_tests(args.grader, reference_solutions_path, grader_args, args.limit)\n        run_tests()\n", "src/lib/pedal/plugins/grade_magic.py": "# Built-in imports\nimport json\nimport requests\n\n# IPython imports\nfrom IPython.core.magic import (Magics, magics_class, line_magic, cell_magic, line_cell_magic)\nfrom IPython.display import Javascript, display\nfrom IPython.utils.io import capture_output, CapturedIO\n\n# Logging imports\nimport os\nimport sys\nfrom warnings import warn\n# from traitlets import Bool\nimport time\n\n# TODO: Opportunity here to add in requests-cache. This would allow us to avoid\n# the repeated trip. However, you'll need to handle expiring the cache in a\n# smart way. One option is to write a command line script to just wipe as\n# necessary. Simply deleting the cache file would be pretty easy, assuming it\n# installs per user.\n\n# This really should come in as a configuration setting somewhere.\nBLOCKPY_URL = 'https://think.cs.vt.edu/blockpy/load_assignment_give_feedback'\n\n\ndef get_response_error(response):\n    \"\"\"\n    Transform a Response object into a friendlier string.\n\n    Args:\n        response (requests.Response): A Requests reponse object to parse for\n                                      some kind of error.\n    Returns:\n        str: A string representation of the URL response.\n    \"\"\"\n    return \"{} {}: {}\".format(response.status_code, response.reason,\n                              response.text)\n\n\ndef download_on_run(assignment_id):\n    \"\"\"\n    Download the on_run (give_feedback) code to use to test their solution.\n\n    Args:\n        assignment_id (int OR str): The ID of the assignment to get the\n                                    on_run code for.\n    Returns:\n        bool: Whether or not the request was successful.\n        str: If unsuccesful, a message to display to the user. Otherwise, it'll\n             be the on_run code.\n    \"\"\"\n    data = {'assignment_id': assignment_id}\n    try:\n        response = requests.get(BLOCKPY_URL, data=data)\n    except Exception as error:\n        return False, str(error)\n    try:\n        result = response.json()\n    except ValueError:\n        # Failed to parse the JSON; perhaps it was some text data?\n        return False, get_response_error(response)\n    if result['success']:\n        return True, result['give_feedback']\n    else:\n        return False, result['message']\n\n\nPEDAL_PIPELINE = '''\nfrom pedal.report import *\nfrom pedal.report.imperative import *\nclear_report()\nfrom pedal.source import set_source\nset_source({student_code})\nfrom pedal.tifa import tifa_analysis\ntifa_analysis(True)\nfrom pedal.sandbox.compatibility import *\nqueue_input({inputs})\nrun_student(True)\nstudent = get_sandbox()\nfrom pedal.cait.cait_api import parse_program\n{on_run}\nfrom pedal.resolvers import simple\nSUCCESS, SCORE, CATEGORY, LABEL, MESSAGE, DATA, HIDE = simple.resolve()\n'''\n\n\ndef blockpy_grade(assignment_id, student_code, inputs):\n    \"\"\"\n    Helper function to capture the request from the server.\n\n    Args:\n        assignment_id (int): The assignment ID to look up and use the on_run\n                             code for.\n        student_code (str): The code that was written by the student.\n\n        inputs (str): The inputs to queue into the assignment\n\n    Returns:\n        str: The HTML formatted feedback for the student.\n    \"\"\"\n    successful_download, on_run = download_on_run(assignment_id)\n    # If it failed, let's display some information about why.\n    if not successful_download:\n        return on_run\n    return execute_on_run_code(on_run, student_code, inputs)\n\n\ndef execute_on_run_code(on_run, student_code, inputs):\n    \"\"\"\n    Actually execute the on_run code for the given student code.\n    \"\"\"\n    # Even though the student code is a string, we need to escape it to prevent\n    # any weirdness from being in the instructor code.\n    escaped_student_code = json.dumps(student_code)\n    instructor_code = PEDAL_PIPELINE.format(on_run=on_run,\n                                            student_code=escaped_student_code,\n                                            # inputs=','.join(inputs))\n                                            inputs=inputs)\n    # Execute the instructor code in a new environment\n    global_variables = globals()\n    compiled_code = compile(instructor_code, 'instructor_code.py', 'exec')\n    exec(compiled_code, global_variables)\n    category = global_variables['CATEGORY']\n    label = global_variables['LABEL']\n    message = global_variables['MESSAGE']\n    # In some cases, we might want to override how the text is rendered.\n    if category.lower() == 'instructor' and label.lower() == 'explain':\n        category = \"Instructor Feedback\"\n        label = ''\n    # Return the result as HTML\n    return '''<strong>{}</strong>: {}<br>{}'''.format(category, label, message)\n\n\n# The following string literals are used to create the JavaScript code that\n# creates the Python code that will execute the instructor's feedback code\n# using the student's Python code.\n\n# Extract out the student code, embed the result\nEXTRACT_STUDENT_CODE = r\"\"\"\n// Convert Notebook cells to a string of Python code\nvar makePython = function(cell) {\n    if (cell.cell_type == \"code\") {\n        // Code is embedded unchanged, unless it is magic\n        var source = cell.get_text();\n        if (source.startsWith('%')) {\n            // Skip magic\n            return '';\n        } else {\n            return source;\n        }\n    } else if (cell.cell_type == \"markdown\" ||\n               cell.cell_type == \"raw\") {\n        // Markdown and text is wrapped in a string.\n        var escaped_text = cell.get_text().replace(/'''/g, \"\\\\'\\\\'\\\\'\");\n        return \"'''\"+escaped_text+\"'''\";\n    }\n}\nvar isUsable = function(cell) {\n    return cell.cell_type == \"code\" ||\n           cell.cell_type == \"markdown\" ||\n           cell.cell_type == \"raw\";\n}\nvar cells = Jupyter.notebook.get_cells();\nvar source_code = cells.filter(isUsable).map(makePython).join(\"\\n\");\nsource_code = JSON.stringify(source_code);\nconsole.log(source_code);\n// Start constructing the feedback code (which will be Python).\nvar on_run_code = [];\non_run_code.push(\"student_code=\"+source_code);\n\"\"\"\n\n# Retrieve the last cell, and also recolor it a little for style\nANIMATE_LAST_CELL = r\"\"\"\n// While we are accessing the server, recolor the last cell a little.\nvar last = null;\nif (cells.length > 0) {\n    last = cells[cells.length-1];\n    $(last.element).animate({\"background-color\": \"#E0E6FF\"}, 1000);\n}\n\"\"\"\n\n# If the %grade magic is used, we run the code directly.\nLOCAL_GRADE = r'''\non_run_code.push(\"from pedal.plugins.grade_magic import execute_on_run_code\");\non_run_code.push('print(execute_on_run_code({on_run_code}, student_code, {inputs}))');\n'''\n\n# If the %grade_blockpy magic is used, we need to get the on_run from blockpy.\nBLOCKPY_GRADE = r'''\non_run_code.push(\"from pedal.plugins.grade_magic import blockpy_grade\");\non_run_code.push('import json')\non_run_code.push('inputs = {inputs}')\nconsole.log('inputs = {inputs}')\non_run_code.push(\"print(blockpy_grade({assignment}, student_code, inputs))\");\n'''\n\n# This chunk actually performs the on_run code execution using the kernel.\nEXECUTE_CODE = r'''\non_run_code = on_run_code.join(\"\\n\");\nconsole.log(on_run_code);\nvar kernel = IPython.notebook.kernel;\nif (kernel !== null) {\n    var t = kernel.execute(on_run_code, { 'iopub' : {'output' : function(x) {\n        if (x.msg_type == \"error\") {\n            // If this was an error, show the traceback properly.\n            if (last !== null) {\n                last.output_area.append_error(x.content);\n                console.error(x);\n            } else {\n                console.error(\"Could not append to final cell.\", x);\n            }\n        } else if (!x.content.data && x.content.text) {\n            // If it was valid data, we show it as HTML.\n            console.log(x);\n            element.html(x.content.text.replace(/\\n/g, \"<br>\"));\n        } else {\n            // I'm not sure what it is - better dump it on the console.\n            console.log(x);\n        }\n        // Decolor the last cell if it was there.\n        if (last !== null) {\n            last = cells[cells.length-1];\n            $(last.element).animate({\"background-color\": \"white\"}, 1000);\n        }\n    }}});\n}'''\n\n\n@magics_class\nclass GradeMagic(Magics):\n    \"\"\"\n    This class holds the magic for the %grade and %grade_blockpy\n    \"\"\"\n\n    @line_magic\n    def grade_logstart(self, line=\"\"):\n        # ######Logging\n        ts = time.time()\n        logger = self.shell.logger  # logging\n        old_logfile = self.shell.logfile  # logging\n        directory = os.path.expanduser(\"log_folder{}~/\".format(line))\n        logfname = os.path.expanduser(\"log_folder{}~/log_{}.py~\".format(line, ts))\n        self.shell.logfile = logfname\n        loghead = u'# IPython log file\\n\\n'\n        try:\n            os.makedirs(directory, exist_ok=True)\n            logger.logstart(logfname, loghead, 'rotate', True, True,\n                            True)\n        except BaseException:\n            self.shell.logfile = old_logfile\n            warn(\"Couldn't start log: %s\" % sys.exc_info()[1])\n        self.shell.run_code(\"input = __builtins__.input\")\n        self.shell.run_code(\"print = __builtins__.print\")\n        self.shell.run_code(\"sum = __builtins__.sum\")\n        self.shell.run_code(\"len = __builtins__.len\")\n\n    @line_magic\n    def grade_logstop(self, line=\"\"):\n        self.shell.logger.logstop()\n\n    def logging(self):\n        # ######Logging\n        ts = time.time()\n        logger = self.shell.logger  # logging\n        old_logfile = self.shell.logfile  # logging\n        logfname = os.path.expanduser(\"log_folder~/log_{}.py~\".format(ts))\n        self.shell.logfile = logfname\n        loghead = u'# IPython log file\\n\\n'\n        try:\n            logger.logstart(logfname, loghead, 'rotate', False, True,\n                            True)\n        except BaseException:\n            self.shell.logfile = old_logfile\n            warn(\"Couldn't start log: %s\" % sys.exc_info()[1])\n        logger.timestamp = False\n        input_hist = self.shell.history_manager.input_hist_raw\n        logger.log_write(u'\\n'.join(input_hist[1:]))\n        logger.log_write(u'\\n')\n        logger.timestamp = True\n        self.shell.logger.logstop()\n        # ######Logging\n\n    # noinspection PyMethodMayBeStatic\n    def grade_parser(self, line, cell=None):\n        if ',' in line:\n            if cell is None:\n                assignment, line = line.split(\",\", maxsplit=1)\n            else:\n                assignment = None\n            inputs = json.dumps(line.split(\",\"))\n            inputs = \"\\\\'\" + inputs[1:len(inputs) - 1] + \"\\\\'\"\n        else:\n            if cell is None:\n                assignment, inputs = line, \"\"\n            else:\n                inputs = line\n                assignment = \"\"\n            inputs = json.dumps(inputs)\n        return {\"inputs\": inputs, \"assignment\": assignment}\n\n    # noinspection PyMethodMayBeStatic\n    def unified_helper(self, local_code, **kwargs):\n        code = EXTRACT_STUDENT_CODE\n        code += ANIMATE_LAST_CELL\n        code += local_code.format(**kwargs)\n        code += EXECUTE_CODE\n        return code\n\n    @cell_magic\n    def grade(self, line=\"\", cell=\"\"):\n        dump = self.grade_parser(line, cell)\n        code = self.unified_helper(LOCAL_GRADE, on_run_code=\"INSTRUCTOR_CODE\", inputs=dump['inputs'])\n        cell = cell.replace(\"\\\\\", \"\\\\\\\\\")\n        cell = cell.replace(\"\\n\", \"\\\\n\")\n        cell = cell.replace(\"'\", \"\\\\'\")\n        cell = cell.replace('\"', '\\\\\"')\n        # Runs this code in the kernel as python code\n        # Can also run compiled code\n        self.shell.run_code(\"INSTRUCTOR_CODE = \" + '\"' + cell + '\"')\n        # TODO: This was the easier way for me to get this to work\n        #  This might be worth using in more depth to have less translation\n        #  to and from javascript. See usage_examples\n        return display(Javascript(code))\n\n    @line_cell_magic\n    def usage_examples(self, line=\"\", cell=\"print('running cell')\\nprint('running cell2')\"):\n        # Runs code in the kernel's context\n        self.shell.run_code(\"print('fun')\")\n\n        # Runs code in kernel's context using compiled code\n        sample = compile(cell, \"usage_examples.py\", \"exec\")\n        self.shell.run_code(sample)\n\n        # runs javascript code\n        self.shell.run_cell_magic(\"javascript\", \"\", \"console.log('I do JAVASCRIPT');\\n\")\n        # Maybe can use javascript execution to pass things around...not sure though...can't get it to work\n        # You can pass values, but it doesn't seem to work unless you run it again.\n        # https://michhar.github.io/javascript-and-python-have-a-party/\n\n        self.shell.run_cell_magic(\n            \"javascript\", \"\",\n            # js_code = Javascript(\n            \"\"\"var callbacks = { iopub : { output: function(out_data){ console.log(out_data) } } };\\n\"\"\"\n            \"\"\"var code = \"fun = 12\";\\n\"\"\"\n            \"\"\"IPython.notebook.kernel.execute(code);\\n\"\"\")\n        # handle = display(js_code, display_id=\"usage_examples\")\n        # handle.update(handle)\n        self.shell.run_cell_magic(\"javascript\", \"\", \"console.log('I do JAVASCRIPT TOO!!');\\n\")\n        # captures standard output, standard error, etc. and stops or not stops it\n        # class IPython.utils.capture.capture_output(stdout=True, stderr=True, display=True)\n        # Note that Tracebacks aren't put in standard error?\n        with capture_output(True, False, False) as captured:\n            print(dir(self))\n            self.shell.run_code(\"print(fun)\")\n            sys.stderr.write(\"spam\\n\")\n        print(\"I captured stdout\")\n        print(captured.stdout)\n        print(\"I captured stderr\")\n        print(captured.stderr)\n\n    @line_magic\n    def grade_blockpy(self, line=\"\"):\n        dump = self.grade_parser(line)\n        code = self.unified_helper(BLOCKPY_GRADE, assignment=dump[\"assignment\"], inputs=dump[\"inputs\"])\n        return display(Javascript(code))\n\n\ndef load_ipython_extension(ipython):\n    \"\"\"\n    Register this plugin with Jupyter Notebooks. Although it is allegedly\n    necessary in order to make this a plugin, we do not actually use it.\n    \"\"\"\n    ipython.register_magics(GradeMagic)\n\n\n\"\"\"\nDEPRECATED: The following lines of code do not seem to be necessary to\n            register this plugin with Jupyter.\ndef _jupyter_server_extension_paths():\n    return [{\n        \"module\": \"pedal.plugins.grade_magic\"\n    }]\n\n# jupyter serverextension enable --py pedal.plugins.grade_magic\ndef load_jupyter_server_extension(nbapp):\n    from IPython import get_ipython\n    get_ipython().register_magics(GradeMagic)\n\"\"\"\n", "src/lib/pedal/source/sections.py": "from pedal.report import MAIN_REPORT\nimport ast\n\n\n#def move_to_section(section_number, name, report=None):\n#    pass\n\ndef _calculate_section_number(section_index):\n    return int((section_index+1)/2)\n\ndef next_section(name=\"\", report=None):\n    if report is None:\n        report = MAIN_REPORT\n    source = report['source']\n    if not report['source']['success']:\n        return False\n    source['section'] += 2\n    section_index = source['section']\n    section_number = _calculate_section_number(section_index)\n    sections = source['sections']\n    found = len(source['sections'])\n    if section_index < found:\n        if source['independent']:\n            source['code'] = ''.join(sections[section_index])\n            old_code = ''.join(sections[:section_index])\n            source['line_offset'] = len(old_code.split(\"\\n\"))-1\n        else:\n            source['code'] = ''.join(sections[:section_index + 1])\n        report.group = section_index\n    else:\n        report.attach('Syntax error', category='Syntax', tool='Source',\n                      mistake=(\"Tried to advance to next section but the \"\n                               \"section was not found. Tried to load section \"\n                               \"{count}, but there were only {found} sections.\"\n                               ).format(count=section_number, found=found))\n\ndef check_section_exists(section_number, report=None):\n    \"\"\"\n    Checks that the right number of sections exist. The prologue before the\n    first section is 0, while subsequent ones are 1, 2, 3, etc. \n    So if you have 3 sections in your code plus the prologue,\n    you should pass in 3 and not 4 to verify that all of them exist.\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    if not report['source']['success']:\n        return False\n    found = int((len(report['source']['sections']) - 1) / 2)\n    if section_number > found:\n        report.attach('Syntax error', category='Syntax', tool='Source',\n                      group=report['source']['section'],\n                      mistake=(\"Incorrect number of sections in your file. \"\n                               \"Expected {count}, but only found {found}\"\n                               ).format(count=section_number, found=found))\n\n\ndef verify_section(report=None):\n    if report is None:\n        report = MAIN_REPORT\n    source = report['source']\n    if not source['success']:\n        return False\n    code = source['code']\n    try:\n        parsed = ast.parse(code, source['filename'])\n        source['ast'] = parsed\n    except SyntaxError as e:\n        report.attach('Syntax error', category='Syntax', tool='Source',\n                      group=source['section'],\n                      mistake={'message': \"Invalid syntax on line \"\n                                          + str(e.lineno+source['line_offset']),\n                               'error': e,\n                               'position': {\"line\": e.lineno}})\n        source['success'] = False\n        if 'ast' in source:\n            del source['ast']\n    return source['success']\n\n\nclass _finish_section:\n    def __init__(self, number, *functions):\n        if isinstance(number, int):\n            self.number = number\n        else:\n            self.number = -1\n            functions = [number] + list(functions)\n        self.functions = functions\n        for function in functions:\n            self(function, False)\n\n    def __call__(self, f=None, quiet=True):\n        if f is not None:\n            f()\n        if quiet:\n            print(\"\\tNEXT SECTION\")\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, x, y, z):\n        print(\"\\tNEXT SECTION\")\n        # return wrapped_f\n\n\ndef finish_section(number, *functions, **kwargs):\n    if 'next_section' in kwargs:\n        next_section = kwargs['next_section']\n    else:\n        next_section = False\n    if len(functions) == 0:\n        x = _finish_section(number, *functions)\n        x()\n    else:\n        result = _finish_section(number, *functions)\n        if next_section:\n            print(\"\\tNEXT SECTION\")\n        return result\n\n\ndef section(number):\n    \"\"\"\n    \"\"\"\n    pass\n\n\ndef precondition(function):\n    pass\n\n\ndef postcondition(function):\n    pass\n", "src/lib/pedal/source/__init__.py": "\"\"\"\nA package for verifying source code.\n\"\"\"\n\nfrom pedal.source.sections import *\nfrom pedal.report import MAIN_REPORT\nimport re\nimport ast\n\nNAME = 'Source'\nSHORT_DESCRIPTION = \"Verifies source code and attaches it to the report\"\nDESCRIPTION = '''\n'''\nREQUIRES = []\nOPTIONALS = []\nCATEGORY = 'Syntax'\n\n__all__ = ['NAME', 'DESCRIPTION', 'SHORT_DESCRIPTION', 'REQUIRES', 'OPTIONALS',\n           'set_source', 'check_section_exists', 'next_section', 'verify_section',\n           'set_source_file']\nDEFAULT_PATTERN = r'^(##### Part .+)$'\n\n\ndef set_source(code, filename='__main__.py', sections=False, independent=False,\n               report=None):\n    \"\"\"\n    Sets the contents of the Source to be the given code. Can also be\n    optionally given a filename.\n\n    Args:\n        code (str): The contents of the source file.\n        filename (str): The filename of the students' code. Defaults to\n                        __main__.py.\n        sections (str or bool): Whether or not the file should be divided into\n                                sections. If a str, then it should be a\n                                Python regular expression for how the sections\n                                are separated. If False, there will be no\n                                sections. If True, then the default pattern\n                                will be used: '^##### Part (\\\\d+)$'\n        report (Report): The report object to store data and feedback in. If\n                         left None, defaults to the global MAIN_REPORT.\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    report['source']['code'] = code\n    report['source']['full'] = code\n    report['source']['lines'] = code.split(\"\\n\")\n    report['source']['filename'] = filename\n    report['source']['independent'] = independent\n    report['source']['success'] = True\n    if not sections:\n        report['source']['sections'] = None\n        report['source']['section'] = None\n        _check_issues(code, report)\n    else:\n        if sections:\n            pattern = DEFAULT_PATTERN\n        else:\n            pattern = sections\n        report.group = 0\n        report['source']['section_pattern'] = pattern\n        report['source']['section'] = 0\n        report['source']['line_offset'] = 0\n        report['source']['sections'] = re.split(pattern, code,\n                                                flags=re.MULTILINE)\n        report['source']['code'] = report['source']['sections'][0]\n\n\ndef _check_issues(code, report):\n    if code.strip() == '':\n        report.attach('Blank source', category='Syntax', tool=NAME,\n                      group=report['source']['section'],\n                      mistake=\"Source code file is blank.\")\n        report['source']['success'] = False\n    try:\n        parsed = ast.parse(code, report['source']['filename'])\n        report['source']['ast'] = parsed\n    except SyntaxError as e:\n        report.attach('Syntax error', category='Syntax', tool='Source',\n                      group=report['source']['section'],\n                      mistake={'message': \"Invalid syntax on line \"\n                                          + str(e.lineno),\n                               'error': e,\n                               'position': {\"line\": e.lineno}})\n        report['source']['success'] = False\n        report['source']['ast'] = ast.parse(\"\")\n\n\ndef get_program(report=None):\n    if report is None:\n        report = MAIN_REPORT\n    return report['source']['code']\n\ndef set_source_file(filename, sections=False, independent=False, report=None):\n    if report is None:\n        report = MAIN_REPORT\n    try:\n        with open(filename, 'r') as student_file:\n            set_source(student_file.read(), filename=filename,\n                       sections=sections, independent=independent,\n                       report=report)\n    except IOError:\n        message = (\"The given filename ('{filename}') was either not found\"\n                   \" or could not be opened. Please make sure the file is\"\n                   \" available.\").format(filename=filename)\n        report.attach('Source File Not Found', category='Syntax', tool='Source',\n                      group=0 if sections else None,\n                      mistake={'message': message})\n        report['source']['success'] = False\n", "src/lib/pedal/mistakes/instructor_append.py": "from pedal.cait.cait_api import find_matches, find_expr_sub_matches, data_state\nfrom pedal.mistakes.feedback_mod import *\n\n\ndef append_group_on_change():\n    wrong_not_append_to_list()\n\n\ndef append_group():\n    missing_append_in_iteration()\n    missing_append_list_initialization()\n    wrong_append_list_initialization()\n    wrong_not_append_to_list()\n    append_list_wrong_slot()\n    # TODO: add app_assign on next iteration of experiment!\n    # app_assign()\n\n\ndef find_append_in(node):\n    append_list = []\n    calls = node.find_all(\"Call\")\n    for node in calls:\n        if node.func.attr == \"append\":\n            append_list.append(node)\n    return append_list\n\n\n\"\"\"\ndef missing_append_in_iteration():\n    std_ast = parse_program()\n    for_loops = std_ast.find_all(\"For\")\n    for loop in for_loops:\n        if len(find_append_in(loop)):\n            return False\n    explain(\"You must construct a list by appending values one at a time to the list.<br><br><i>(app_in_iter)<i></br>\")\n    return True\n\"\"\"\n\n\ndef missing_append_in_iteration():\n    matches = find_matches(\"for ___ in ___:\\n\"\n                           \"    __expr__\")\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            submatch = __expr__.find_matches(\"___.append(___)\")\n            if submatch:\n                return False\n        explain(\"You must construct a list by appending values one at a time to the list.\"\n                \"<br><br><i>(app_in_iter)<i></br>\")\n        return True\n    return False\n\n\ndef wrong_not_append_to_list():\n    matches = find_matches(\"for ___ in ___:\\n\"\n                           \"    __expr__\")\n    for match in matches:\n        __expr__ = match[\"__expr__\"]\n        submatches = __expr__.find_matches(\"_target_.append(___)\")\n        for submatch in submatches:\n            _target_ = submatch[\"_target_\"]\n            if not data_state(_target_).was_type('list'):\n                explain(\"Values can only be appended to a list. The variable <code>{0!s}</code> is either \"\n                        \"not initialized, not initialized correctly, or is confused with another variable.\"\n                        \"<br><br><i>(app_not_list)<i></br>\".format(_target_))\n                return True\n    return False\n\n\ndef missing_append_list_initialization():\n    matches = find_matches(\"for ___ in ___:\\n\"\n                           \"    __expr__\")\n    for match in matches:\n        __expr__ = match[\"__expr__\"]\n        submatches = __expr__.find_matches(\"_new_list_.append(___)\", )\n        for submatch in submatches:\n            _new_list_ = submatch[\"_new_list_\"].astNode\n            matches02 = find_matches(\"{} = []\\n\"\n                                     \"for ___ in ___:\\n\"\n                                     \"    __expr__\".format(_new_list_.id))\n            if not matches02:\n                explain(\"The list variable <code>{0!s}</code> must be initialized.<br><br><i>\"\n                        \"(no_app_list_init)<i></br>\".format(_new_list_.id))\n                return True\n    return False\n\n\ndef wrong_append_list_initialization():\n    matches = find_matches(\"_list_ = __expr1__\\n\"\n                           \"for ___ in ___:\\n\"\n                           \"    __expr2__\")\n    for match in matches:\n        _list_ = match[\"_list_\"].astNode\n        __expr1__ = match[\"__expr1__\"]\n        __expr2__ = match[\"__expr2__\"]\n        submatch = find_expr_sub_matches(\"{}.append(___)\".format(_list_.id), __expr2__)\n        if submatch and (__expr1__.ast_name == \"List\" and\n                         len(__expr1__.elts) != 0 or\n                         __expr1__.ast_name != \"List\"):\n            explain(\"The list variable <code>{0!s}</code> is either not \"\n                    \"initialized correctly or mistaken for\"\n                    \" another variable. The list you append to should be \"\n                    \"initialized to an empty list.<br><br><i>\"\n                    \"(app_list_init)<i></br>\".format(_list_.id))\n            return True\n    return False\n\n\ndef append_list_wrong_slot():\n    matches = find_matches(\"_target_.append(_item_)\")\n    if matches:\n        for match in matches:\n            _item_ = match[\"_item_\"].astNode\n            _target_ = match[\"_target_\"].astNode\n            if data_state(_item_).was_type('list'):\n                explain(\"You should not append a list (<code>{0!s}</code>) to <code>{1!s}</code>.<br><br><i>\"\n                        \"(app_list_slot)<i></br>\".format(_item_.id, _target_.id))\n                return True\n    return False\n\n\ndef app_assign():\n    message = (\"Appending modifies the list, so unlike addition,\"\n               \" an assignment statement is not needed when using append.\")\n    code = \"app_asgn\"\n\n    matches = find_matches(\"_sum_ = _sum_.append(__exp__)\")\n    if matches:\n        return explain_r(message, code)\n    return False\n", "src/lib/pedal/mistakes/instructor_filter.py": "from pedal.cait.cait_api import find_match, find_matches\nfrom pedal.report.imperative import explain\n\n\ndef filter_group():\n    missing_if_in_for()\n    append_not_in_if()\n\n\ndef missing_if_in_for():\n    \"\"\"\n    Name: missing_if_in_for\n    Pattern:\n    missing\n    for <item> in ___ :\n        if ...<item> ... :\n\n    Feedback: The arrangement of decision and iteration is not correct for the filter pattern.\n    Returns:\n\n    \"\"\"\n    matches = find_matches(\"for _item_ in ___:\\n\"\n                           \"    if __expr__:\\n\"\n                           \"        pass\")\n    if not matches:\n        explain(\"The arrangement of decision and iteration is not correct for the filter pattern.<br><br><i>\"\n                \"(missing_if_in_for)<i></br></br>\")\n        return True\n    return False\n\n\ndef append_not_in_if():\n    \"\"\"\n    Name: append_not_in_if\n    Pattern:\n    missing\n    if ... :\n       ___.append(___)\n\n    Feedback: Only items satisfying some condition should be appended to the list.\n\n    Returns:\n    \"\"\"\n    match = find_match(\"if ___:\\n\"\n                       \"    ___.append(___)\")\n    if not match:\n        explain(\n            \"Only items satisfying some condition should be appended to the list.<br><br><i>(app_not_in_if)<i></br>\")\n        return True\n    return False\n", "src/lib/pedal/mistakes/__init__.py": "", "src/lib/pedal/mistakes/feedback_mod.py": "from pedal.report.imperative import explain, gently\n\n\ndef gently_r(message, code, line=None, tldr=\"explain\"):\n    gently(message + \"<br><br><i>({})<i></br></br>\".format(code), line, label=tldr)\n    return message\n\n\ndef explain_r(message, code, priority='medium', line=None, tldr=\"explain\"):\n    explain(message + \"<br><br><i>({})<i></br></br>\".format(code), priority, line, label=tldr)\n    return message\n\n\ndef codify(code):\n    return \"<code>\" + code + \"</code>\"\n", "src/lib/pedal/mistakes/instructor_iteration.py": "from pedal.cait.cait_api import (parse_program, find_match, find_matches,\n                                 find_expr_sub_matches, data_state,\n                                 def_use_error)\nfrom pedal.report.imperative import explain\n\n\ndef iteration_group():\n    list_initialization_misplaced()\n    wrong_target_is_list()\n    wrong_list_repeated_in_for()\n    missing_iterator_initialization()\n    list_not_initialized_on_run()\n    wrong_iterator_not_list()\n    missing_target_slot_empty()\n    missing_for_slot_empty()\n    wrong_target_reassigned()\n\n\ndef iteration_group_on_change():\n    wrong_target_is_list()\n    wrong_list_repeated_in_for()\n    wrong_iterator_not_list()\n\n\ndef all_for_loops():\n    std_ast = parse_program()\n    return std_ast.find_all(\"For\")\n\n\n# this conflics with list_repeated_in_for\ndef wrong_target_is_list():\n    match = find_match(\"for _item_ in ___:\\n    pass\")\n    if match:\n        _item_ = match[\"_item_\"].astNode\n        if data_state(_item_).was_type('list'):\n            explain('The variable <code>{0!s}</code> is a list and should not be placed in the iteration variable slot'\n                    ' of the \"for\" block<br><br><i>(target_is_list)<i></br>.'.format(_item_.id))\n            return True\n    return False\n\n\n# this conflicts with list_in_wrong_slot_in_for\ndef wrong_list_repeated_in_for():\n    match = find_match(\"for _item_ in _item_:\\n    pass\")\n    if match:\n        _item_ = match[\"_item_\"].astNode\n        if data_state(_item_).was_type('list'):\n            explain('The <code>{0!s}</code> variable can only appear once in the \"for\" block <br><br><i>'\n                    '(list_repeat)<i></br>'.format(_item_.id))\n            return True\n    return False\n\n\n# this isn't consistent with the pattern you wrote\ndef missing_iterator_initialization():\n    match = find_match(\"for ___ in _list_:\\n    pass\")\n    if match:\n        _list_ = match[\"_list_\"].astNode\n        if _list_.id == \"___\":\n            explain(\"The slot to hold a list in the iteration is empty.<br><br><i>(no_iter_init-blank)<i></br>\")\n            return True\n        elif not data_state(_list_).was_type('list'):\n            explain(\"The variable <code>{0!s}</code> is in the list slot of the iteration but is not a list.\"\n                    \"<br><br><i>(no_iter_init)<i></br>\".format(_list_.id))\n            return True\n    return False\n\n\n# TODO: We need to cover the different cases for these\ndef wrong_iterator_not_list():\n    match = find_match(\"for ___ in _item_:\\n    pass\")\n    if match:\n        _item_ = match[\"_item_\"].astNode\n        if not data_state(_item_).was_type('list'):\n            explain(\"The variable <code>{0!s}</code> has been set to something that is not a list but is placed in the \"\n                    \"iteration block that must be a list.<br><br><i>(iter_not_list)<i></br>\".format(_item_.id))\n            return True\n    return False\n\n\ndef missing_target_slot_empty():\n    match = find_match(\"for _item_ in ___:\\n    pass\")\n    if match:\n        _item_ = match[\"_item_\"].astNode\n        if _item_.id == \"___\":\n            explain(\"You must fill in the empty slot in the iteration.<br><br><i>(target_empty)<i></br>\")\n            return True\n    return False\n\n\ndef list_not_initialized_on_run():\n    match = find_match(\"for ___ in _item_:\\n    pass\")\n    if match:\n        _item_ = match[\"_item_\"][0].astNode\n        if def_use_error(_item_):\n            explain(\"The list in your for loop has not been initialized<br><br><i>(no_list_init)<i></br>\")\n            return True\n    return False\n\n\ndef list_initialization_misplaced():\n    match = find_match(\"for ___ in _item_:\\n    pass\")\n    if match:\n        _item_ = match[\"_item_\"][0].astNode\n        if data_state(_item_).was_type('list') and def_use_error(_item_):\n            explain(\"Initialization of <code>{0!s}</code> is a list but either in the wrong place or redefined\"\n                    \"<br><br><i>(list_init_misplaced)<i></br>\".format(_item_.id))\n            return True\n    return False\n\n\ndef missing_for_slot_empty():\n    match = find_match(\"for _item_ in _list_:\\n    pass\")\n    if match:\n        _item_ = match[\"_item_\"][0].astNode\n        _list_ = match[\"_list_\"][0].astNode\n        if _item_.id == \"___\" or _list_.id == \"___\":\n            explain(\"You must fill in the empty slot in the iteration.<br><br><i>(for_incomplete)<i></br>\")\n            return True\n    return False\n\n\ndef wrong_target_reassigned():\n    matches = find_matches(\"for _item_ in ___:\\n\"\n                           \"   __expr__\")\n    for match in matches:\n        __expr__ = match[\"__expr__\"]\n        _item_ = match[\"_item_\"][0]\n        submatches = __expr__.find_matches(\"{} = ___\".format(_item_), )\n        if submatches:\n            explain(\"The variable <code>{0!s}</code> has been reassigned. \"\n                    \"The iteration variable shouldn't be reassigned\"\n                    \"<br><br><i>(target_reassign)<i></br>\".format(_item_))\n            return True\n    return False\n", "src/lib/pedal/mistakes/iteration_context.py": "from pedal.cait.cait_api import (parse_program,\n                                 find_matches, find_match,\n                                 find_expr_sub_matches)\nfrom pedal.report.imperative import explain, gently\nimport pedal.mistakes.instructor_append as append_api\nfrom pedal.toolkit.utilities import *\nfrom pedal.sandbox.compatibility import get_output\n\n\n# ################8.2 Start#######################\ndef wrong_list_length_8_2():\n    matches = find_matches(\"_list_ = __expr__\")\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            if __expr__.ast_name == \"List\" and len(__expr__.elts) < 3:\n                explain('You must have at least three pieces<br><br><i>(list length_8.2)<i></br>')\n                return True\n    return False\n\n\ndef missing_list_initialization_8_2():\n    matches = find_matches(\"shopping_cart = __expr__\")\n    for match in matches:\n        __expr__ = match[\"__expr__\"]\n        if __expr__.ast_name == \"List\":\n            return False\n    explain(\n        'You must set the variable <code>shopping_cart</code> to a list containing the prices of items in the'\n        ' shopping cart.<br><br><i>(missing_list_init_8.2)<i></br>')\n    return True\n\n\ndef wrong_list_is_constant_8_2():\n    matches = find_matches(\"shopping_cart = __expr__\")\n    for match in matches:\n        __expr__ = match[\"__expr__\"]\n        if __expr__.ast_name == \"Num\":\n            explain(\n                'You must set <code>shoppping_cart</code> to a list of values not to a single number.<br><br><i>'\n                '(list_is_const_8.2)<i></br>')\n            return True\n    return False\n\n\ndef list_all_zeros_8_2():\n    std_ast = parse_program()\n    lists = std_ast.find_all('List')\n    is_all_zero = True\n    for init_list in lists:\n        for node in init_list.elts:\n            if node.ast_name == 'Num' and node.n != 0:\n                is_all_zero = False\n                break\n        if is_all_zero:\n            break\n    if is_all_zero:\n        explain('Try seeing what happens when you change the numbers in the list.<br><br><i>(default_list_8.2)<i></br>')\n        return True\n    return False\n\n\n# ################8.2 End#######################\n\n\n# ################8.3 Start#######################\ndef wrong_list_initialization_placement_8_3():\n    for_matches = find_matches(\"for ___ in ___:\\n\"\n                               \"    pass\")\n    init_matches = find_matches(\"episode_length_list = ___\")\n    if init_matches and for_matches:\n        for for_match in for_matches:\n            for_lineno = for_match.match_lineno\n            for init_match in init_matches:\n                if init_match.match_lineno > for_lineno:\n                    explain(\n                        'The list of episode lengths (<code>episode_length_list</code>) must be initialized before the'\n                        ' iteration which uses this list.<br><br><i>(init_place_8.3)<i></br>')\n                    return True\n    return False\n\n\ndef wrong_accumulator_initialization_placement_8_3():\n    for_matches = find_matches(\"for ___ in ___:\"\n                               \"    pass\")\n    init_matches = find_matches(\"sum_length = 0\")\n    if init_matches and for_matches:\n        for for_match in for_matches:\n            for_lineno = for_match.match_lineno\n            for init_match in init_matches:\n                if init_match.match_lineno > for_lineno:\n                    explain(\n                        'The variable to hold the sum of the episode lengths (<code>sum_length</code>) must be '\n                        'initialized before the iteration which uses this variable.<br><br><i>'\n                        '(accu_init_place_8.3)<i></br>')\n                    return True\n    return False\n\n\ndef wrong_iteration_body_8_3():\n    match = find_match(\"for _item_ in _list_:\\n\"\n                       \"    sum_length = ___ + ___\\n\")\n    if not match:\n        explain('The addition of each episode length to the total length is not in the correct place.<br><br><i>'\n                '(iter_body_8.3)<i></br>')\n        return True\n    return False\n\n\ndef wrong_print_8_3():\n    match = find_match(\"for _item_ in _list_:\\n\"\n                       \"    pass\\n\"\n                       \"print(_total_)\")\n    if not match:\n        explain('The output of the total length of time is not in the correct place. The total length of time should be'\n                ' output only once after the total length of time has been computed.<br><br><i>(print_8.3)<i></br>')\n        return True\n    return False\n\n\n# ################8.3 End#######################\n\n\n# ################8.4 Start#######################\ndef missing_target_slot_empty_8_4():\n    matches = find_matches(\"for _item_ in pages_count_list:\\n\"\n                           \"    pass\")\n    if matches:\n        for match in matches:\n            _item_ = match[\"_item_\"][0]\n            if _item_.id == \"___\":\n                explain('You must fill in the empty slot in the iteration.<br><br><i>(target_empty_8.4)<i></br>')\n                return True\n    return False\n\n\ndef missing_addition_slot_empty_8_4():\n    matches = find_matches(\"sum_pages + _item_\")\n    if matches:\n        for match in matches:\n            _item_ = match[\"_item_\"][0]\n            if _item_.id == \"___\":\n                explain('You must fill in the empty slot in the addition.<br><br><i>(add_empty_8.4)<i></br>')\n                return True\n    return False\n\n\ndef wrong_names_not_agree_8_4():\n    matches = find_matches(\"for _item1_ in pages_count_list:\\n\"\n                           \"    sum_pages = sum_pages + _item2_\")\n    if matches:\n        for match in matches:\n            # in theory, these will always be different? should test in test_cait\n            _item1_ = match[\"_item1_\"][0]\n            _item2_ = match[\"_item2_\"][0]\n            if _item1_.id != _item2_.id:\n                explain('Each value of <code>{0!s}</code> must be added to <code>{1!s}</code>.<br><br><i>'\n                        '(name_agree_8.4)<i></br>'.format(_item1_.id, _item2_.id))\n                return True\n    return False\n\n\n# ################8.4 End#######################\ndef wrong_modifying_list_8_5():\n    \"\"\"\n\n    # old code for record keeping because significantly different semantics\n    std_ast = parse_program()\n    list_init = std_ast.find_all('List')\n    true_sum = 0\n    if len(list_init) != 0:\n        for value in list_init[0].elts:\n            true_sum = value.n + true_sum\n    if true_sum != sum([20473, 27630, 17849, 19032, 16378]) or len(list_init) == 0:\n        explain('Don\\'t modify the list<br><br><i>(mod_list_8.5)<i></br>')\n        return True\n    return  False\n\n    Returns:\n    \"\"\"\n    match = find_match(\"[20473, 27630, 17849, 19032, 16378]\")\n    if not match:\n        explain('Don\\'t modify the list<br><br><i>(mod_list_8.5)<i></br>')\n        return True\n    return False\n\n\ndef wrong_modifying_list_8_6():\n    \"\"\"\n    std_ast = parse_program()\n    list_init = std_ast.find_all('List')\n    true_sum = 0\n    for value in list_init[0].elts:\n        true_sum = value.n + true_sum\n    if true_sum != sum([2.9, 1.5, 2.3, 6.1]):\n        explain('Don\\'t modify the list<br><br><i>(mod_list_8.6)<i></br>')\n    Returns:\n    \"\"\"\n    match = find_match(\"_list_ = [2.9, 1.5, 2.3, 6.1]\")\n    if not match:\n        explain('Don\\'t modify the list<br><br><i>(mod_list_8.6)<i></br>')\n        return True\n    return False\n\n\ndef wrong_should_be_counting():\n    \"\"\"\n    std_ast = parse_program()\n    for_loops = std_ast.find_all('For')\n    for loop in for_loops:\n        iter_prop = loop.target\n        assignments = loop.find_all('Assign')\n        for assignment in assignments:\n            binops = assignment.find_all('BinOp')\n            for binop in binops:\n                if binop.has(iter_prop) and binop.op == 'Add':\n                    explain('This problem asks for the number of items in the list not the total of all the values in '\n                            'the list.<br><br><i>(not_count)<i></br>')\n    Returns:\n    \"\"\"\n    matches = find_matches(\"for _item_ in ___:\\n\"\n                           \"    __expr__\")\n    if matches:\n        for match in matches:\n            _item_ = match[\"_item_\"][0]\n            __expr__ = match[\"__expr__\"]\n            submatches = __expr__.find_matches(\"___ = ___ + {}\".format(_item_.id), )\n            if submatches:\n                explain(\n                    'This problem asks for the number of items in the list not the total of all the values in the list.'\n                    '<br><br><i>(not_count)<i></br>')\n                return True\n    return False\n\n\ndef wrong_should_be_summing():\n    \"\"\"\n    std_ast = parse_program()\n    for_loops = std_ast.find_all('For')\n    for loop in for_loops:\n        assignments = loop.find_all('Assign')\n        for assignment in assignments:\n            binops = assignment.find_all('BinOp')\n            for binop in binops:\n                if binop.has(1) and binop.op == 'Add':\n                    explain('This problem asks for the total of all the values in the list not the number of items in '\n                            'the list.<br><br><i>(not_sum)<i></br>')\n    \"\"\"\n    matches = find_matches(\"for _item_ in ___:\\n\"\n                           \"    __expr__\")\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            submatches = __expr__.find_matches(\"___ = 1 + ___\", )\n            if submatches:\n                explain('This problem asks for the total of all the values in the list not the number of '\n                        'items in the list.<br><br><i>(not_sum)<i></br>')\n                return True\n    return False\n\n\ndef missing_addition_slot_empty():\n    \"\"\"\n    std_ast = parse_program()\n    assignments = std_ast.find_all('Assign')\n    for assignment in assignments:\n        # left = assignment.target\n        right = assignment.value\n        binOp = right.find_all('BinOp')\n        if len(binOp) == 1:\n            binOp = binOp[0]\n            if binOp.op == 'Add':\n                if binOp.left.ast_name == 'Name' and binOp.right.ast_name == 'Name':\n                    if binOp.left.id == '___' or binOp.right.id == '___':\n                        explain('You must fill in the empty slot in the addition.<br><br><i>(add_empty)<i></br>')\n                        return True\n    return False\n    Returns:\n    \"\"\"\n    matches = find_matches(\"___ + _item_\")\n    if matches:\n        for match in matches:\n            _item_ = match[\"_item_\"][0]\n            if _item_.id == \"___\":\n                explain('You must fill in the empty slot in the addition.<br><br><i>(add_empty)<i></br>')\n                return True\n    return False\n\n\ndef wrong_cannot_sum_list():\n    \"\"\"\n\n    std_ast = parse_program()\n    for_loops = std_ast.find_all('For')\n    for loop in for_loops:\n        list_prop = loop.iter\n        assignments = loop.find_all('Assign')\n        for assignment in assignments:\n            binops = assignment.find_all('BinOp')\n            for binop in binops:\n                if binop.has(list_prop) and binop.op == 'Add':\n                    explain('Addition can only be done with a single value at a time, not with an entire list at one'\n                            ' time.<br><br><i>(sum_list)<i></br>')\n    Returns:\n    \"\"\"\n    matches = find_matches(\"for ___ in _list_ :\\n\"\n                           \"    __expr__\")\n    if matches:\n        for match in matches:\n            _list_ = match[\"_list_\"][0]\n            __expr__ = match[\"__expr__\"]\n            submatches = __expr__.find_matches(\"___ = ___ + {}\".format(_list_.id), )\n            if submatches:\n                explain('Addition can only be done with a single value at a time, not with an entire list at one'\n                        ' time.<br><br><i>(sum_list)<i></br>')\n                return True\n    return False\n\n\ndef missing_no_print():\n    prints = find_match('print(___)', cut=True)\n    if not prints:\n        explain('Program does not output anything.<br><br><i>(no_print)<i></br>')\n        return True\n    return False\n\n\ndef missing_counting_list():\n    \"\"\"\n    std_ast = parse_program()\n    has_count = False\n    for_loops = std_ast.find_all('For')\n    if len(for_loops) > 0:\n        for loop in for_loops:\n            assignments = loop.find_all('Assign')\n            if len(assignments) < 1:\n                continue\n            for assignment in assignments:\n                binops = assignment.find_all('BinOp')\n                if len(binops) < 1:\n                    continue\n                lhs = assignment.target\n                for binop in binops:\n                    if binop.has(lhs) and binop.has(1) and binop.op == 'Add':\n                        has_count = True\n    if not has_count:\n        explain('Count the total number of items in the list using iteration.<br><br><i>(miss_count_list)<i></br>')\n    Returns:\n    \"\"\"\n    matches = find_matches(\"for _item_ in ___:\\n\"\n                           \"    __expr__\")\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            submatches = __expr__.find_matches(\"_sum_ = _sum_ + 1\", )\n            if submatches:\n                return False\n    explain(\n        'Count the total number of items in the list using iteration.<br><br><i>(miss_count_list)<i></br>')\n    return True\n\n\ndef missing_summing_list():\n    \"\"\"\n    std_ast = parse_program()\n    has_total = False\n    for_loops = std_ast.find_all('For')\n    if len(for_loops) > 0:\n        for loop in for_loops:\n            assignments = loop.find_all('Assign')\n            if len(assignments) < 1:\n                continue\n            iter_prop = loop.target\n            for assignment in assignments:\n                binops = assignment.find_all('BinOp')\n                if len(binops) < 1:\n                    continue\n                lhs = assignment.target\n                for binop in binops:\n                    if binop.has(lhs) and binop.has(iter_prop) and binop.op == 'Add':\n                        has_total = True\n    if not has_total:\n        explain('Sum the total of all list elements using iteration.<br><br><i>(miss_sum_list)<i></br>')\n    Returns:\n    \"\"\"\n    matches = find_matches(\"for _item_ in ___:\\n\"\n                           \"    __expr__\")\n    if matches:\n        for match in matches:\n            _item_ = match[\"_item_\"][0]\n            __expr__ = match[\"__expr__\"]\n            submatches = find_expr_sub_matches(\"_sum_ = _sum_ + {}\"\n                                               .format(_item_.id), __expr__)\n            if submatches:\n                return False\n    explain('Sum the total of all list elements using iteration.<br><br><i>(miss_sum_list)<i></br>')\n    return True\n\n\ndef missing_zero_initialization():\n    \"\"\"\n\n    std_ast = parse_program()\n    for_loops = std_ast.find_all('For')\n    accumulator = None\n    loop_acu = None\n    for loop in for_loops:\n        assignments = loop.find_all('Assign')\n        for assignment in assignments:\n            binops = assignment.find_all('BinOp')\n            if len(binops) > 0:\n                lhs = assignment.target\n                for binop in binops:\n                    if binop.has(lhs) and binop.op == 'Add':\n                        accumulator = lhs\n                        loop_acu = loop\n    accu_init = False\n    if accumulator is not None:\n        assignments = std_ast.find_all('Assign')\n        for assignment in assignments:\n            if loop_acu.lineno > assignment.lineno:\n                lhs = assignment.target\n                if lhs.id == accumulator.id and assignment.has(0):\n                    accu_init = True\n                    break\n    if not accu_init and accumulator is not None:\n        explain('The addition on the first iteration step is not correct because either the variable '\n                '<code>{0!s}</code> has not been initialized to an appropriate initial value or it has not been placed'\n                ' in an appropriate location<br><br><i>(miss_zero_init)<i></br>'.format(accumulator.id))\n        return False\n    return True\n    Returns:\n    \"\"\"\n\n    matches01 = find_matches(\"for ___ in ___:\\n\"\n                             \"    __expr__\")\n    if matches01:\n        for match01 in matches01:\n            __expr__ = match01[\"__expr__\"]\n            submatches01 = __expr__.find_matches(\"_sum_ = _sum_ + ___\", )\n            if submatches01:\n                for submatch01 in submatches01:\n                    _sum_ = submatch01[\"_sum_\"][0]\n                    matches02 = find_matches((\"{} = 0\\n\"\n                                              \"for ___ in ___:\\n\"\n                                              \"    __expr__\").format(_sum_.id))\n                    if not matches02:\n                        explain('The addition on the first iteration step is not correct because either the variable '\n                                '<code>{0!s}</code> has not been initialized to an appropriate initial value or it has '\n                                'not been placed in an appropriate location<br><br><i>'\n                                '(miss_zero_init)<i></br>'.format(_sum_.id))\n                        return True\n    return False\n\n\ndef wrong_printing_list():\n    matches = find_matches(\"for ___ in ___:\\n\"\n                           \"    __expr__\")\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            if __expr__.find_matches(\"print(___)\", ):\n                explain('You should be printing a single value.<br><br><i>(list_print)<i></br>')\n                return True\n    return False\n\n\n# TODO: This might be reason to rethink letting instructor symbols map to multiple items\ndef missing_average():\n    matches_missing = find_matches(\"for ___ in ___:\\n\"\n                                   \"    pass\\n\"\n                                   \"__expr__\")\n    matches = []\n    if matches_missing:\n        for match in matches_missing:\n            __expr__ = match[\"__expr__\"]\n            sub_matches = __expr__.find_matches(\"_total_/_count_\", )\n            if sub_matches:\n                for sub_match in sub_matches:\n                    _total_ = sub_match[\"_total_\"][0]\n                    _count_ = sub_match[\"_count_\"][0]\n                    if _total_.id != _count_.id:\n                        matches.append(match)\n    if not len(matches) > 0:\n        explain('An average value is not computed.<br><br><i>(no_avg)<i></br>')\n        return True\n    return False\n\n\ndef warning_average_in_iteration():\n    matches = find_matches(\"for ___ in ___:\\n\"\n                           \"    __expr__\\n\")\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            submatches = __expr__.find_matches(\"_average_ = _total_/_count_\", )\n            if submatches:\n                for submatch in submatches:\n                    _total_ = submatch[\"_total_\"][0]\n                    _count_ = submatch[\"_count_\"][0]\n                    _average_ = submatch[\"_average_\"][0]\n                    if _total_.id != _count_.id != _average_.id and _total_.id != _average_.id:\n                        explain('An average value is best computed after the properties name <code>{0!s}</code>(total)'\n                                ' and <code>{1!s}</code> are completely known rather than recomputing the average on'\n                                ' each iteration.<br><br><i>(avg_in_iter)<i></br>'.format(_total_.id, _count_.id))\n                        return True\n\n    return False\n\n\ndef wrong_average_denominator():\n    matches = find_matches(\"for ___ in ___:\\n\"\n                           \"    __expr__\\n\"  # where expr contains _count_ = _count_ + 1\n                           \"__expr2__\")  # where expr2 contains ___/_value_\n    # where _value_.id != _count_.id\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            __expr2__ = match[\"__expr2__\"]\n            # _value_ = match[\"_value_\"][0]\n            submatches = __expr__.find_matches(\"_count_ = _count_ + 1\", )\n            submatches02 = find_expr_sub_matches(\"___/_value_\", __expr2__)\n            if submatches and submatches02:\n                for submatch in submatches:\n                    for submatch02 in submatches02:\n                        _count_ = submatch[\"_count_\"][0]\n                        _value_ = submatch02[\"_value_\"][0]\n                        if _count_.id != _value_.id:\n                            explain('The average is not calculated correctly.<br><br><i>(avg_denom)<i></br>')\n                            return True\n    return False\n\n\ndef wrong_average_numerator():\n    matches = find_matches(\"for _item_ in ___:\\n\"\n                           \"    __expr__\\n\"  # where expr contains _total_ = _total_ + 1\n                           \"__expr2__\")  # where expr2 contains _value_/___\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            __expr2__ = match[\"__expr2__\"]\n            _item_ = match[\"_item_\"][0]\n            submatches = __expr__.find_matches(\"_total_ = _total_ + {}\".format(_item_.id), )\n            submatches02 = find_expr_sub_matches(\"_value_/___\", __expr2__)\n            if submatches and submatches02:\n                for submatch in submatches:\n                    for submatch02 in submatches02:\n                        _value_ = submatch02[\"_value_\"][0]\n                        _total_ = submatch[\"_total_\"][0]\n                        if _total_.id != _value_.id:\n                            explain('The average is not calculated correctly.<br><br><i>(avg_numer)<i></br>')\n                            return True\n    return False\n\n\n# #######################AVERAGE END###########################\ndef wrong_compare_list():\n    matches = find_matches(\"for ___ in _list_:\\n\"\n                           \"    if __expr__:\\n\"\n                           \"        pass\")\n    if matches:\n        for match in matches:\n            _list_ = match[\"_list_\"][0]\n            __expr__ = match[\"__expr__\"]\n            if __expr__.has(_list_.astNode):\n                explain('Each item in the list <code>{0!s}</code> must be compared one item at a time.<br><br><i>'\n                        '(comp_list)<i></br>'.format(_list_.id))\n                return True\n    return False\n\n\ndef wrong_for_inside_if():\n    match = find_match(\"if ___:\\n\"\n                       \"    for ___ in ___:\\n\"\n                       \"        pass\")\n    if match:\n        explain('The iteration should not be inside the decision block.<br><br><i>(for_in_if)<i></br>')\n        return True\n    return False\n\n\ndef iterator_is_function():\n    std_ast = parse_program()\n    for_loops = std_ast.find_all('For')\n    # noinspection PyBroadException\n    try:\n        for loop in for_loops:\n            list_prop = loop.iter\n            if list_prop.ast_name == 'Call':\n                explain('You should make a variable for the list instead of using a function call for the list'\n                        '<br><br><i>(iter_is_func)<i></br>')\n                return True\n    except Exception:\n        return False\n    return False\n\n\n# ##########################9.1 START############################\ndef wrong_list_initialization_9_1():\n    match = find_match('rainfall_list = weather.get(\"Precipitation\",\"Location\",\"Blacksburg, VA\")')\n    if not match:\n        explain('The list of rainfall amounts (<code>rainfall_list</code>) is not initialized properly.'\n                '<br><br><i>(list_init_9.1)<i></br>')\n        return True\n    return False\n\n\ndef wrong_accumulator_initialization_9_1():\n    match = find_match(\"rainfall_sum = 0\")\n    if not match:\n        explain('The variable to hold the total value of the rainfall amounts (<code>rainfall_sum</code>) is not '\n                'initialized properly.<br><br><i>(accu_init_9.1)<i></br>')\n        return True\n    return False\n\n\ndef wrong_accumulation_9_1():\n    matches = find_matches(\"rainfall_sum = _item_ + rainfall\")\n    if matches:\n        for match in matches:\n            _item_ = match[\"_item_\"][0]\n            if _item_.id != \"rainfall_sum\":\n                explain('The addition of each rainfall amount to <code>rainfall_sum</code> is not correct.'\n                        '<br><br><i>(accu_9.1)<i></br>')\n                return True\n    return False\n\n\ndef wrong_list_initialization_placement_9_1():\n    match = find_match(\"rainfall_list = ___\\n\"\n                       \"for _item_ in _list_:\\n\"\n                       \"    pass\")\n    if not match:\n        explain('The list of rainfall amount (<code>rainfall_list</code>) must be initialized before the iteration that'\n                ' uses this list.<br><br><i>(list_init_place_9.1)<i></br>')\n        return True\n    return False\n\n\n# TODO: Convert this to matching API\ndef wrong_accumulator_initialization_placement_9_1():\n    std_ast = parse_program()\n    assignments = std_ast.find_all('Assign')\n    loops = std_ast.find_all('For')\n    list_init = None\n    init_after_loop = False\n    for assignment in assignments:\n        if assignment.target.id == 'rainfall_sum':\n            list_init = assignment\n            break\n    for loop in loops:\n        if list_init is not None and loop.lineno > list_init.lineno:\n            init_after_loop = True\n            break\n    if list_init is None or not init_after_loop:\n        explain('The variable for the sum of all the rainfall amounts (<code>rainfall_sum</code>) must be initialized '\n                'before the iteration which uses this variable.<br><br><i>(accu_init_place_9.1)<i></br>')\n\n\n# TODO: Convert this to matching API\ndef wrong_iteration_body_9_1():\n    std_ast = parse_program()\n    loops = std_ast.find_all('For')\n    assignment_in_for = False\n    for loop in loops:\n        assignments = loop.find_all('Assign')\n        for assignment in assignments:\n            if assignment.target.id == 'rainfall_sum':\n                assignment_in_for = True\n                break\n        if assignment_in_for:\n            break\n    if not assignment_in_for:\n        explain('The addition of each rainfall amount to the total rainfall is not in the correct place.<br><br><i>'\n                '(iter_body_9.1)<i></br>')\n\n\ndef wrong_print_9_1():\n    \"\"\"\n\n    std_ast = parse_program()\n    for_loops = std_ast.find_all('For')\n    # has_for = len(for_loops) > 0\n    for_loc = []\n    wrong_print_placement = True\n    for loop in for_loops:\n        end_node = loop.next_tree\n        if end_node is not None:\n            for_loc.append(end_node.lineno)\n    calls = std_ast.find_all('Call')\n    for call in calls:\n        if call.func.id == 'print':\n            for loc in for_loc:\n                if call.func.lineno >= loc:\n                    wrong_print_placement = False\n                    break\n            if not wrong_print_placement:\n                break\n    if wrong_print_placement:\n        explain('The output of the total rainfall amount is not in the correct place. The total rainfall should be '\n                'output only once after the total rainfall has been computed.<br><br><i>(print_9.1)<i></br>')\n    Returns:\n    \"\"\"\n    match = find_match(\"for _item_ in _list_:\\n\"\n                       \"    pass\\n\"\n                       \"print(_total_)\")\n    if not match:\n        explain('The output of the total rainfall amount is not in the correct place. The total rainfall should be '\n                'output only once after the total rainfall has been computed.<br><br><i>(print_9.1)<i></br>')\n        return True\n    return False\n\n\n# ##########################9.1 END############################\n\n\n# ##########################9.2 START############################\n# TODO: Convert this to matching API\ndef wrong_list_initialization_9_2():\n    std_ast = parse_program()\n    assignments = std_ast.find_all('Assign')\n    has_call = False\n    for assignment in assignments:\n        if assignment.target.id == 'rainfall_list':\n            call = assignment.find_all('Call')\n            if len(call) == 1:\n                args = call[0].args\n                if len(args) == 3:\n                    if args[0].s == 'Precipitation' and args[1].s == 'Location' and args[2].s == 'Blacksburg, VA':\n                        has_call = True\n                        break\n    if not has_call:\n        explain('The list of rainfall amounts (<code>rainfall_list</code>) is not initialized properly.'\n                '<br><br><i>(list_init_9.2)<i></br>')\n    return not has_call\n\n\n# TODO: Convert this to matching API\ndef wrong_accumulator_initialization_9_2():\n    std_ast = parse_program()\n    assignments = std_ast.find_all('Assign')\n    has_assignment = False\n    for assignment in assignments:\n        if assignment.target.id == 'rainfall_count' and assignment.value.ast_name == 'Num':\n            if assignment.value.n == 0:\n                has_assignment = True\n                break\n    if not has_assignment:\n        explain('The variable to hold the total value of the rainfall amounts (<code>rainfall_count</code>) is not '\n                'initialized properly.<br><br><i>(accu_init_9.2)<i></br>')\n    return not has_assignment\n\n\ndef wrong_accumulation_9_2():\n    matches = find_matches(\"rainfall_count = _item_ + 1\")\n    if matches:\n        for match in matches:\n            _item_ = match[\"_item_\"][0]\n            if _item_.id != \"rainfall_count\":\n                explain(\n                    'The adding of another day with rainfall to the total count of days with rainfall '\n                    '(<code>rainfall_count</code>) is not correct.<br><br><i>(accu_9.2)<i></br>')\n                return True\n    return False\n\n\n# TODO: Convert this to matching API\ndef wrong_list_initialization_placement_9_2():\n    std_ast = parse_program()\n    assignments = std_ast.find_all('Assign')\n    loops = std_ast.find_all('For')\n    list_init = None\n    init_after_loop = False\n    for assignment in assignments:\n        if assignment.target.id == 'rainfall_list':\n            list_init = assignment\n            break\n    for loop in loops:\n        if list_init is not None and loop.lineno > list_init.lineno:\n            init_after_loop = True\n            break\n    if list_init is None or not init_after_loop:\n        explain('The list of rainfall amount (<code>rainfall_list</code>) must be initialized before the iteration that'\n                ' uses this list.<br><br><i>(list_init_place_9.2)<i></br>')\n        return True\n    return False\n\n\n# TODO: Convert this to matching API\ndef wrong_accumulator_initialization_placement_9_2():\n    std_ast = parse_program()\n    assignments = std_ast.find_all('Assign')\n    loops = std_ast.find_all('For')\n    list_init = None\n    init_after_loop = False\n    for assignment in assignments:\n        if assignment.target.id == 'rainfall_count':\n            list_init = assignment\n            break\n    if list_init is not None:\n        for loop in loops:\n            if loop.lineno > list_init.lineno:\n                init_after_loop = True\n                break\n    if list_init is None or not init_after_loop:\n        explain('The variable for the count of the number of days having rain (<code>rainfall_count</code>) must be '\n                'initialized before the iteration which uses this variable.<br><br><i>(accu_init_place_9.2)<i></br>')\n        return True\n    return False\n\n\ndef wrong_iteration_body_9_2():\n    matches = find_matches(\"for _item_ in _list_:\\n\"\n                           \"    if __expr__:\\n\"\n                           \"        pass\")\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            if __expr__.numeric_logic_check(1, 'var > 0'):\n                return False\n    explain('The test (if) to determine if a given amount of rainfall is greater than (>) zero is not in the '\n            'correct place.<br><br><i>(iter_body_9.2)<i></br>')\n    return True\n\n\ndef wrong_decision_body_9_2():\n    matches = find_matches(\"if __expr__:\\n\"\n                           \"    rainfall_count = rainfall_count + 1\")\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            if __expr__.numeric_logic_check(1, 'var > 0'):\n                return False\n    explain('The increase by 1 in the number of days having rainfall (<code>rainfall_count</code>) is not in the '\n            'correct place.<br><br><i>(dec_body_9.2)<i></br>')\n    return True\n\n\ndef wrong_print_9_2():\n    match = find_match(\"for _item_ in _list_:\\n\"\n                       \"    pass\\n\"\n                       \"print(_total_)\")\n    if not match:\n        explain('The output of the total number of days with rainfall is not in the correct place. The total number of '\n                'days should be output only once after the total number of days has been computed.<br><br><i>'\n                '(print_9.2)<i></br>')\n        return True\n    return False\n\n\n# ##########################9.2 END############################\n\n\n# ##########################9.6 START############################\ndef wrong_comparison_9_6():\n    matches = find_matches(\"if __comp__:\\n\"\n                           \"    pass\")\n    if matches:\n        for match in matches:\n            __comp__ = match[\"__comp__\"]\n            if not __comp__.numeric_logic_check(1, 'var > 80'):\n                explain(\n                    'In this problem you should be finding temperatures above 80 degrees.<br><br><i>(comp_9.6)<i></br>')\n                return True\n    return False\n\n\n# ##########################9.6 END############################\n\n\n# ##########################10.2 START############################\ndef wrong_conversion_10_2():\n    \"\"\"\n    '''\n    # code version 2 start\n    binops = __expr__.find_all('BinOp')\n    for binop in binops:\n        if binop.has(_target_.astNode) and binop.has(0.04) and binop.op_name == 'Mult':\n            return False\n    # code version 2 end\n    '''\n    Returns:\n    \"\"\"\n    matches = find_matches(\"for _target_ in ___:\\n\"\n                           \"    __expr__\")\n    if matches:\n        for match in matches:\n            # code version 1 start\n            _target_ = match[\"_target_\"][0]\n            __expr__ = match[\"__expr__\"]\n            matches02 = __expr__.find_matches(\"_target_*0.04\", )\n            if matches02:\n                for match02 in matches02:\n                    _target_02 = match02[\"_target_\"][0]\n                    if _target_.id == _target_02.id:\n                        return False\n            # code version 1 end\n        explain('The conversion of <code>{0!s}</code> to inches is not correct.<br><br><i>'\n                '(conv_10.2)<i></br>'.format(_target_.id))\n        return True\n    return False\n\n\n# ##########################10.2 END############################\n\n\n# ##########################10.3 START############################\ndef wrong_filter_condition_10_3():\n    matches = find_matches(\"if __expr__:\\n\"\n                           \"    pass\")\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            if __expr__.numeric_logic_check(1, \"var > 0\") or __expr__.numeric_logic_check(1, \"var != 0\"):\n                return False\n        explain('The condition used to filter the year when artists died is not correct.<br><br><i>(filt_10.3)<i></br>')\n        return True\n    return False\n\n\n# ##########################10.3 END############################\n\n\n# ##########################10.4 START############################\ndef wrong_and_filter_condition_10_4():\n    matches = find_matches(\"for _temp_ in _list_:\\n\"\n                           \"    if __expr__:\\n\"\n                           \"        pass\")\n    if matches:\n        for match in matches:\n            _temp_ = match[\"_temp_\"][0]\n            __expr__ = match[\"__expr__\"]\n            if (__expr__.has(_temp_.astNode) and\n                    not __expr__.numeric_logic_check(1, \"32 <= temp <= 50\")):\n                explain(\n                    'The condition used to filter the temperatures into the specified range of temperatures is not '\n                    'correct.<br><br><i>(filt_and_10.4)<i></br>')\n                return True\n    return False\n\n\ndef wrong_nested_filter_condition_10_4():\n    matches = find_matches(\"for _temp_ in _list_:\\n\"\n                           \"    if __cond1__:\\n\"\n                           \"        if __cond2__:\\n\"\n                           \"            pass\")\n    if matches:\n        for match in matches:\n            _temp_ = match[\"_temp_\"][0].astNode\n            __cond1__ = match[\"__cond1__\"]\n            __cond2__ = match[\"__cond2__\"]\n            if not (\n                    __cond1__.has(_temp_) and __cond2__.has(_temp_) and (\n                    __cond1__.numeric_logic_check(\n                        1,\n                        \"32 <= temp\") and __cond2__.numeric_logic_check(\n                1,\n                \"temp <= 50\") or __cond2__.numeric_logic_check(\n                1,\n                \"32 <= temp\") and __cond1__.numeric_logic_check(\n                1,\n                \"temp <= 50\"))):\n                explain(\n                    'The decisions used to filter the temperatures into the specified range of temperatures is not '\n                    'correct.<br><br><i>(nest_filt_10.4)<i></br>')\n                return True\n    return False\n\n\n# ##########################10.4 END############################\n\n\n# ########################10.5 START###############################\ndef wrong_conversion_problem_10_5():\n    matches = find_matches(\"for _item_ in ___:\\n\"\n                           \"    __expr__\")\n    if matches:\n        for match in matches:\n            _item_ = match[\"_item_\"][0]\n            __expr__ = match[\"__expr__\"]\n            matches02 = __expr__.find_matches(\"_item_*0.62\", )\n            if matches02:\n                for match02 in matches02:\n                    _item_02 = match02[\"_item_\"][0]\n                    if _item_02.id == _item_.id:\n                        return False\n        explain('The conversion from kilometers to miles is not correct.<br><br><i>(conv_10.5)<i></br>')\n        return True\n    return False\n\n\ndef wrong_filter_problem_atl1_10_5():\n    \"\"\"\n    find pattern where expression is equal to _item_*0.62 and\n    where the condition is not equivalent to _expr_ > 10\n    Returns:\n    \"\"\"\n\n    matches = find_matches(\"for _item_ in ___:\\n\"\n                           \"    if __cond__:\\n\"\n                           \"        _list_.append(__expr__)\")\n    if matches:\n        for match in matches:\n            _item_ = match[\"_item_\"][0].astNode\n            __cond__ = match[\"__cond__\"]\n            __expr__ = match[\"__expr__\"]\n            matches02 = __expr__.find_matches(\"_item_*0.62\", )\n            if matches02:\n                for match02 in matches02:\n                    _item_02 = match02[\"_item_\"][0].astNode\n                    if (_item_.id == _item_02.id and\n                            __cond__.has(_item_) and\n                            not __cond__.numeric_logic_check(0.1, \"item > 16.1290322580645\")):\n                        explain('You are not correctly filtering out values from the list.<br><br><i>'\n                                '(filt_alt1_10.5)<i></br>')\n                        return True\n    return False\n\n\ndef wrong_filter_problem_atl2_10_5():\n    matches = find_matches(\"for _item_ in ___:\\n\"\n                           \"    _miles_ = __expr__\\n\"\n                           \"    if __cond__:\\n\"\n                           \"        _list_.append(_miles_)\")\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            __cond__ = match[\"__cond__\"]\n            _item_ = match[\"_item_\"][0].astNode\n            _miles_ = match[\"_miles_\"][0].astNode\n            matches02 = __expr__.find_matches(\"_item_*0.62\", )\n            if matches02:\n                for match02 in matches02:\n                    _item_02 = match02[\"_item_\"][0].astNode\n                    if _item_.id == _item_02.id:\n                        if not (__cond__.has(_miles_) and\n                                __cond__.numeric_logic_check(1, \"_item_ > 10\")):\n                            explain('You are not correctly filtering out values from the list.<br><br><i>'\n                                    '(filt_alt2_10.5)<i></br>')\n                            return True\n    return False\n\n\ndef wrong_append_problem_atl1_10_5():\n    matches = find_matches(\"for _item_ in ___:\\n\"\n                           \"    if __cond__:\\n\"\n                           \"        _list_.append(__expr__)\")\n    if matches:\n        for match in matches:\n            _item_ = match[\"_item_\"][0].astNode\n            __cond__ = match[\"__cond__\"]\n            __expr__ = match[\"__expr__\"]\n            if (__cond__.numeric_logic_check(0.1, \"item > 16.1290322580645\") and\n                    __cond__.has(_item_)):\n                new_code = \"{}*0.62\".format(_item_.id)\n                matches02 = __expr__.find_matches(new_code, )\n                if not matches02:\n                    explain('You are not appending the correct values.<br><br><i>(app_alt1_10.5)<i></br>')\n                    return True\n    return False\n\n\ndef wrong_append_problem_atl2_10_5():\n    matches = find_matches(\"for _item_ in ___:\\n\"\n                           \"    _miles_ = _item_ * 0.62\\n\"\n                           \"    if __cond__:\\n\"\n                           \"        _list_.append(_var_)\")\n    for match in matches:\n        __cond__ = match[\"__cond__\"]\n        _miles_ = match[\"_miles_\"][0]\n        _var_ = match[\"_var_\"][0]\n        if __cond__.has(_miles_) and __cond__.numeric_logic_check(1, \"_miles_ > 10\"):\n            if _var_.id != _miles_.id:\n                explain('You are not appending the correct values<br><br><i>(app_alt2_10.5)<i></br>')\n                return True\n    return False\n\n\n# ########################10.5 END###############################\ndef wrong_debug_10_6():\n    \"\"\"\n\n\n\n\n    Returns:\n    \"\"\"\n    matches = find_matches('quakes = earthquakes.get(\"depth\",\"(None)\",\"\")\\n'\n                           'quakes_in_miles = []\\n'\n                           'for quake in _list1_:\\n'\n                           '    _list2_.append(quake * 0.62)\\n'\n                           'plt.hist(quakes_in_miles)\\n'\n                           'plt.xlabel(\"Depth in Miles\")\\n'\n                           'plt.ylabel(\"Number of Earthquakes\")\\n'\n                           'plt.title(\"Distribution of Depth in Miles of Earthquakes\")\\n'\n                           'plt.show()')\n    for match in matches:\n        name1 = match[\"_list1_\"][0].ast_node.id\n        name2 = match[\"_list2_\"][0].ast_node.id\n        master_list = [\"quake\", \"quakes\", \"quakes_in_miles\"]\n        if (name1 in master_list and name2 in master_list and\n                name1 != \"quakes_in_miles\" and name2 != \"quakes\" and\n                (name1 != \"quake\" or name2 != \"quake\")):\n            return False\n    explain('This is not one of the two changes needed. Undo the change and try again.<br><br><i>(debug_10.6)<i></br>')\n    return True\n\n\ndef wrong_debug_10_7():\n    match = find_match(\"filtered_sentence_counts = []\\n\"\n                       \"book_sentence_counts = classics.get('sentences','(None)','')\\n\"\n                       \"for book in book_sentence_counts:\\n\"\n                       \"    if book >= 5000:\\n\"\n                       \"        filtered_sentence_counts.append(book)\\n\"\n                       \"plt.hist(filtered_sentence_counts)\\n\"\n                       \"plt.title('Distribution of Number of Sentences in Long Books')\\n\"\n                       \"plt.xlabel('Number of Sentences')\\n\"\n                       \"plt.ylabel('Number of Long Books')\\n\"\n                       \"plt.show()\\n\")\n\n    if not match:\n        explain('This is not the change needed. Undo the change and try again.<br><br><i>(debug_10.7)<i></br>')\n        return True\n    return False\n\n\n# ########################.....###############################\ndef wrong_initialization_in_iteration():\n    matches = find_matches(\"for ___ in ___:\\n\"\n                           \"    __expr__\")\n    if matches:\n        for match in matches:\n            __expr__ = match[\"__expr__\"]\n            submatches = __expr__.find_matches(\"_assign_ = __expr__\", )\n            if submatches:\n                for submatch in submatches:\n                    __expr__sub = submatch[\"__expr__\"]\n                    _assign_ = submatch[\"_assign_\"][0].astNode\n                    if len(__expr__sub.find_all(\"Name\")) == 0:\n                        explain(\n                            'You only need to initialize <code>{0!s}</code> once. Remember that statements in an '\n                            'iteration block happens multiple times'\n                            '<br><br><i>(wrong_init_in_iter)<i></br>'.format(_assign_.id))\n                        return True\n    return False\n\n\ndef wrong_duplicate_var_in_add():\n    match = find_match(\"_item_ + _item_\")\n    if match:\n        explain('You are adding the same variable twice; you need two different variables in your addition.'\n                '<br><br><i>(dup_var)<i></br>')\n        return True\n    return False\n\n\n# ########################PLOTTING###############################\ndef plot_group_error(output=None):\n    if output is None:\n        output = get_output()\n    if len(output) > 1:\n        explain('You should only be printing/plotting one thing!<br><br><i>(print_one)<i></br>')\n        return True\n    elif len(output) == 0:\n        explain('The algorithm is plotting an empty list. Check your logic.<br><br><i>(blank_plot)<i></br>')\n        return True\n    elif not isinstance(output[0], list):\n        explain('You should be plotting, not printing!<br><br><i>(printing)<i></br>')\n        return True\n    elif len(output[0]) != 1:\n        explain('You should only be plotting one thing!<br><br><i>(one_plot)<i></br>')\n        return True\n\n\ndef all_labels_present():  # TODO: make sure it's before the show, maybe check for default values\n    \"\"\"\n    plt.title(\"Distribution of Number of Sentences in Long Books\")\n    plt.xlabel(\"Number of Sentences\")\n    plt.ylabel(\"Number of Long Books\")\n    plt.show()\n    Returns:\n    \"\"\"\n\n    match = find_match(\"plt.title(___)\\nplt.show()\")\n    match02 = find_match(\"plt.xlabel(___)\\nplt.show()\")\n    match03 = find_match(\"plt.ylabel(___)\\nplt.show()\")\n\n    if (not match) or (not match02) or (not match03):\n        gently('Make sure you supply labels to all your axes and provide a title and then call show'\n               '<br><br><i>(labels_present)<i></br>')\n        return True\n    return False\n\n\n# TODO: Convert this to matching API\ndef hard_code_8_5():  # TODO: This one's weird\n    match = find_matches(\"print(__num__)\")\n    if match:\n        for m in match:\n            __num__ = m[\"__num__\"]\n            if len(__num__.find_all(\"Num\")) > 0:\n                explain(\"Use iteration to calculate the sum.<br><br><i>(hard_code_8.5)<i></br>\")\n                return True\n    return False\n", "src/lib/pedal/mistakes/instructor_histogram.py": "from pedal.cait.cait_api import find_match, find_matches, data_state\nfrom pedal.report.imperative import explain\n\n\ndef histogram_group():\n    histogram_argument_not_list()\n    histogram_wrong_list()\n    histogram_missing()\n    plot_show_missing()\n\n\ndef histogram_missing():\n    \"\"\"\n    Name: histogram_missing\n    Pattern:\n\n    Missing\n       plt.hist(___)\n\n    Feedback: The program should display a histogram.\n\n    Returns:\n    \"\"\"\n    match = find_match(\"plt.hist(___)\")\n    if not match:\n        explain(\"The program should display a histogram.<br><br><i>(histo_missing)<i></br>\")\n        return True\n    return False\n\n\ndef plot_show_missing():\n    \"\"\"\n    Name: plot_show_missing\n    Pattern:\n    Missing\n       plt.show()\n\n    Feedback: The plot must be explicitly shown to appear in the Printer area.\n\n    Returns:\n    \"\"\"\n    match = find_match(\"plt.show()\")\n    if not match:\n        explain(\"The plot must be explicitly shown to appear in the Printer area.\"\n                \"<br><br><i>(plot_show_missing)<i></br>\")\n        return True\n    return False\n\n\ndef histogram_argument_not_list():\n    \"\"\"\n\n    Name: histogram_argument_not_list\n    Pattern:\n       plt.hist(<argument>)\n    Where type(<argument>) is not \"list\"\n\n    Feedback: Making a histogram requires a list; <argument> is not a list.\n\n\n    Returns:\n    \"\"\"\n    matches = find_matches(\"plt.hist(_argument_)\")\n    if matches:\n        for match in matches:\n            _argument_ = match[\"_argument_\"].astNode\n            if not data_state(_argument_).was_type('list'):\n                explain(\"Making a histogram requires a list; <code>{0!s}</code> is not a list.<br><br><i>\"\n                        \"(hist_arg_not_list)<i></br>\".format(_argument_.id))\n                return True\n    return False\n\n\ndef histogram_wrong_list():\n    \"\"\"\n\n    Name: histogram_wrong_list\n    Pattern:\n\n    for ___ in ___:\n       <target>.append(___)\n    plt.hist(<list>)\n\n    where name(<target>) != name(<list>)\n\n    Feedback: The list created in the iteration is not the list being used to create the histogram.\n\n    Returns:\n    \"\"\"\n    matches = find_matches(\"for ___ in ___:\\n\"\n                           \"    __expr__\\n\"\n                           \"plt.hist(_list_)\")\n    if matches:\n        for match in matches:\n            _list_ = match[\"_list_\"].astNode\n            __expr__ = match[\"__expr__\"]\n            submatches = __expr__.find_matches(\"{}.append(___)\".format(_list_.id))\n            if submatches:\n                return False\n        explain(\n            \"The list created in the iteration is not the list being used to create the histogram.<br><br><i>\"\n            \"(histo_wrong_list)<i></br>\")\n        return True\n    return False\n\n\ndef histogram_wrong_placement():\n    matches = find_matches(\"for ___ in ___:\\n\"\n                           \"    pass\\n\")\n    if matches:\n        matches02 = find_matches(\"plt.hist(___)\")\n        for match in matches:\n            if matches02:\n                for match02 in matches02:\n                    if match02.match_lineno > match.match_lineno:\n                        return False\n    explain(\"The histogram should be plotted only once, after the new list has been created\"\n            \"<br><br><i>(histo_wrong_place)<i></br>\")\n    return True\n", "src/lib/pedal/assertions/organizers.py": "from pedal.report.imperative import MAIN_REPORT\nfrom pedal.assertions.setup import _setup_assertions, AssertionException\nfrom functools import wraps\n\ndef contextualize_calls():\n    pass\n\n\nclass _finish_section:\n    def __init__(self, number, *functions):\n        if isinstance(number, int):\n            self.number = number\n        else:\n            self.number = -1\n            functions = [number] + list(functions)\n        self.functions = functions\n        for function in functions:\n            self(function, False)\n\n    def __call__(self, f=None, quiet=True):\n        if f is not None:\n            f()\n        if quiet:\n            print(\"\\tNEXT SECTION\")\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, x, y, z):\n        print(\"\\tNEXT SECTION\")\n        # return wrapped_f\n\n\ndef finish_section(number, *functions, next_section=False):\n    if len(functions) == 0:\n        x = _finish_section(number, *functions)\n        x()\n    else:\n        result = _finish_section(number, *functions)\n        if next_section:\n            print(\"\\tNEXT SECTION\")\n        return result\n\ndef section(*args):\n    '''\n    '''\n    _setup_assertions(MAIN_REPORT)\n    def wrap(f):\n        MAIN_REPORT['assertions']['functions'].append(f)\n        return f\n    section_number = -1\n    if len(args) >= 1 and callable(args[0]):\n        if len(args) >= 2:\n            section_number = args[1]\n        return wrap(args[0])\n    elif len(args) >= 1:\n        section_number = args[0]\n    return wrap\n\ndef phase(name):\n    _setup_assertions(MAIN_REPORT)\n    def wrap(f):\n        @wraps(f)\n        def _handle_entry(*args, **kwargs):\n            old_exception_state = MAIN_REPORT['assertions']['exceptions']\n            MAIN_REPORT['assertions']['exceptions'] = True\n            value = f(*args, **kwargs)\n            MAIN_REPORT['assertions']['exceptions'] = old_exception_state\n            return value\n        MAIN_REPORT['assertions']['functions'].append(_handle_entry)\n        return _handle_entry\n    return wrap\n    \ndef stop_on_failure(f):\n    _setup_assertions(MAIN_REPORT)\n    @wraps(f)\n    def wrapped(*args, **kwargs):\n        old_exception_state = MAIN_REPORT['assertions']['exceptions']\n        MAIN_REPORT['assertions']['exceptions'] = True\n        value = None\n        try:\n            value = f(*args, **kwargs)\n        except AssertionException:\n            pass\n        MAIN_REPORT['assertions']['exceptions'] = old_exception_state\n        return value\n    return wrapped\n\n\ndef try_all():\n    _setup_assertions(MAIN_REPORT)\n    @wraps(f)\n    def wrapped(*args, **kwargs):\n        old_exception_state = MAIN_REPORT['assertions']['exceptions']\n        MAIN_REPORT['assertions']['exceptions'] = False\n        value = f(*args, **kwargs)\n        MAIN_REPORT['assertions']['exceptions'] = old_exception_state\n        return value\n    return wrapped\n\n\ndef precondition(function):\n    pass\n\n\ndef postcondition(function):\n    pass\n", "src/lib/pedal/assertions/__init__.py": "from pedal.report.imperative import MAIN_REPORT\n\nfrom pedal.assertions.setup import _setup_assertions, resolve_all\nfrom pedal.assertions.assertions import *\nfrom pedal.assertions.organizers import *\n\ndef set_assertion_mode(exceptions=True, report=None):\n    if report is None:\n        report = MAIN_REPORT\n    _setup_assertions(report)\n    \n    report['assertions']['exceptions'] = exceptions\n", "src/lib/pedal/assertions/assertions.py": "import string\nimport re\n\nfrom pedal.report.imperative import MAIN_REPORT\nfrom pedal.sandbox.result import SandboxResult\nfrom pedal.sandbox.exceptions import SandboxException\nfrom pedal.sandbox.sandbox import DataSandbox\nfrom pedal.assertions.setup import _setup_assertions, AssertionException\n\n_MAX_LENGTH = 80\n\n\ndef safe_repr(obj, short=False):\n    try:\n        result = repr(obj)\n    except Exception:\n        result = object.__repr__(obj)\n    if not short or len(result) < _MAX_LENGTH:\n        return result\n    return result[:_MAX_LENGTH] + ' [truncated]...'\n\n\npunctuation_table = str.maketrans(string.punctuation, ' ' * len(string.punctuation))\n\n\ndef _normalize_string(a_string, numeric_endings=False):\n    # Lower case\n    a_string = a_string.lower()\n    # Remove trailing decimals (TODO: How awful!)\n    if numeric_endings:\n        a_string = re.sub(r\"(\\s*[0-9]+)\\.[0-9]+(\\s*)\", r\"\\1\\2\", a_string)\n    # Remove punctuation\n    a_string = a_string.translate(punctuation_table)\n    # Split lines\n    lines = a_string.split(\"\\n\")\n    normalized = [[piece\n                   for piece in line.split()]\n                  for line in lines]\n    normalized = [[piece for piece in line if piece]\n                  for line in normalized\n                  if line]\n    return sorted(normalized)\n\n\ndef equality_test(actual, expected, _exact_strings, _delta, _test_output):\n    # Float comparison\n    if (isinstance(expected, float) and\n        isinstance(actual, (float, int)) and\n            abs(actual - expected) < _delta):\n        return True\n    # Exact Comparison\n    if actual == expected:\n        return True\n    # Inexact string comparison\n    if (_exact_strings and isinstance(expected, str) and\n        isinstance(actual, str) and\n        _normalize_string(actual) == _normalize_string(expected)):\n        return True\n    # Output comparison\n    if _test_output:\n        # Inexact output comparison\n        normalized_actual = [_normalize_string(line) for line in actual]\n        if (isinstance(expected, str) and\n            _normalize_string(expected) in normalized_actual):\n            return True\n        # Exact output comparison\n        normalized_expected = [_normalize_string(line) for line in expected]\n        if (isinstance(expected, list) and\n            normalized_expected == normalized_actual):\n            return True\n    # Else\n    return False\n\n\n# Unittest Asserts\nDELTA = .001\n\n\ndef _fail(code_message, actual_message, expected_message,\n          show_expected_value, modify_right, *values):\n    normal_values = []\n    sandboxed_values = []\n    sandboxed_results = []\n    if modify_right and values:\n        values = values[:-1] + (modify_right(values[-1]), )\n    for value in values:\n        if is_sandbox_result(value):\n            sandboxed_results.append(value)\n            value = value._actual_value\n            sandboxed_values.append(safe_repr(value))\n        else:\n            normal_values.append(safe_repr(value))\n    if sandboxed_results:\n        code_message = _build_context(sandboxed_results, actual_message, expected_message,\n                                      show_expected_value)\n    return AssertionException(code_message.format(*(sandboxed_values + normal_values)))\n\n\ndef _build_result_from_target(target, index, quantity):\n    if target == \"_\":\n        if quantity == 1:\n            return \"the result\"\n        elif index == 0:\n            return \"the first result\"\n        else:\n            return \"the second result\"\n    return \"<code>\"+target+\"</code>\"\n\ndef _build_context(sandboxed_results, actual_message, expected_message,\n                   show_expected_value):\n    context = []\n    calls = []\n    inputs = []\n    outputs = []\n    targets = []\n    for result in sandboxed_results:\n        # Look up info\n        call_id = result._actual_call_id\n        sandbox = result._actual_sandbox\n        outputs.extend(sandbox.output_contexts[call_id])\n        calls.extend(sandbox.call_contexts[call_id])\n        inputs.extend(sandbox.input_contexts[call_id])\n        targets.append(sandbox.target_contexts[call_id])\n    # Actual rendering of text\n    if calls:\n        context.append(\"I ran:<pre>\"+ \"\\n\".join(map(str, calls))+ \"</pre>\")\n    if inputs:\n        context.append(\"I entered as input:<pre>\"+ \"\\n\".join(map(str, inputs))+ \"</pre>\")\n    actual_message += \":<pre>{}</pre>\"\n    for i, target in enumerate(targets):\n        named_target = _build_result_from_target(target, i, len(targets))\n        if target == '_':\n            context.append(named_target.capitalize() + \" \"+actual_message)\n        else:\n            context.append(\"The value of \"+named_target+\" \"+actual_message)\n    expected_context = \"But I expected \"\n    if len(targets) == 2:\n        expected_context += _build_result_from_target(targets[0], 0, 2)\n        expected_context += \" \" +expected_message + \" \"\n        expected_context += _build_result_from_target(targets[1], 1, 2)\n    else:\n        expected_context += _build_result_from_target(targets[0], 0, 1)\n        expected_context += \" \" + expected_message\n        if show_expected_value:\n            expected_context += \":<pre>{}</pre>\"\n    context.append(expected_context)\n    return \"\\n\".join(context)\n\n\ndef is_sandbox_result(value):\n    if hasattr(value, \"__actual_class__\"):\n        if value.__actual_class__ == SandboxResult:\n            return True\n    return False\n\n\ndef _basic_assertion(left, right, operator, code_comparison_message,\n                     hc_message, hc_message_past, message, report, contextualize,\n                     show_expected_value=True, modify_right=None):\n    if report is None:\n        report = MAIN_REPORT\n    _setup_assertions(report)\n    context = \"\"\n    # TODO: Handle right-side sandbox result\n    #if is_sandbox_result(right):\n    #    right = right._actual_value\n    if isinstance(left, Exception):\n        return False\n    if isinstance(right, Exception):\n        return False\n    if not operator(left, right):\n        failure = _fail(code_comparison_message, hc_message, hc_message_past,\n                        show_expected_value, modify_right, left, right)\n        report['assertions']['collected'].append(failure)\n        report.attach('Instructor Test', category='student', tool='Assertions',\n                      mistake={'message': \"Student code failed instructor test.<br>\\n\"+\n                                          context+str(failure)})\n        report['assertions']['failures'] += 1\n        if report['assertions']['exceptions']:\n            raise failure\n        else:\n            return False\n    return True\n\n\nPRE_VAL = \"\"\n\n\ndef assertEqual(left, right, score=None, message=None, report=None,\n                contextualize=True, exact=False):\n    if _basic_assertion(left, right,\n                            lambda l, r: equality_test(l, r, False, DELTA, False),\n                            \"{} != {}\",\n                            \"was\"+PRE_VAL,\n                            \"to be equal to\",\n                            message, report, contextualize):\n        if report is None:\n            report = MAIN_REPORT\n        report.give_partial(score)\n        return True\n    return False\n\n\nassert_equal = assertEqual\n\n\ndef assertNotEqual(left, right, score=None, message=None, report=None,\n                contextualize=True, exact=False):\n    if _basic_assertion(left, right,\n                            lambda l, r: not equality_test(l, r, False, DELTA, False),\n                            \"{} == {}\",\n                            \"was\"+PRE_VAL,\n                            \"to not be equal to\",\n                            message, report, contextualize):\n        if report is None:\n            report = MAIN_REPORT\n        report.give_partial(score)\n        return True\n    return False\n\n\ndef assertTrue(something, score=None, message=None, report=None,\n                contextualize=True):\n    if _basic_assertion(something, True,\n                            lambda l, r: bool(l),\n                            \"{} is true\",\n                            \"was false\"+PRE_VAL,\n                            \"to be true\",\n                            message, report, contextualize,\n                            show_expected_value=False):\n        if report is None:\n            report = MAIN_REPORT\n        report.give_partial(score)\n        return True\n    return False\n\n\ndef assertFalse(something, score=None, message=None, report=None,\n                contextualize=True):\n    if _basic_assertion(something, False,\n                            lambda l, r: not bool(l),\n                            \"{} is false\",\n                            \"was true\"+PRE_VAL,\n                            \"to be false\",\n                            message, report, contextualize,\n                            show_expected_value=False):\n        if report is None:\n            report = MAIN_REPORT\n        report.give_partial(score)\n        return True\n    return False\n\n\ndef assertIs(left, right, score=None, message=None):\n    pass\n\n\ndef assertIsNot(left, right, score=None, message=None):\n    pass\n\ndef _actually_is_none(l, r):\n    if is_sandbox_result(l):\n        return l._actual_value is None\n    return l is None\n\ndef assertIsNone(something, score=None, message=None, report=None,\n                contextualize=True):\n    if _basic_assertion(something, None,\n                            _actually_is_none,\n                            \"{} is none\",\n                            \"was\"+PRE_VAL,\n                            \"to be none\",\n                            message, report, contextualize,\n                            show_expected_value=False):\n        if report is None:\n            report = MAIN_REPORT\n        report.give_partial(score)\n        return True\n    return False\n\ndef _actually_is_not_none(l, r):\n    if is_sandbox_result(l):\n        return l._actual_value is not None\n    return l is not None\n\ndef assertIsNotNone(something, score=None, message=None, report=None,\n                contextualize=True):\n    if _basic_assertion(something, None,\n                            _actually_is_not_none,\n                            \"{} is not none\",\n                            \"was\"+PRE_VAL,\n                            \"to not be none\",\n                            message, report, contextualize,\n                            show_expected_value=False):\n        if report is None:\n            report = MAIN_REPORT\n        report.give_partial(score)\n        return True\n    return False\n\n\ndef assertIn(needle, haystack, score=None, message=None, report=None,\n             contextualize=True):\n    expected_message = \"to be in\"\n    if not is_sandbox_result(needle) and is_sandbox_result(haystack):\n        expected_message = \"to contain\"\n    if _basic_assertion(needle, haystack,\n                            lambda n, h: n in h,\n                            \"{} not in {}\",\n                            \"was\"+PRE_VAL,\n                            expected_message,\n                            message, report, contextualize):\n        if report is None:\n            report = MAIN_REPORT\n        report.give_partial(score)\n        return True\n    return False\n\n\ndef assertNotIn(needle, haystack, score=None, message=None, report=None,\n                contextualize=True):\n    expected_message = \"to not be in\"\n    if not is_sandbox_result(needle) and is_sandbox_result(haystack):\n        expected_message = \"to not contain\"\n    if _basic_assertion(needle, haystack,\n                            lambda n, h: n not in h,\n                            \"{} in {}\",\n                            \"was\"+PRE_VAL,\n                            expected_message,\n                            message, report, contextualize):\n        if report is None:\n            report = MAIN_REPORT\n        report.give_partial(score)\n        return True\n    return False\n\ndef _humanize_types(types):\n    if isinstance(types, tuple):\n        return ', '.join([t.__name__ for t in types])\n    return types.__name__\n\ndef assertIsInstance(value, types, score=None, message=None, report=None,\n                contextualize=True):\n    if _basic_assertion(value, types,\n                            lambda v, t: isinstance(v, t),\n                            \"isinstance({}, {})\",\n                            \"was\"+PRE_VAL,\n                            \"to be of type\",\n                            message, report, contextualize,\n                            modify_right=_humanize_types):\n        if report is None:\n            report = MAIN_REPORT\n        report.give_partial(score)\n        return True\n    return False\n\n\ndef assertNotIsInstance(value, types):\n    pass\n\n\ndef assertRaises(exception):\n    pass\n\n\ndef assertRaisesRegexp(exception):\n    pass\n\n\ndef assertAlmostEqual(left, right):\n    pass\n\n\ndef assertNotAlmostEqual(left, right):\n    pass\n\n\ndef assertGreater(left, right):\n    pass\n\n\ndef assertGreaterEqual(left, right):\n    pass\n\n\ndef assertLess(left, right):\n    pass\n\n\ndef assertLessEqual(left, right):\n    pass\n\n\ndef assertRegexpMatches(text, pattern):\n    pass\n\n\ndef assertNotRegexpMatches(text, pattern):\n    pass\n\n\ndef assertItemsEqual(left, right):\n    pass\n\n\ndef assertDictContainsSubset(left, right):\n    pass\n\n\ndef assertMultiLineEqual(left, right):\n    pass\n\n\ndef assertSequenceEqual(left, right):\n    pass\n\n\n# Speciality Asserts\ndef assertPrints(result, expected_output, args=None, returns=None,\n                  score=None, message=None, report=None,\n                  contextualize=True, exact=False):\n    if not isinstance(result, SandboxResult):\n        return False\n        raise TypeError(\"You must pass in a SandboxResult (e.g., using `call`) to assertPrints\")\n    if report is None:\n        report = MAIN_REPORT\n    _setup_assertions(report)\n    call_id = result._actual_call_id\n    sandbox = result._actual_sandbox\n    calls = sandbox.call_contexts[call_id]\n    inputs = sandbox.input_contexts[call_id]\n    actual_output = sandbox.output_contexts[call_id]\n    if not equality_test(actual_output, expected_output, exact, DELTA, True):\n        context= []\n        if calls:\n            context.append(\"I ran:<pre>\"+\n                           \"\\n\".join(map(str, calls))+\n                           \"</pre>\")\n        if inputs:\n            context.append(\"I entered as input:<pre>\"+\n                           \"\\n\".join(map(str, inputs))+\n                           \"</pre>\")\n        if actual_output:\n            context.append(\"The function printed:<pre>\"+\n                           \"\\n\".join(map(str, actual_output))+\n                           \"</pre>\")\n        else:\n            context.append(\"The function printed nothing.\")\n        context.append(\"But I expected the output:<pre>\"+ \"\\n\".join(map(str, expected_output))+ \"</pre>\")\n        failure = AssertionException(\"\\n\".join(context))\n        report['assertions']['collected'].append(failure)\n        report.attach('Instructor Test', category='student', tool='Assertions',\n                      mistake={'message': \"Student code failed instructor test.<br>\\n\"+\n                                          str(failure)})\n        report['assertions']['failures'] += 1\n        if report['assertions']['exceptions']:\n            raise failure\n        else:\n            return False\n    report.give_partial(score)\n    return True\n\ndef assertHasFunction(obj, function, args=None, returns=None,\n                      score=None, message=None, report=None,\n                      contextualize=True, exact=False):\n    # If object is a sandbox, will check the .data[variable] attribute\n    # Otherwise, check it directly\n    if isinstance(obj, DataSandbox):\n        comparison = lambda o, f: f in o.data\n    else:\n        comparison = lambda o, f: f in hasattr(o, f)\n    if not _basic_assertion(obj, function,\n                            comparison,\n                            \"Could not find function {}{}\",\n                            \"was\"+PRE_VAL,\n                            \"to have the function\",\n                            message, report, contextualize):\n        return False\n    if isinstance(obj, DataSandbox):\n        student_function = obj.data[function]\n    else:\n        student_function = getattr(obj, function)\n    if _basic_assertion(student_function, function,\n                            lambda l, r: callable(l),\n                            \"The value {} is in the variable {}, and that value is not a callable function.\",\n                            \"was callable\"+PRE_VAL,\n                            \"to be callable\",\n                            message, report, contextualize,\n                            show_expected_value=False):\n        if report is None:\n            report = MAIN_REPORT\n        report.give_partial(score)\n        return True\n    return False\n\ndef assertHasClass(sandbox, class_name, attrs=None):\n    pass\n\n\ndef assertHas(obj, variable, types=None, value=None, score=None,\n              message=None, report=None, contextualize=True):\n    # If object is a sandbox, will check the .data[variable] attribute\n    # Otherwise, check it directly\n    if isinstance(obj, DataSandbox):\n        comparison = lambda o, v: v in o.data\n    else:\n        comparison = lambda o, v: v in hasattr(o, v)\n    if not _basic_assertion(obj, variable,\n                            comparison,\n                            \"Could not find variable {}{}\",\n                            \"was\"+PRE_VAL,\n                            \"to have the variable\",\n                            message, report, contextualize):\n        return False\n    if isinstance(obj, DataSandbox):\n        student_variable = obj.data[variable]\n    else:\n        student_variable = getattr(obj, variable)\n    if types is not None:\n        if not _basic_assertion(student_variable, types,\n                            lambda v, t: isinstance(v, t),\n                            \"isinstance({}, {})\",\n                            \"was\"+PRE_VAL,\n                            \"to be of type\",\n                            message, report, contextualize,\n                            modify_right=_humanize_types):\n            return False\n    if value is not None:\n        if not _basic_assertion(student_variable, value,\n                            lambda l, r: equality_test(l, r, False, DELTA, False),\n                            \"{} != {}\",\n                            \"was\"+PRE_VAL,\n                            \"to be equal to\",\n                            message, report, contextualize,\n                            show_expected_value=False):\n            return False\n    if report is None:\n        report = MAIN_REPORT\n    report.give_partial(score)\n    return True\n\ndef assertGenerally(expression, score=None, message=None, report=None,\n                    contextualize=True):\n    if report is None:\n        report = MAIN_REPORT\n    _setup_assertions(report)\n    if expression:\n        report.give_partial(score)\n        return True\n    else:\n        report['assertions']['failures'] += 1\n        if report['assertions']['exceptions']:\n            raise AssertionException(\"General assertion\")\n        else:\n            return False\n\n# Allow addition of new assertions\n# e.g., assertGraphType, assertGraphValues\n", "src/lib/pedal/assertions/setup.py": "from pedal.report.imperative import MAIN_REPORT\n\nclass AssertionException(Exception):\n    pass\n\ndef resolve_all(set_success=False, report=None):\n    if report is None:\n        report = MAIN_REPORT\n    _setup_assertions(report)\n    for function in report['assertions']['functions']:\n        try:\n            function()\n        except AssertionException:\n            break\n    #for f in report.feedback:\n    #    print(\"\\t\", f, f.mistake, f.misconception)\n    if not report['assertions']['failures'] and set_success:\n        report.set_success()\n\ndef _setup_assertions(report):\n    if 'assertions' not in report:\n        report['assertions'] = {\n            'functions': [],\n            'exceptions': False,\n            'failures': 0,\n            'collected': [],\n            # Should we batch up multiple assertion failures?\n            #   The grouping mechanism is try_all\n            'tabular_output': False,\n        }\n        report.add_hook('source.next_section.before', resolve_all)\n        report.add_hook('pedal.resolvers.resolve', resolve_all)\n", "src/lib/pedal/resolvers/__init__.py": "\"\"\"\n\nResolver Types\n\nDoes there need to be some kind of hook for Tools to wrap up their business?\n\nSimple\n    Find the highest priority feedback and show that, along with any positive feedback.\n\nSectional\n    Find the highest priority feedback for each section, and show that along with any positive feedback.\n\nFull\n    Report all feedback, grouped by tool/category/priority/time.\n\nFull Summary\n    Report all feedback but divided into frequencies of labels grouped by tool/category/priority/time.\n\n\"\"\"\n", "src/lib/pedal/resolvers/core.py": "from pedal.report.imperative import MAIN_REPORT\n\n\ndef make_resolver(func, report=None):\n    '''\n    Decorates the given function as a Resolver. This means that when the\n    function is executed, the `\"pedal.resolver.resolve\"` event will be\n    triggered.\n    \n    Args:\n        func (callable): The function to decorate.\n        report (Report): The Report to trigger the event on. If None, then use\n            the `MAIN_REPORT`.\n    '''\n    if report is None:\n        report = MAIN_REPORT\n\n    def resolver_wrapper():\n        report.execute_hooks(\"pedal.resolvers.resolve\")\n        return func()\n\n    return resolver_wrapper\n", "src/lib/pedal/resolvers/sectional.py": "from pedal.resolvers import simple\nfrom pedal.report import MAIN_REPORT\n\n\ndef resolve(report=None, priority_key=None):\n    \"\"\"\n    Args:\n        report (Report): The report object to resolve down. Defaults to the\n                         global MAIN_REPORT\n\n    Returns\n        str: A string of HTML feedback to be delivered\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    if priority_key is None:\n        priority_key = simple.by_priority\n    # Prepare feedbacks\n    feedbacks = report.feedback\n    feedbacks.sort(key=lambda f: (f.group or 0, priority_key(f)))\n    suppressions = report.suppressions\n    # Process\n    final_success = False\n    final_score = 0\n    finals = {}\n    found_failure = False\n    for feedback in feedbacks:\n        group = feedback.group or 0\n        category = feedback.category.lower()\n        if category in suppressions:\n            if True in suppressions[category]:\n                continue\n            elif feedback.label.lower() in suppressions[category]:\n                continue\n        success, partial, message, data = simple.parse_feedback(feedback)\n        final_success = success or final_success\n        final_score += partial\n        if message is not None:\n            if feedback.priority not in ('positive', 'instructions'):\n                if found_failure:\n                    continue\n                found_failure = True\n            if group not in finals:\n                finals[group] = []\n            entry = {'label': feedback.label,\n                     'message': message,\n                     'category': feedback.category,\n                     'priority': feedback.priority,\n                     'data': data}\n            if feedback.priority == 'instructions':\n                # Find end of instructions\n                index = 0\n                for feedback in finals[group]:\n                    if feedback['priority'] != 'instructions':\n                        break\n                    index += 1\n                finals[group].insert(index, entry)\n            elif feedback.priority != 'positive':\n                finals[group].insert(0, entry)\n            else:\n                finals[group].append(entry)\n    final_hide_correctness = suppressions.get('success', False)\n    if not finals:\n        finals[0] = [{\n            'label': 'No errors',\n            'category': 'Instructor',\n            'data': [],\n            'priority': 'medium',\n            'message': \"No errors reported.\"\n        }]\n    return (final_success, final_score, final_hide_correctness, finals)\n", "src/lib/pedal/resolvers/simple.py": "from pedal.report import MAIN_REPORT, Feedback\nfrom pedal.resolvers.core import make_resolver\n\nDEFAULT_CATEGORY_PRIORITY = [\n    'syntax',\n    'mistakes',\n    'instructor',\n    'analyzer',\n    'runtime',\n    'student',\n    'positive',\n    'instructions',\n    'uncategorized',\n]\n\n# For compatibility with the old feedback API\nLEGACY_CATEGORIZATIONS = {\n    # 'student': 'runtime',\n    'parser': 'syntax',\n    'verifier': 'syntax',\n    'instructor': 'instructor'\n}\n\n\ndef by_priority(feedback):\n    \"\"\"\n    Converts a feedback into a numeric representation for sorting.\n\n    Args:\n        feedback (Feedback): The feedback object to convert\n    Returns:\n        float: A decimal number representing the feedback's relative priority.\n    \"\"\"\n    category = 'uncategorized'\n    if feedback.category is not None:\n        category = feedback.category.lower()\n    priority = 'medium'\n    if feedback.priority is not None:\n        priority = feedback.priority.lower()\n        priority = LEGACY_CATEGORIZATIONS.get(priority, priority)\n    if category in DEFAULT_CATEGORY_PRIORITY:\n        value = DEFAULT_CATEGORY_PRIORITY.index(category)\n    else:\n        value = len(DEFAULT_CATEGORY_PRIORITY)\n    offset = .5\n    if priority == 'low':\n        offset = .7\n    elif priority == 'high':\n        offset = .3\n    elif priority not in ('low', 'medium', 'high'):\n        if priority in DEFAULT_CATEGORY_PRIORITY:\n            value = DEFAULT_CATEGORY_PRIORITY.index(priority)\n            offset = .1\n    return value + offset\n\n\ndef parse_message(component):\n    if isinstance(component, str):\n        return component\n    elif isinstance(component, list):\n        return '<br>\\n'.join(parse_message(c) for c in component)\n    elif isinstance(component, dict):\n        if \"html\" in component:\n            return component[\"html\"]\n        elif \"message\" in component:\n            return component[\"message\"]\n        else:\n            raise ValueError(\"Component has no message field: \" + str(component))\n    else:\n        raise ValueError(\"Invalid component type: \" + str(type(component)))\n\n\ndef parse_data(component):\n    if isinstance(component, str):\n        return [{'message': component}]\n    elif isinstance(component, list):\n        return component\n    elif isinstance(component, dict):\n        return [component]\n\n\ndef parse_feedback(feedback):\n    # Default returns\n    success = False\n    performance = 0\n    message = None\n    data = []\n    # Actual processing\n    for feedback_type in Feedback.MESSAGE_TYPES:\n        feedback_value = getattr(feedback, feedback_type)\n        if feedback_value is not None:\n            data.extend(parse_data(feedback_value))\n            parsed_message = parse_message(feedback_value)\n            if parsed_message is not None:\n                message = parsed_message\n    if feedback.result is not None:\n        success = feedback.result\n    if feedback.performance is not None:\n        performance = feedback.performance\n    return success, performance, message, data\n\n\n@make_resolver\ndef resolve(report=None, priority_key=None):\n    \"\"\"\n    Args:\n        report (Report): The report object to resolve down. Defaults to the\n                         global MAIN_REPORT\n\n    Returns\n        str: A string of HTML feedback to be delivered\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    if priority_key is None:\n        priority_key = by_priority\n    # Prepare feedbacks\n    feedbacks = report.feedback\n    feedbacks.sort(key=priority_key)\n    suppressions = report.suppressions\n    # Process\n    final_success = False\n    final_score = 0\n    final_message = None\n    final_category = 'Instructor'\n    final_label = 'No errors'\n    final_data = []\n    for feedback in feedbacks:\n        category = feedback.category.lower()\n        if category in suppressions:\n            if True in suppressions[category]:\n                continue\n            elif feedback.label.lower() in suppressions[category]:\n                continue\n        success, partial, message, data = parse_feedback(feedback)\n        final_success = success or final_success\n        final_score += partial\n        if (message is not None and\n                final_message is None and\n                feedback.priority != 'positive'):\n            final_message = message\n            final_category = feedback.category\n            final_label = feedback.label\n            final_data = data\n    if final_message is None:\n        final_message = \"No errors reported.\"\n    final_hide_correctness = suppressions.get('success', False)\n    if (not final_hide_correctness and final_success and\n            final_label == 'No errors' and\n            final_category == 'Instructor'):\n        final_category = 'Complete'\n        final_label = 'Complete'\n        final_message = \"Great work!\"\n    return (final_success, final_score, final_category,\n            final_label, final_message, final_data,\n            final_hide_correctness)\n", "src/lib/pedal/cait/stretchy_tree_matching.py": "import ast\nimport re\nfrom pedal.cait.ast_map import AstMap\nfrom pedal.cait.cait_node import CaitNode\n\n# \"Enums\" for _name_regex\n_VAR = \"var\"\n_EXP = \"exp\"\n_WILD = \"wild\"\n_NONE_FIELD = \"none\"\n\n\ndef is_primitive(item):\n    \"\"\"\n    Determines if the given item is a primitive value (either an int, float,\n    str, bool, or None).\n\n    Args:\n        item (any): Any value\n    Returns:\n        bool: Whether the item is a primitive value.\n    \"\"\"\n    return isinstance(item, (int, float, str, bool)) or item is None\n\n\ndef _name_regex(name_id):\n    var_match = re.compile('^_[^_].*_$')  # /regex\n    exp_match = re.compile('^__.*__$')  # /regex\n    wild_card = re.compile('^___$')  # /regex\n    return {_VAR: var_match.match(name_id),\n            _EXP: exp_match.match(name_id),\n            _WILD: wild_card.match(name_id)}\n\n\nclass StretchyTreeMatcher:\n    def __init__(self, ast_or_code, report, filename=\"__main__\"):\n        \"\"\"\n        The StretchyTreeMatcher is used to compare a pattern against some\n        student code. It produces a set of potential mappings between them.\n\n        Args:\n            ast_or_code (str or AstNode): The students' code or a valid AstNode from\n                `ast.parse`. If the code has invalid syntax, a SyntaxError\n                will be raised.\n            filename (str): The filename to parse with - only used for error\n                reporting.\n            report (Report): A report to obtain data from.\n        \"\"\"\n        self.report = report\n        if isinstance(ast_or_code, str):\n            ast_node = ast.parse(ast_or_code, filename)\n        else:\n            ast_node = ast_or_code\n        # Build up root\n        if ast_node is None:\n            self.root_node = None\n        elif isinstance(ast_node, CaitNode):\n            self.root_node = ast_node\n        else:\n            self.root_node = CaitNode(ast_node, _NONE_FIELD, report=self.report)\n\n    def find_matches(self, ast_or_code, filename=\"__main__\", check_meta=True):\n        \"\"\"\n        Args:\n            ast_or_code (str or AstNode): The students' code or a valid AstNode from\n                `ast.parse`. If the code has invalid syntax, a SyntaxError\n                will be raised.\n            filename (str): The filename to parse with - only used for error\n                reporting.\n            check_meta (bool): Determine if the nodes came from the same AST\n                field.\n        Returns:\n            list[AstMap]: A list of AstMaps that are suitable matches.\n        \"\"\"\n        if isinstance(ast_or_code, str):\n            other_tree = CaitNode(ast.parse(ast_or_code, filename), report=self.report)\n        elif isinstance(ast_or_code, CaitNode):\n            other_tree = ast_or_code\n        else:\n            other_tree = CaitNode(ast_or_code, _NONE_FIELD, report=self.report)\n        explore_root = self.root_node\n        trim_set = [\"Expr\", \"Module\"]\n        explore_root_old_field = explore_root.field\n        if self.root_node is not None:  # Trimming ins_node\n            while (len(explore_root.children) == 1 and\n                   explore_root.ast_name in trim_set):\n                explore_root.field = explore_root_old_field\n                explore_root = explore_root.children[0]\n                explore_root_old_field = explore_root.field\n                explore_root.field = _NONE_FIELD\n        other_root = other_tree\n        other_root_old_field = other_root.field\n        if other_root is not None:  # Trimming std_node\n            while len(other_root.children) == 1 and other_root.ast_name in trim_set:\n                other_root.field = other_root_old_field\n                other_root = other_root.children[0]\n                other_root_old_field = other_root.field\n                other_root.field = _NONE_FIELD\n        matches = self.any_node_match(explore_root, other_root,\n                                   check_meta=check_meta)\n        explore_root.field = explore_root_old_field\n        other_root.field = other_root_old_field\n        return matches\n\n    def any_node_match(self, ins_node, std_node, check_meta=True, cut=False):\n        \"\"\"\n        Finds whether ins_node can be matched to some node in the tree std_node\n\n        Args:\n            ins_node:\n            std_node:\n            check_meta:\n            cut:\n\n        Returns:\n            list of AstMaps: a mapping of nodes and a symbol table mapping ins_node to\n                some node in the tree std_node or False if such a matching does not\n                exist\n        \"\"\"\n        # @TODO: create a more public function that converts ins_node and std_node into CaitNodes\n        # TODO: Create exhaustive any_node_match\n        # matching: an object representing the mapping and the symbol table\n        matching = self.deep_find_match(ins_node, std_node, check_meta)\n        # if a direct matching is found\n        if matching:\n            for match in matching:\n                match.match_root = std_node\n        else:\n            matching = []\n        #    return matching  # return it\n        # if not matching or exhaust:  # otherwise\n        # try to matching ins_node to each child of std_node, recursively\n        for std_child in std_node.children:\n            matching_c = self.any_node_match(ins_node, std_child, check_meta=check_meta, cut=cut)\n            if matching_c:\n                for match in matching_c:\n                    match.match_root = std_child\n                # return matching\n                matching = matching + matching_c\n        if len(matching) > 0:\n            return matching\n        return []\n\n    def deep_find_match(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        Finds whether ins_node and matches std_node and whether ins_node's children flexibly match std_node's children\n        in order\n        Args:\n            ins_node: The instructor ast that should be included in the student AST\n            std_node: The student AST that we are searching for the included tree\n            check_meta: Flag, if True, check whether the two nodes originated from the same ast field\n\n        Returns:\n            a mapping of nodes and a symbol table mapping ins_node to std_node, or [] if no mapping was found\n        \"\"\"\n        method_name = \"deep_find_match_\" + type(ins_node.astNode).__name__\n        target_func = getattr(self, method_name, self.deep_find_match_generic)\n        return target_func(ins_node, std_node, check_meta)\n\n    # noinspection PyPep8Naming\n    def deep_find_match_Name(self, ins_node, std_node, check_meta=True):\n        name_id = ins_node.astNode.id\n        match = _name_regex(name_id)\n        mapping = AstMap()\n        matched = False\n        meta_matched = self.metas_match(ins_node, std_node, check_meta)\n        if match[_VAR] and meta_matched:  # if variable\n            # This if body is probably unnecessary.\n            if type(std_node.astNode).__name__ == \"Name\":\n                return self.deep_find_match_generic(ins_node, std_node, check_meta=check_meta, ignores=[\"ctx\"])\n        # could else return False, but shallow_match_generic should do this as well\n        elif match[_EXP]:  # and meta_matched:  # if expression\n            # terminate recursion, the whole subtree should match since expression nodes match to anything\n            mapping.add_exp_to_sym_table(ins_node, std_node)\n            matched = True\n        elif match[_WILD] and meta_matched:  # if wild card, don't care\n            # terminate the recursion, the whole subtree should match since wild cards match to anything\n            matched = True\n\n        if matched:\n            mapping.add_node_pairing(ins_node, std_node)\n            return [mapping]\n        # else\n        return self.deep_find_match_generic(ins_node, std_node, check_meta=check_meta, ignores=[\"ctx\"])\n\n    # noinspection PyPep8Naming\n    def deep_find_match_BinOp(self, ins_node, std_node, check_meta=True):\n        op = ins_node.astNode.op\n        op = type(op).__name__\n        is_generic = not (op == \"Mult\" or op == \"Add\")\n        if is_generic:\n            return self.deep_find_match_generic(ins_node, std_node, check_meta)\n        else:  # this means that the node is clearly commutative\n            return self.deep_find_match_binflex(ins_node, std_node, False)\n\n    # noinspection PyMethodMayBeStatic\n    def binflex_helper(self, case_left, case_right, new_mappings, base_mappings):\n        \"\"\"\n        adds to new_mappings (return/modify by argument) the mappings for both the left and right subtrees as denoted by\n        case_left and case_right\n        Args:\n            case_left: The mappings for the left opperand\n            case_right: The mappings for the right opperand\n            new_mappings: The new set of mappings to generate\n            base_mappings: The original mappings of the binop node\n\n        Returns:\n            None\n        \"\"\"\n        if case_left and case_right:\n            for case_l in case_left:\n                new_map = base_mappings[0].new_merged_map(case_l)\n                for case_r in case_right:\n                    both = new_map.new_merged_map(case_r)\n                    if not both.has_conflicts():\n                        new_mappings.append(both)\n\n    def deep_find_match_binflex(self, ins_node, std_node, check_meta=False):\n        base_mappings = self.shallow_match(ins_node, std_node, check_meta)\n        if not base_mappings:\n            return []\n        op_mappings = self.shallow_match(ins_node.children[1], std_node.children[1], check_meta=True)\n        if not op_mappings:\n            return []\n        base_mappings = [base_mappings[0].new_merged_map(op_mappings[0])]\n\n        if base_mappings:\n            ins_left = ins_node.children[0]  # instructor left ast node\n            ins_right = ins_node.children[2]  # instructor right ast node\n            std_left = std_node.children[0]  # student left ast node\n            std_right = std_node.children[2]  # student right ast node\n            new_mappings = []\n            # case 1: ins_left->std_left and ins_right->std_right\n            case_left = self.deep_find_match(ins_left, std_left, False)\n            case_right = self.deep_find_match(ins_right, std_right, False)\n            self.binflex_helper(case_left, case_right, new_mappings, base_mappings)\n            # case 2: ins_left->std_right and ins_right->std_left\n            case_left = self.deep_find_match(ins_left, std_right, False)\n            case_right = self.deep_find_match(ins_right, std_left, False)\n            self.binflex_helper(case_left, case_right, new_mappings, base_mappings)\n            if len(new_mappings) == 0:\n                return []\n            return new_mappings\n        return []\n\n    def deep_find_match_Expr(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        An Expression node (not to be confused with expressions denoted by the instructor nodes in Name ast nodes)\n        checks whether it should be generic, or not\n        Args:\n            ins_node: Instructor ast to find in the student ast\n            std_node: Student AST to search for the instructor ast in\n            check_meta: flag to check whether the fields of the instructor node and the student node should match\n\n        Returns:\n            AstMap: a mapping between the instructor and student asts, or False if such a mapping doesn't exist\n        \"\"\"\n        # if check_meta and ins_node.field != std_node.field:\n        if not self.metas_match(ins_node, std_node, check_meta):\n            return []\n        mapping = AstMap()\n        value = ins_node.value\n        ast_type = type(value.astNode).__name__\n        if ast_type == \"Name\":\n            name_id = value.astNode.id\n            exp_match = re.compile('^__.*__$')  # /regex\n            wild_card = re.compile('^___$')  # /regex\n            matched = False\n            meta_matched = self.metas_match(ins_node, std_node, check_meta)\n            if exp_match.match(name_id):  # and meta_matched:  # if expression\n                # terminate recursion, the whole subtree should match since expression nodes match to anything\n                mapping.add_exp_to_sym_table(value, std_node)\n                matched = True\n            elif wild_card.match(name_id) and meta_matched:  # if wild card, don't care\n                # terminate the recursion, the whole subtree should match since wild cards match to anything\n                matched = True\n            if matched:\n                mapping.add_node_pairing(ins_node, std_node)\n                return [mapping]\n        return self.deep_find_match_generic(ins_node, std_node, check_meta)\n\n    def deep_find_match_generic(self, ins_node, std_node, check_meta=True, ignores=None):\n        \"\"\"\n        This first uses shallow match to find a base map (match) from which to\n        build off. The algorithm then tracks all the possible mappings that\n        match a given child node in the instructor AST, keeping track of which\n        siblings have been visited.\n\n        For each instructor child, when all children of the student node have\n        been iterated through recursively, a helper function is called. This\n        helper function determines which possible children validly can extend\n        the base match to create a set of new base maps through use of the\n        indicies of the sibilings.\n\n        The process repeats itself until no matches can be grown or until each\n        instructor child node has been visited\n\n        Args:\n            ins_node: Instructor ast to find in the student ast\n            std_node: Student AST to search for the instructor ast in\n            check_meta: flag to check whether the fields of the instructor node and the student node should match\n            ignores: List of fields to ignore in the field match\n\n        Returns:\n            a mapping between the isntructor and student asts, or [] if such a mapping doesn't exist\n        \"\"\"\n        if ignores is None:\n            ignores = []\n        base_mappings = self.shallow_match(ins_node, std_node, check_meta)\n        if base_mappings:\n            # base case this runs 0 times because no children\n            # find each child of ins_node that matches IN ORDER\n            base_sibs = [-1]\n            youngest_sib = 0\n            # for each child\n            for i, insChild in enumerate(ins_node.children):\n                # make a new set of maps\n                running_maps = []\n                running_sibs = []\n                if insChild.field in ignores:\n                    continue\n                # accumulate all potential matches for current child\n                for j, std_child in enumerate(std_node.children[youngest_sib:], youngest_sib):\n                    std_child = std_node.children[j]\n                    new_mapping = self.deep_find_match(insChild, std_child, check_meta)\n                    if new_mapping:\n                        running_maps.append(new_mapping)\n                        running_sibs.append(j)\n                map_update = self.map_merge(base_mappings, base_sibs, running_maps, running_sibs)\n                if map_update is None:\n                    return []\n                base_mappings = map_update['new_maps']\n                base_sibs = map_update['new_sibs']\n                youngest_sib = map_update['youngest_sib'] + 1\n            return base_mappings\n        return []\n\n    # noinspection PyMethodMayBeStatic\n    def map_merge(self, base_maps, base_sibs, run_maps, run_sibs):\n        \"\"\"\n        Merges base_maps with the current possible maps. Helper method to deep_find_match_generic. checks whether each\n        mapping in run_maps can extend the match to any possible mapping in base_maps.\n\n        Args:\n            base_maps: The original mappings\n            base_sibs: The corresponding siblings for each mapping in base_maps\n            run_maps: The set of maps to merge into the current base_maps\n            run_sibs: The corresponding siblings for each mapping in run_maps\n\n        Returns:\n            A new set of maps for all valid extensions of base_maps with running maps\n        \"\"\"\n        # no matching nodes were found\n        if len(run_maps) == 0:\n            return None\n        new_maps = []\n        new_sibs = []\n        youngest_sib = run_sibs[0]\n        for baseMap, base_sib in zip(base_maps, base_sibs):\n            for run_map, runSib in zip(run_maps, run_sibs):\n                if runSib > base_sib:\n                    for run_mapsub in run_map:\n                        new_map = baseMap.new_merged_map(run_mapsub)\n                        if not new_map.has_conflicts():  # if it's a valid mapping\n                            new_maps.append(new_map)\n                            new_sibs.append(runSib)\n        if len(new_maps) == 0:\n            return None\n        return {\n            'new_maps': new_maps,\n            'new_sibs': new_sibs,\n            'youngest_sib': youngest_sib\n        }\n\n    # noinspection PyMethodMayBeStatic,PyPep8Naming,PyUnusedLocal\n    def shallow_match_Module(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        Flexibly matches a module node to a module or a body\n        Args:\n            ins_node:\n            std_node:\n            check_meta:\n\n        Returns:\n            a mapping of ins_node to std_node, or False if doesn't match\n        \"\"\"\n        if type(std_node.astNode).__name__ == \"Module\" or std_node.field == \"body\":\n            mapping = AstMap()\n            mapping.add_node_pairing(ins_node, std_node)\n            return [mapping]\n        return []\n\n    def shallow_symbol_handler(self, ins_node, std_node, id_val, check_meta=True):\n        \"\"\"\n        TODO: Make this handle the func field to handle functions\n        Matches ins_node to std_node for different cases of encountering a name node in ins_node\n            case 1: _var_ matches if std_node is a name node and automatically returns a mapping and symbol table\n            case 2: __exp__ matches to any subtree and automatically returns a mapping and symbol table\n            case 3: ___ matches to any subtree and automatically returns a mapping\n            case 4: matches only if the exact names are the same (falls through to shallow_match_generic)\n        Args:\n            ins_node:\n            std_node:\n            id_val:\n            check_meta:\n\n        Returns:\n            list of AstMap: a mapping of ins_node to std_node and possibly a symbol_table, or False if it doesn't match\n        \"\"\"\n        name_id = ins_node.astNode.__getattribute__(id_val)\n        match = _name_regex(name_id)\n        mapping = AstMap()\n        matched = False\n        # TODO: add functionality to add function references to func_table?\n        meta_matched = self.metas_match(ins_node, std_node, check_meta)\n        if match[_VAR] and meta_matched:  # variable\n            if type(std_node.astNode).__name__ == \"Name\" or id_val in [\"attr\", \"arg\"]:\n                if id_val in [\"attr\", \"arg\"]:\n                    std_node.astNode._id = std_node.astNode.__getattribute__(id_val)\n                if std_node.field == \"func\" and ins_node.field != _NONE_FIELD:\n                    # TODO: This 'ins_node.field != _NONE_FIELD' code is for an obscure edge case where the\n                    #  instructor code is only _var_\n                    std_node.astNode._id = std_node.astNode.__getattribute__(id_val)\n                    mapping.add_func_to_sym_table(ins_node, std_node)\n                else:\n                    std_node.astNode._id = std_node.astNode.__getattribute__(id_val)\n                    mapping.add_var_to_sym_table(ins_node, std_node)  # TODO: Capture result?\n                matched = True\n        # could else return False, but shallow_match_generic should do this as well\n        elif match[_EXP] and meta_matched:\n            mapping.add_exp_to_sym_table(ins_node, std_node)\n            matched = True\n        elif match[_WILD] and meta_matched:\n            matched = True\n\n        if matched:\n            mapping.add_node_pairing(ins_node, std_node)\n            return [mapping]\n        # else\n        return self.shallow_match_main(ins_node, std_node, check_meta=check_meta, ignores=[\"ctx\"])\n\n    # noinspection PyPep8Naming,PyMethodMayBeStatic\n    def shallow_match_arg(self, ins_node, std_node, check_meta=True):\n        ins_node.astNode._id = ins_node.arg\n        # TODO: annotations are currently ignored because shallow_symbol_handler doesn't handle them, feature? or\n        #  should we fix this. Although this should actually be toggleable?\n        return self.shallow_symbol_handler(ins_node, std_node, \"arg\", check_meta=check_meta)\n\n    def shallow_match_arguments(self, ins_node, std_node, check_meta=True):\n        # TODO: do we ignore default values? Currently not ignored\n        return self.shallow_match_generic(ins_node, std_node, check_meta=check_meta)\n\n    # noinspection PyPep8Naming,PyMethodMayBeStatic\n    def shallow_func_handle(self, ins_node, std_node, check_meta=True):\n        if ins_node.field == \"func\" and std_node.field == \"func\":\n            ins_node.astNode._id = ins_node.astNode.attr\n            return self.shallow_symbol_handler(ins_node, std_node, \"attr\", check_meta)\n        return self.shallow_match_generic(ins_node, std_node, check_meta)\n\n    def shallow_match_Attribute(self, ins_node, std_node, check_meta=True):\n        if ins_node.field == \"func\" and std_node.ast_name == \"Attribute\":\n            return self.shallow_func_handle(ins_node, std_node, check_meta)\n        elif std_node.ast_name == \"Attribute\":\n            ins_node.astNode._id = ins_node.attr  # TODO: Fix this hack more gracefully\n            # add_var_to_sym_table in ast_map needs the id attribute to make the map\n            return self.shallow_symbol_handler(ins_node, std_node, \"attr\", check_meta)\n        else:\n            return self.shallow_match_generic(ins_node, std_node, check_meta)\n\n    # noinspection PyPep8Naming\n    def shallow_match_Name(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        TODO: Make this handle the func field to handle functions\n        Matches ins_node to std_node for different cases of encountering a name node in ins_node\n            case 1: _var_ matches if std_node is a name node and automatically returns a mapping and symbol table\n            case 2: __exp__ matches to any subtree and automatically returns a mapping and symbol table\n            case 3: ___ matches to any subtree and automatically returns a mapping\n            case 4: matches only if the exact names are the same (falls through to shallow_match_generic)\n        Args:\n            ins_node:\n            std_node:\n            check_meta:\n\n        Returns:\n            list of AstMap: a mapping of ins_node to std_node and possibly a symbol_table, or False if it doesn't match\n        \"\"\"\n        ins_node.ast_node._id = ins_node.id\n        return self.shallow_symbol_handler(ins_node, std_node, \"id\", check_meta)\n\n    # noinspection PyPep8Naming,PyMethodMayBeStatic\n    def shallow_match_Pass(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        An empty body should match to anything\n        Args:\n            ins_node: Instructor ast to find in the student ast\n            std_node: Student AST to search for the instructor ast in\n            check_meta: flag to check whether the fields of the instructor node and the student node should match\n\n        Returns:\n            list of AstMap: a mapping between the isntructor and student asts, or False if such a mapping doesn't exist\n        \"\"\"\n        # if check_meta and ins_node.field != std_node.field:\n        if not self.metas_match(ins_node, std_node, check_meta):\n            return []\n        mapping = AstMap()\n        mapping.add_node_pairing(ins_node, std_node)\n        return [mapping]\n\n    # noinspection PyPep8Naming,PyMethodMayBeStatic\n    def shallow_match_Expr(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        An Expression node (not to be confused with expressions denoted by the instructor nodes in Name ast nodes)\n        should match to anything\n        Args:\n            ins_node: Instructor ast to find in the student ast\n            std_node: Instructor ast to find in the student ast\n            check_meta: flag to check whether the fields of the instructor node and the student node should match\n\n        Returns:\n            a mapping between the instructor and student asts, or False if such a mapping doesn't exist\n        \"\"\"\n        # if check_meta and ins_node.field != std_node.field:\n        if not self.metas_match(ins_node, std_node, check_meta):\n            return []\n        mapping = AstMap()\n        mapping.add_node_pairing(ins_node, std_node)\n        return [mapping]\n\n    def shallow_match_Call(self, ins_node, std_node, check_meta=True):\n        return self.shallow_match_main(ins_node, std_node, check_meta, ignores=None)\n        # matches = self.shallow_match_main(ins_node, std_node, check_meta, ignores=[\"func\"])\n        # if matches:\n        #    pass\n        # return None\n        # TODO: Make this handle Calls more intelligently\n\n    # noinspection PyPep8Naming\n    def shallow_match_FunctionDef(self, ins_node, std_node, check_meta=True):\n        ins = ins_node.astNode\n        std = std_node.astNode\n        meta_matched = self.metas_match(ins_node, std_node, check_meta)\n        is_match = type(ins).__name__ == type(std).__name__ and meta_matched\n        mapping = self.shallow_match_main(ins_node, std_node, check_meta, ignores=['name', 'args'])\n        matched = False\n        if is_match and mapping:\n            name = ins.name\n            match = _name_regex(name)\n            if match[_VAR] and meta_matched:  # variable\n                ins._id = name\n                std._id = std.name\n                mapping[0].add_func_to_sym_table(ins_node, std_node)  # TODO: Capture result?\n                matched = True\n            elif match[_WILD] and meta_matched:\n                matched = True\n            elif name == std.name and meta_matched:\n                matched = True\n        if matched:\n            return mapping\n        else:\n            return []\n\n    # noinspection PyMethodMayBeStatic\n    def shallow_match_generic(self, ins_node, std_node, check_meta=True):\n        \"\"\"\n        Checks that all non astNode attributes are equal between ins_node and std_node\n        Args:\n            ins_node: Instructor ast root node\n            std_node: Student AST root node\n            check_meta: flag to check whether the fields of the instructor node and the student node should match\n\n        Returns:\n            list of AstMap: a mapping between the instructor and student root nodes (potentially empty)\n        \"\"\"\n        return self.shallow_match_main(ins_node, std_node, check_meta=check_meta)\n\n    def shallow_match_main(self, ins_node, std_node, check_meta=True, ignores=None):\n        \"\"\"\n        Checks that all non astNode attributes are equal between ins_node and std_node\n        Args:\n            ins_node: Instructor ast root node\n            std_node: Student AST root node\n            check_meta: flag to check whether the fields of the instructor node and the student node should match\n            ignores: a mapping between the instructor and student root nodes, or False if such a mapping doesn't exist\n\n        Returns:\n\n        \"\"\"\n        if ignores is None:\n            ignores = []\n        ignores.append(\"_id\")  # special exception for symbols in lookup tables\n        ins = ins_node.astNode\n        std = std_node.astNode\n        ins_field_list = list(ast.iter_fields(ins))\n        std_field_list = list(ast.iter_fields(std))\n        meta_matched = self.metas_match(ins_node, std_node, check_meta)\n        is_match = len(ins_field_list) == len(std_field_list) and type(ins).__name__ == type(\n            std).__name__ and meta_matched\n        for insTup, stdTup in zip(ins_field_list, std_field_list):\n            if not is_match:\n                break\n\n            ins_field = insTup[0]\n            ins_value = insTup[1]\n            std_field = stdTup[0]\n            std_value = stdTup[1]\n\n            if ins_value is None:\n                continue\n\n            ignore_field = ins_field in ignores\n\n            is_match = (ins_field == std_field) or ignore_field\n\n            if not isinstance(ins_value, list):\n                ins_value = [ins_value]\n\n            if not isinstance(std_value, list):\n                std_value = [std_value]\n\n            # is_match = len(ins_value) == len(std_value)# for stretchy matching this isn't True\n            # Reference ast_node_visitor.js for the original behavior and keep note of it for the purposes of handling\n            # the children noting the special case when the nodes of the array are actually parameters of the node\n            # (e.g. a load function) instead of a child node\n            if not ignore_field:\n                for inssub_value, stdsub_value in zip(ins_value, std_value):\n                    if not is_match:\n                        break\n                    # TODO: make this a smarter comparison, maybe handle dictionaries, f-strings, tuples, etc.\n                    if is_primitive(inssub_value):\n                        is_match = inssub_value == stdsub_value\n        if is_match:\n            mapping = AstMap()  # return MAPPING\n            mapping.add_node_pairing(ins_node, std_node)\n            return [mapping]\n        else:\n            return []\n\n    # filter function for various types of nodes\n    def shallow_match(self, ins_node, std_node, check_meta=True):\n        method_name = 'shallow_match_' + type(ins_node.astNode).__name__\n        target_func = getattr(self, method_name, self.shallow_match_generic)\n        return target_func(ins_node, std_node, check_meta=check_meta)\n\n    @staticmethod\n    def metas_match(ins_node, std_node, check_meta=True):\n        \"\"\"\n        Args:\n            ins_node:\n            std_node:\n            check_meta:\n\n        Returns:\n\n        \"\"\"\n        return ((check_meta and ins_node.field == std_node.field) or\n                not check_meta\n                # or std_node.field == _NONE_FIELD\n                or ins_node.field == _NONE_FIELD)\n", "src/lib/pedal/cait/cait_api.py": "from pedal.report import MAIN_REPORT\nfrom pedal.cait.stretchy_tree_matching import StretchyTreeMatcher\nfrom pedal.cait.cait_node import CaitNode\nimport ast\n\n\nclass CaitException(Exception):\n    pass\n\n\n\"\"\"\nCaitReport:\n    A collection of information from the latest CAIT run.\n\n    Attrs:\n        ast: The CaitNode tree that was most recently parsed out.\n        cache[str:CaitNode]: A dictionary mapping student code (str) to\n            parsed representations.\n        success: Whether there have been any errors so far.\n        error: The exception that occurred, or None if no exception so far.\n\"\"\"\n\n\ndef _parse_source(code, cait_report):\n    \"\"\"\n    Parses the given code and returns its Cait representation. If the parse was\n    unsuccessful, it attaches the error to the report.\n\n    Args:\n        code (str): A string of Python code.\n        cait_report (dict): A Cait Report to store information in.\n    Returns:\n        AstNode: The parsed AST reprensetation, or None\n    \"\"\"\n    try:\n        parsed = ast.parse(code)\n    except SyntaxError as e:\n        cait_report['success'] = False\n        cait_report['error'] = e\n        return ast.parse(\"\")\n    return parsed\n\n\ndef _load_cait(student_code, report):\n    \"\"\"\n    Retrieves the current report for CAIT. If there is no CAIT report, it will\n    generate one. If source code is given, that will be used instead of the\n    report's source code.\n\n    Args:\n        student_code (str): The code to parse into the a CaitNode tree. If\n            None, then it will use the code in the report's Source tool.\n        report (Report): The report to attach data to.\n\n    Returns:\n        dict: Returns the Cait Report\n    \"\"\"\n    if 'cait' not in report:\n        report['cait'] = {'success': True, 'error': None,\n                          'ast': None, 'cache': {}}\n    cait = report['cait']\n    if student_code is not None:\n        if student_code in cait['cache']:\n            cait['ast'] = cait['cache'][student_code]\n            return cait\n        else:\n            student_ast = _parse_source(student_code, cait)\n    elif report['source']['success']:\n        student_code = report['source']['code']\n        if student_code in cait['cache']:\n            cait['ast'] = cait['cache'][student_code]\n            return cait\n        else:\n            student_ast = report['source']['ast']\n    else:\n        report.attach(\"No source code found\", tool='cait',\n                      category='analyzer')\n        cait['success'] = False\n        cait['ast'] = CaitNode(ast.parse(\"\"), report=report)\n        return cait\n    cait['ast'] = cait['cache'][student_code] = CaitNode(student_ast, report=report)\n    return cait\n\n\ndef require_tifa(self):\n    \"\"\"\n    Confirms that TIFA was run successfully, otherwise raises a\n    CaitException.\n    \"\"\"\n    if not self.report['tifa']['success']:\n        raise CaitException(\"TIFA was not run prior to CAIT.\")\n\n\n# noinspection PyBroadException\ndef parse_program(student_code=None, report=None):\n    \"\"\"\n    Parses student code and produces a CAIT representation.\n\n    Args:\n        student_code (str): The student source code to parse. If None, defaults\n            to the code within the Source tool of the given Report.\n        report (Report): The report to attach data to. Defaults to MAIN_REPORT.\n\n    Returns:\n        CaitNode: A CAIT-enhanced representation of the root Node.\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    cait_report = _load_cait(student_code, report)\n    return cait_report['ast']\n\n\ndef expire_cait_cache(report=None):\n    \"\"\"\n    Deletes the most recent CAIT run and any cached CAIT parses.\n\n    Args:\n        report (Report): The report to attach data to. Defaults to MAIN_REPORT.\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    report['cait']['ast'] = None\n    report['cait']['cache'] = {}\n\n\ndef def_use_error(node, report=None):\n    \"\"\"\n    Checks if node is a name and has a def_use_error\n\n    Args:\n        node (str or AstNode or CaitNode): The Name node to look up.\n        report (Report): The report to attach data to. Defaults to MAIN_REPORT.\n    Returns:\n        True if the given name has a def_use_error\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    if not isinstance(node, str) and node.ast_name != \"Name\":\n        raise TypeError\n    try:\n        def_use_vars = report['tifa']['issues']['Initialization Problem']\n    except KeyError:\n        return False\n    if not isinstance(node, str):\n        node_id = node.id\n    else:\n        node_id = node\n    has_error = False\n    for issue in def_use_vars:\n        name = issue['name']\n        if name == node_id:\n            has_error = True\n            break\n    return has_error\n\n\n# noinspection PyBroadException\ndef data_state(node, report=None):\n    \"\"\"\n    Determines the Tifa State of the given node.\n\n    Args:\n        node (str or AstNode or CaitNode): The Name node to look up in TIFA.\n        report (Report): The report to attach data to. Defaults to MAIN_REPORT.\n    Returns:\n        The State of the object (Tifa State) or None if it doesn't exist\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    if not isinstance(node, str) and node.ast_name != \"Name\":\n        raise TypeError\n    if isinstance(node, str):\n        node_id = node\n    else:\n        node_id = node.id\n    try:\n        return report['tifa'][\"top_level_variables\"][node_id]\n    except KeyError:\n        return None\n\n\ndef data_type(node, report=None):\n    \"\"\"\n    Looks up the type of the node using Tifa's analysis.\n\n    Args:\n        node (str or AstNode or CaitNode): The Name node to look up in TIFA.\n        report (Report): The report to attach data to. Defaults to MAIN_REPORT.\n    Returns:\n        The type of the object (Tifa type) or None if a type doesn't exist\n    \"\"\"\n    state = data_state(node, report=report)\n    if state is not None:\n        return state.type\n    return None\n\n\ndef find_match(pattern, student_code=None, report=None, cut=False):\n    \"\"\"\n    Apply Tree Inclusion and return the first match of the `pattern` in the\n    `student_code`.\n\n    Args:\n        pattern (str): The CaitExpression to match against.\n        student_code (str): The string of student code to check against.\n            Defaults to the code of the Source tool in the Report.\n        report (Report): The report to attach data to.\n        cut (bool): Set to true to trim root to first branch\n    Returns:\n        CaitNode or None: The first matching node for the given pattern, or\n            None if nothing was found.\n    \"\"\"\n    matches = find_matches(pattern=pattern, student_code=student_code,\n                           report=report, cut=cut)\n    if matches:\n        return matches[0]\n    else:\n        return None\n\n\ndef find_matches(pattern, student_code=None, report=None, cut=False):\n    \"\"\"\n    Apply Tree Inclusion and return all matches of the `pattern` in the\n    `student_code`.\n\n    Args:\n        pattern (str): The CaitExpression to match against.\n        student_code (str): The string of student code to check against.\n        report (Report): The report to attach data to.\n        cut (bool): Set to true to trim root to first branch\n    Returns:\n        List[CaitNode]: All matching nodes for the given pattern.\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    cait_report = _load_cait(student_code, report)\n    if not cait_report['success']:\n        return []\n    student_ast = cait_report['ast']\n    matcher = StretchyTreeMatcher(pattern, report=report)\n    return matcher.find_matches(student_ast)\n\n\ndef find_submatches(pattern, student_code, is_mod=False):\n    \"\"\"\n    Incomplete.\n    \"\"\"\n    return find_expr_sub_matches(pattern, student_code, is_mod)\n\n\ndef find_expr_sub_matches(pattern, student_code, is_mod=False, report=None):\n    \"\"\"\n    Finds pattern in student_code\n    # TODO: Add code to make pattern accept CaitNodes\n    # TODO: Make this function without so much meta knowledge\n    Args:\n        pattern: the expression to find (str that MUST evaluate to a Module node with a single child or an AstNode)\n        student_code: student subtree\n        is_mod (bool): currently hack for multiline sub matches\n        report: defaults to MAIN_REPORT unless another one exists\n    Returns:\n        a list of matches or False if no matches found\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    is_node = isinstance(pattern, CaitNode)\n    if not isinstance(pattern, str) and not is_node:\n        raise TypeError(\"pattern expected str or CaitNode, found {0}\".format(type(pattern)))\n    matcher = StretchyTreeMatcher(pattern, report=report)\n    if (not is_node and not is_mod) and len(matcher.root_node.children) != 1:\n        raise ValueError(\"pattern does not evaluate to a singular statement\")\n    return matcher.find_matches(student_code, check_meta=False)\n", "src/lib/pedal/cait/cait_node.py": "import ast\nfrom pedal.cait.ast_helpers import dump\nfrom types import MethodType\nfrom pedal.report import MAIN_REPORT\n\n\nclass CaitNode:\n    \"\"\"\n    A wrapper class for AST nodes. Linearizes access to the children of the ast\n    node and saves the field this AST node\n    originated from.\n\n    Attributes:\n        ast_name (str): The name of the original AstNode (e.g., \"Name\" or\n            \"FunctionDef\")\n\n    TODO: May want to just add fields and methods to the existing AST nodes and\n    use a production pattern instead.\n    \"\"\"\n\n    def __init__(self, ast_node, my_field='', tid=0, lin_tree=None,\n                 ancestor=None, report=None):\n        \"\"\"\n\n        Args:\n            ast_node (ast_node): The AST node to be wrapped\n            my_field (str): the field of the parent node that produced this child.\n            tid (int): the tree id\n            lin_tree list of cait_node: A linear version of the tree\n            ancestor (cait_node): The parent of this node\n            report: The report associated with this particular match.\n        \"\"\"\n        if report is None:\n            report = MAIN_REPORT\n        self.report = report\n        self.children = []\n        self.astNode = ast_node\n        self.field = my_field\n        self.tree_id = tid\n        self.parent = ancestor\n        if lin_tree is None:\n            self.linear_tree = [self]\n        else:\n            lin_tree.append(self)\n            self.linear_tree = lin_tree\n\n        # reference to the easy node wrapping the ast_node\n        setattr(ast_node, 'cait_node', self)\n\n        tid_count = tid\n\n        my_field_generator = ast.iter_fields(self.astNode)\n        for item in my_field_generator:\n            field, value = item\n            # if the field doesn't have a value, no child exists\n            if value is None:\n                continue\n\n            # If the children are not in an array, wrap it in an array for\n            # consistency in the code the follows\n            if not isinstance(value, list):\n                value = [value]\n\n            # Reference ast_node_visitor.js for the original behavior and keep note of it for the purposes of handling\n            # the children noting the special case when the nodes of the array are actually parameters of the node\n            # (e.g. a load function) instead of a child node\n            for sub_value in value:\n                if isinstance(sub_value, ast.AST):\n                    new_child = CaitNode(sub_value, my_field=field,\n                                         tid=tid_count + 1,\n                                         lin_tree=self.linear_tree,\n                                         ancestor=self,\n                                         report=self.report)\n                    self.children.append(new_child)\n                    tid_count = len(self.linear_tree) - 1\n\n    def __str__(self):\n        return ''.join([self.field, \"\\n\", dump(self.astNode)])\n\n    def numeric_logic_check(self, mag, expr):\n        \"\"\"\n        If this node is a Compare or BoolOp node, sees if the logic in expr (a javascript string being a logical\n        statement) matches the logic of self. This assumes that we are only comparing numerical values to a single\n        variable\n        TODO: modify this to take multiple variables\n        TODO: modify to support more than +, -, *, and / BinOps\n        TODO: modify to support unary operators other than USub and Not\n        TODO: This is very finicky and buggy, try not to use it\n        Args:\n            mag (float): the order of magnitude that should be added to numbers to check logic, 1 is usually a good value,\n                    especially when working with the set of integers.\n            expr (Compare or BoolOp): the \"Compare\" or \"BoolOp\" tree to check self against\n\n        Returns:\n            bool: True if self (typically student node) and expr are equivalent boolean expressions\n        \"\"\"\n\n        def eval_unop(unop_num, unop_node):\n            operand = eval_selector(unop_num, unop_node.operand)\n            op = unop_node.op_name\n\n            return {\"USub\": -operand,\n                    \"Not\": not operand}[op]\n\n        def eval_binop(binop_num, binop_node):\n            left = eval_selector(binop_num, binop_node.left)\n            right = eval_selector(binop_num, binop_node.right)\n            op = binop_node.op_name\n\n            return {\n                \"Add\": left + right,\n                \"Sub\": left - right,\n                \"Mult\": left * right,\n                \"Div\": left / right}[op]\n\n        def eval_selector(op_num, op_expr):\n            op_expr = op_num if op_expr.ast_name == \"Name\" else op_expr\n            if isinstance(op_expr, (int, float)):\n                return op_expr\n            if op_expr.ast_name == \"BinOp\":\n                return eval_binop(op_num, op_expr)\n            if op_expr.ast_name == \"UnaryOp\":\n                return eval_unop(op_num, op_expr)\n            if op_expr.ast_name == \"Num\":\n                return op_expr.n\n            raise NotImplementedError\n\n        def eval_bool_comp(num_list, comp_ast):\n            ops = comp_ast.ops_names\n            comps = comp_ast.comparators\n            results = []\n            current = comp_ast.left\n            left = current\n\n            for num_i in num_list:\n                result = True\n                for op, comp in zip(ops, comps):\n                    current = eval_selector(num_i, current)\n                    comp_p = eval_selector(num_i, comp)\n\n                    res = {\n                        \"Eq\": current == comp_p,\n                        \"NotEq\": current != comp_p,\n                        \"Lt\": current < comp_p,\n                        \"LtE\": current <= comp_p,\n                        \"Gt\": current > comp_p,\n                        \"GtE\": current >= comp_p,\n                    }[op]\n                    current = comp\n                    result = result and res\n                    if not result:\n                        break\n                results.append(result)\n                current = left\n            return results\n\n        def eval_boolop(num_list, boolop_ast):\n            boolop = boolop_ast.op_name\n            values = boolop_ast.values\n            results_c = None\n            is_and = boolop == \"And\"\n            for value in values:\n                if value.ast_name == \"Compare\":\n                    results = eval_bool_comp(num_list, value)\n                else:  # should be boolop\n                    results = eval_boolop(num_list, value)\n                if results_c is None:\n                    results_c = results\n                else:  # compile results\n                    new_result = []\n                    for result1, result2 in zip(results_c, results):\n                        if is_and:\n                            new_result.append(result1 and result2)\n                        else:\n                            new_result.append(result1 or result2)\n                    results_c = new_result\n            return results_c\n\n        try:\n            ins_expr = CaitNode(ast.parse(expr), report=self.report).body[0].value\n            ins_nums = ins_expr.find_all(\"Num\")\n            std_nums = self.find_all(\"Num\")\n            test_nums = []\n            for num in ins_nums:\n                raw_num = num.n\n                test_nums.append(raw_num)\n                test_nums.append(raw_num + mag)\n                test_nums.append(raw_num - mag)\n            for num in std_nums:\n                raw_num = num.n\n                test_nums.append(raw_num)\n                test_nums.append(raw_num + mag)\n                test_nums.append(raw_num - mag)\n\n            if self.ast_name == \"Compare\":\n                std_res = eval_bool_comp(test_nums, self)\n            elif self.ast_name == \"BoolOp\":\n                std_res = eval_boolop(test_nums, self)\n            else:\n                return False\n\n            if ins_expr.ast_name == \"Compare\":\n                ins_res = eval_bool_comp(test_nums, ins_expr)\n            elif ins_expr.ast_name == \"BoolOp\":\n                ins_res = eval_boolop(test_nums, ins_expr)\n            else:\n                raise TypeError\n            return ins_res == std_res\n        except Exception:\n            return False\n\n    def get_next_tree(self):\n        \"\"\"Gets the next tree in the AST\n        This method gets the next AST node that is of equal or higher level than self. Returns None if the end of the\n        tree is reached\n        TODO: Create a get sibling method.\n\n        Returns:\n            cait_node: The next tree in the AST\n\n        \"\"\"\n\n        # adding function to track tree ids\n        def visit_counter(self, node):\n            self.counter += 1\n            self.generic_visit(node)\n\n        node_counter = ast.NodeVisitor()\n        setattr(node_counter, 'counter', self.tree_id)\n        node_counter.visit = MethodType(visit_counter, node_counter)\n\n        # getting ids\n        node_counter.visit(self.astNode)\n        out_of_tree = node_counter.counter >= len(self.linear_tree)  # check if out of bounds\n        # len(self.children) > 0 and self.children[-1] == node_counter\n        if out_of_tree:\n            return None\n        return self.linear_tree[node_counter.counter]\n\n    def get_child(self, node):\n        \"\"\"\n\n        Args:\n            node: a non-CaitNode ast node\n\n        Returns:\n            cait_node: the corresponding cait_node to the child\n        \"\"\"\n        if isinstance(node, ast.AST):\n            for child in self.children:\n                if child.astNode == node:\n                    return child\n        elif isinstance(node, int):\n            return self.children(node)\n        return None\n\n    @staticmethod\n    def get_ast_name(node):\n        return type(node).__name__\n\n    def get_clashing_attr(self, key):\n        if key == \"value\":\n            return self.get_value()\n\n    def __getattr__(self, item):\n        key = item\n        \"\"\"\n        Non-ast node attributes based on ast_node attributes\n        \"\"\"\n        node_name = CaitNode.get_ast_name(self.astNode)\n        if node_name == \"Assign\" and key == \"target\":\n            key = \"targets\"\n        if item in AST_SINGLE_FUNCTIONS:\n            key = item[:-5]  # strip suffix '_name'\n        if item in AST_ARRAYS_OF_FUNCTIONS:\n            key = item[:-6]  # strip suffix '_names'\n\n        \"\"\"\n        Non-ast node attributes\n        \"\"\"\n        if key == 'next_tree':\n            return self.get_next_tree()\n        if key == 'ast_name':\n            return node_name\n        elif key == '_name':\n            return self.astNode.name\n        elif key == 'ast_node':\n            return self.astNode\n        else:  # ast node attributes or derivative attributes\n            if hasattr(self.astNode, key):\n                # noinspection PyBroadException\n                try:\n                    field = self.astNode.__getattribute__(key)\n                except Exception:\n                    field = None\n                if node_name == \"Assign\" and item != key:\n                    if item == \"target\":\n                        return field[0].cait_node  # Get's the relevant ast node\n                    elif item == \"targets\" and isinstance(field, list):\n                        easy_array = []\n                        for node in field:\n                            easy_array.append(node.cait_node)\n                        return easy_array\n                    else:\n                        return field\n                elif item in AST_SINGLE_FUNCTIONS:\n                    return type(field).__name__\n                elif item in AST_ARRAYS_OF_FUNCTIONS:\n                    str_ops_list = []\n                    for op in field:\n                        str_ops_list.append(type(op).__name__)\n                        return str_ops_list\n                elif isinstance(field, ast.AST):\n                    return field.cait_node\n                elif isinstance(field, list):\n                    try:\n                        return [f.cait_node for f in field]\n                    except AttributeError:\n                        # This can only happen in NonLocals, which has a list\n                        # of raw strings in the `names` property\n                        return field\n                else:\n                    return field\n            else:  # get added field that may have existed for different node types\n                return self.get_clashing_attr(key)\n\n    def find_matches(self, pattern, is_mod=False, check_meta=True):\n        \"\"\"\n        Retrieves any patterns that match against this CaitNode. Expected to be\n        used for subpattern matching.\n        \"\"\"\n        # Avoid circular import\n        import pedal.cait.stretchy_tree_matching as stm\n        is_node = isinstance(pattern, CaitNode)\n        if not isinstance(pattern, str) and not is_node:\n            raise TypeError(\"pattern expected str or CaitNode, found {0}\".format(type(pattern)))\n        matcher = stm.StretchyTreeMatcher(pattern, report=self.report)\n        if (not is_node and not is_mod) and len(matcher.root_node.children) != 1:\n            raise ValueError(\"pattern does not evaluate to a singular statement\")\n        return matcher.find_matches(self, check_meta=check_meta)\n\n    def find_match(self, pattern, is_mod=False):\n        matches = self.find_matches(pattern, is_mod)\n        if len(matches) != 0:\n            return matches[0]\n        return None\n\n    def find_all(self, node_type):\n        \"\"\"Finds all nodes defined by string node_type\n\n        Args:\n            node_type: the string representing the \"type\" of node to look for\n\n        Returns:\n            a list of Ast Nodes (cait_nodes) of self that are of the specified type (including self if self\n                    meets that criteria)\n        \"\"\"\n        items = []\n        visitor = ast.NodeVisitor()\n        # setattr(visitor, \"current_id\", self.tree_id - 1)\n        setattr(visitor, \"items\", items)\n        func_name = 'visit_' + node_type\n\n        def main_visit(self, node):\n            self.items.append(node.cait_node)\n            return self.generic_visit(node)\n\n        func_ref = main_visit\n        setattr(visitor, func_name, MethodType(func_ref, visitor))\n        visitor.visit(self.astNode)\n        return visitor.items\n\n    def has(self, node):\n        \"\"\"\n        Determine if this node has the given `node`.\n        \"\"\"\n        if isinstance(node, (int, float)):\n            visitor = ast.NodeVisitor()\n            has_num = []\n\n            def visit_Num(self, potential):\n                has_num.append(node == potential.n)\n                return self.generic_visit(potential)\n\n            visitor.visit_Num = MethodType(visit_Num, visitor)\n            visitor.visit(self.astNode)\n            return any(has_num)\n        elif node.ast_name != \"Name\":\n            return False\n        visitor = ast.NodeVisitor()\n        has_name = []\n\n        def visit_Name(self, potential):\n            has_name.append(node.id == potential.id)\n            return self.generic_visit(potential)\n\n        visitor.visit_Name = MethodType(visit_Name, visitor)\n        visitor.visit(self.astNode)\n        return any(has_name)\n\n    def is_before(self, other):\n        \"\"\"\n        Uses tree id to check if self node came before other.\n        Args:\n            other (cait_node): the other node to compare to\n\n        Returns:\n            bool: True if self is before other\n        \"\"\"\n        try:\n            return self.tree_id < other.tree_id and self.linear_tree == other.linear_tree\n        except Exception:\n            raise TypeError\n\n    def is_ast(self, ast_name):\n        \"\"\"\n        Checks self is the type of the specified ast node\n        Args:\n            ast_name (str): The name of the ast node type\n\n        Returns:\n            bool: True if this node's ast name matches the specified one\n        \"\"\"\n        if not isinstance(ast_name, str):\n            ast_name = CaitNode.get_ast_name(ast_name.astNode)\n        return CaitNode.get_ast_name(self.astNode).lower() == ast_name.lower()\n\n    def is_method(self):\n        \"\"\"\n        Checks if self is a method\n\n        Returns:\n            bool: True if I'm a FunctionDef, and if any of my parents are ClassDef.\n        \"\"\"\n        # Check if I'm a FunctionDef, and if any of my parents are ClassDef.\n        if self.ast_name != \"FunctionDef\":\n            return False\n        current = self.parent\n        while current is not None:\n            if current.ast_name == \"ClassDef\":\n                return True\n            # Don't treat closures as methods\n            elif current.ast_name == \"FunctionDef\":\n                return False\n            current = current.parent\n        return False\n\n    def get_data_state(self):\n        \"\"\"\n        Gets the data_state object of self\n\n        Returns:\n            data_state or None: returns data_state if self is a name and exists, otherwise None\n        \"\"\"\n        if self.ast_name != \"Name\":\n            return None\n        try:\n            return self.report['tifa'][\"top_level_variables\"][self.id]\n        except KeyError:\n            return None\n\n    def get_data_type(self):\n        \"\"\"\n\n        Returns:\n            type of the variable associated with this node if it's a name node, otherwise None.\n        \"\"\"\n        state = self.get_data_state()\n        if state is None:\n            return None\n        else:\n            return state.type\n\n    def was_type(self, tp):\n        \"\"\"\n\n         Returns:\n             type of the variable associated with this node if it's a name node, otherwise None.\n         \"\"\"\n        state = self.get_data_state()\n        if state is None:\n            return None\n        else:\n            return state.was_type(tp)\n\n    def get_value(self):\n        \"\"\"\"\n        Returns:\n            Value of node if Num or Str, and get_data_state if Name\n        \"\"\"\n        value = None\n        if self.is_ast(\"Num\"):\n            value = self.n\n        elif self.is_ast(\"Str\"):\n            value = self.s\n        elif self.is_ast(\"Name\"):\n            # TODO: Decide on what this should return...\n            value = self.id\n        return value\n\n\nAST_SINGLE_FUNCTIONS = [\"ctx_name\", \"op_name\"]\nAST_ARRAYS_OF_FUNCTIONS = [\"ops_names\"]\n", "src/lib/pedal/cait/__init__.py": "\"\"\"\nA package of tools for capturing student code by matching it against patterns.\n\"\"\"\n\nNAME = 'CAIT'\nSHORT_DESCRIPTION = \"Captures instructor code patterns within student code.\"\nDESCRIPTION = '''\n'''\nREQUIRES = ['Source']\nOPTIONALS = ['TIFA']\n\nfrom pedal.cait.cait_api import (find_match, find_matches,\n                                 parse_program,\n                                 find_submatches, find_expr_sub_matches,\n                                 def_use_error, data_state, data_type,\n                                 expire_cait_cache)\n", "src/lib/pedal/cait/ast_helpers.py": "\"\"\"\nA pretty-printing dump function for the ast module.  The code was copied from\nthe ast.dump function and modified slightly to pretty-print.\n\nAlex Leone (acleone ~AT~ gmail.com), 2010-01-30\n\nFrom http://alexleone.blogspot.co.uk/2010/01/python-ast-pretty-printer.html\n\"\"\"\n\nfrom ast import AST, iter_fields, parse\n\n\ndef dump(node, annotate_fields=True, include_attributes=False, indent='  '):\n    \"\"\"\n    Return a formatted dump of the tree in *node*.  This is mainly useful for\n    debugging purposes.  The returned string will show the names and the values\n    for fields.  This makes the code impossible to evaluate, so if evaluation is\n    wanted *annotate_fields* must be set to False.  Attributes such as line\n    numbers and column offsets are not dumped by default.  If this is wanted,\n    *include_attributes* can be set to True.\n    \"\"\"\n\n    def _format(_node, level=0):\n        if isinstance(_node, AST):\n            fields = [(a, _format(b, level)) for a, b in iter_fields(_node)]\n            if include_attributes and _node._attributes:\n                fields.extend([(a, _format(getattr(_node, a), level))\n                               for a in _node._attributes])\n            return ''.join([\n                _node.__class__.__name__,\n                '(',\n                ', '.join(('%s=%s' % field for field in fields)\n                          if annotate_fields else\n                          (b for a, b in fields)),\n                ')'])\n        elif isinstance(_node, list):\n            lines = ['[']\n            lines.extend((indent * (level + 2) + _format(x, level + 2) + ','\n                          for x in _node))\n            if len(lines) > 1:\n                lines.append(indent * (level + 1) + ']')\n            else:\n                lines[-1] += ']'\n            return '\\n'.join(lines)\n        return repr(_node)\n\n    if not isinstance(node, AST):\n        raise TypeError('expected AST, got %r' % node.__class__.__name__)\n    return _format(node)\n\n\ndef parseprint(code, filename=\"<string>\", mode=\"exec\", **kwargs):\n    \"\"\"Parse some code from a string and pretty-print it.\"\"\"\n    node = parse(code, mode=mode)  # An ode to the code\n    print(dump(node, **kwargs))\n\n\n# Short name: pdp = parse, dump, print\npdp = parseprint\n", "src/lib/pedal/cait/ast_map.py": "from pedal.cait.cait_node import CaitNode\n\n\nclass AstSymbol:\n    \"\"\"\n    This represents an Ast symbol, whether it be a variable (name node) or a function name\n    for place holders used in instructor patterns\n\n    Notes:\n        Also has the attributes of the relevant Name node from the ast class.\n\n    Attributes:\n        id (str): the name of the variable place holder used by the instructor\n        ast_node (cait_node): the ast node of the variable\n    \"\"\"\n\n    def __init__(self, _id=\"\", _node=None):\n        self.id = _id\n        self.astNode = _node\n        self.ast_node = _node\n\n    def __getattr__(self, attr):\n        return getattr(self.astNode, attr)\n\n    def __str__(self):\n        # return ''.join([\"id = \", self.id.__str__(), \", astNode = \", type(self.astNode).__name__])\n        return self.id\n\n    def __repr__(self):\n        return ''.join([\"id = \", self.id.__str__(), \", astNode = \", type(self.astNode).__name__])\n\n\nclass AstSymbolList:\n    \"\"\"\n    This class is a wrapper for a list of AstSymbols for ease of access\n    If accessed as a list, manipulable as a list, otherwise, acts as the first AstSymbol in the list\n    \"\"\"\n\n    def __init__(self):\n        self.my_list = []\n\n    def __getitem__(self, item):\n        return self.my_list.__getitem__(item)\n\n    def append(self, item):\n        self.my_list.append(item)\n\n    def __getattr__(self, attr):\n        return getattr(self.my_list[0], attr)\n\n    def __len__(self):\n        return self.my_list.__len__()\n\n\nclass AstMap:\n    def __init__(self):\n        self.mappings = {}\n        self.symbol_table = {}\n        self.exp_table = {}\n        self.func_table = {}\n        self.conflict_keys = []\n        self.match_root = None\n        self.diagnosis = \"\"\n\n    def add_func_to_sym_table(self, ins_node, std_node):\n        \"\"\"\n        Adds ins_node.name to the symbol table if it doesn't already exist, mapping it to a set of ins_node. Updates a\n        second dictionary that maps ins_node to an std_node, and overwrites the current std_node since there should only\n        be one mapping.\n\n        Args:\n            ins_node: instructor node or str representing a function name\n            std_node: student node representing function\n\n        Returns:\n            int: number of conflicts generated\n\n        \"\"\"\n        if not isinstance(std_node, CaitNode):\n            raise TypeError\n        if isinstance(ins_node, str):\n            key = ins_node\n        else:\n            try:\n                if ins_node.ast_name == \"FunctionDef\":\n                    key = ins_node.astNode.name\n                else:  # TODO: Little skulpt artifact that doesn't raise Attribute Errors...\n                    key = ins_node._id\n                    raise AttributeError\n            except AttributeError:\n                key = ins_node.astNode._id\n\n        try:\n            if std_node.ast_name == \"FunctionDef\":\n                value = AstSymbol(std_node.astNode.name, std_node)\n            else:  # TODO: Little skulpt artifact that doesn't raise Attribute Errors...\n                raise AttributeError\n#            value = AstSymbol(std_node.astNode.name, std_node)\n        except AttributeError:\n            node = std_node\n            if type(node.astNode).__name__ != \"Call\":\n                node = node.parent\n                node._id = std_node._id\n            value = AstSymbol(std_node._id, node)\n        if key in self.func_table:\n            new_list = self.func_table[key]\n            if value not in new_list:\n                new_list.append(value)\n            if not (key in self.conflict_keys):\n                for other in new_list:\n                    if value.id != other.id:\n                        self.conflict_keys.append(key)\n                        break\n        else:\n            new_list = AstSymbolList()\n            new_list.append(value)\n\n        self.func_table[key] = new_list\n        return len(self.conflict_keys)\n\n    def add_var_to_sym_table(self, ins_node, std_node):\n        \"\"\"\n        Adds ins_node._id to the symbol table if it doesn't already exist, mapping it to a set of ins_node. Updates a\n        second dictionary that maps ins_node to an std_node, and overwrites the current std_node since there should only\n        be one mapping.\n\n        Args:\n            ins_node: instructor node or str representing variable\n            std_node: student node representing variable\n\n        Returns:\n            int: number of conflicts generated\n\n        \"\"\"\n        if not isinstance(std_node, CaitNode):\n            raise TypeError\n        if isinstance(ins_node, str):\n            key = ins_node\n        else:\n            key = ins_node.astNode._id\n        value = AstSymbol(std_node.astNode._id, std_node)\n        if key in self.symbol_table:\n            new_list = self.symbol_table[key]\n            new_list.append(value)\n            if not (key in self.conflict_keys):\n                for other in new_list:\n                    if value._id != other._id:\n                        self.conflict_keys.append(key)\n                        break\n        else:\n            new_list = AstSymbolList()\n            new_list.append(value)\n\n        self.symbol_table[key] = new_list\n        return len(self.conflict_keys)\n\n    def add_exp_to_sym_table(self, ins_node, std_node):\n        \"\"\"\n        Adds mapping of expression symbol to student node\n        This function does NOT check for conflicts at the moment and probably should at some point.\n        TODO: Check for conflicts\n        Args:\n            ins_node: Instructor node representing an expression\n            std_node: student ast subtree corresponding to the symbol\n\n        Returns:\n            None\n        \"\"\"\n        if not isinstance(std_node, CaitNode):\n            raise TypeError\n        self.exp_table[ins_node.astNode.id] = std_node\n\n    def add_node_pairing(self, ins_node, std_node):\n        \"\"\"\n        Adds a mapping of instructor ast node to a specific student ast node\n        Args:\n            ins_node: instructor pattern ast node\n            std_node: student ast node\n\n        Returns:\n            None\n        \"\"\"\n        if not isinstance(std_node, CaitNode):\n            raise TypeError\n        self.mappings[ins_node] = std_node\n\n    def has_conflicts(self):\n        \"\"\"\n\n        Returns:\n            bool: True if number of conflicts is greater than 0\n        \"\"\"\n        return len(self.conflict_keys) > 0\n\n    def new_merged_map(self, other):\n        \"\"\"\n        Returns a newly merged map consisting of this and other\n        without modifying self.\n        Args:\n            other (AstMap): the other AstMap to be merged with\n\n        Returns:\n            AstMap: self modified by adding the contents of other\n        \"\"\"\n        new_map = AstMap()\n        new_map.merge_map_with(self)\n        new_map.merge_map_with(other)\n        return new_map\n\n    def merge_map_with(self, other):\n        \"\"\"\n        Returns a newly merged map consisting of this and other\n        by modifying self\n        Args:\n            other (AstMap): the other AstMap to be merged with\n\n        Returns:\n            AstMap: self modified by adding the contents of other\n        \"\"\"\n        if not isinstance(other, type(self)):\n            raise TypeError\n\n        # merge all mappings\n        self.mappings.update(other.mappings)\n\n        # merge all expressions\n        self.exp_table.update(other.exp_table)\n\n        # merge all symbols\n        for key, value in other.symbol_table.items():\n            for sub_value in value:\n                self.add_var_to_sym_table(key, sub_value.astNode)\n\n        # merge all functions\n        for key, value in other.func_table.items():\n            for sub_value in value:\n                self.add_func_to_sym_table(str(key), sub_value.astNode)\n\n    @property\n    def match_lineno(self):\n        \"\"\"\n\n        Returns:\n            int: the line number this match started on\n        \"\"\"\n        values = [v.lineno for v in self.mappings.values()\n                  if v.lineno is not None]\n        if not values:\n            return -1\n        else:\n            return min(values)\n\n    def __getitem__(self, id_n):\n        if id_n.startswith('__'):\n            return self.exp_table[id_n]\n        else:\n            if id_n in self.symbol_table:\n                return self.symbol_table[id_n]\n            else:\n                return self.func_table[id_n]\n\n    def __contains__(self, id_n):\n        if id_n.startswith('__'):\n            return id_n in self.exp_table\n        else:\n            exists = id_n in self.symbol_table\n            if exists:\n                return exists\n            else:\n                return id_n in self.func_table\n", "src/lib/pedal/sandbox/compatibility.py": "import sys\n\nfrom pedal.sandbox.sandbox import Sandbox\nfrom pedal.sandbox.messages import EXTENDED_ERROR_EXPLANATION\n\nfrom pedal.report import MAIN_REPORT, Feedback\n\n\ndef _check_sandbox(report):\n    if 'run' not in report['sandbox']:\n        report['sandbox']['run'] = Sandbox()\n    return report['sandbox']['run']\n\n\ndef run_student(raise_exceptions=False, report=None, old_style_messages=False):\n    if report is None:\n        report = MAIN_REPORT\n    sandbox = _check_sandbox(report)\n    source_code = report['source']['code']\n    sandbox.run(source_code, report_exceptions=not raise_exceptions)\n    if raise_exceptions:\n        raise_exception(sandbox.exception, sandbox.exception_position,\n                        report=report, message=None if old_style_messages else \n                                               sandbox.exception_formatted)\n    return sandbox.exception\n\n\ndef queue_input(*inputs, **kwargs):\n    if 'report' not in kwargs:\n        report = MAIN_REPORT\n    else:\n        report = kwargs['report']\n    sandbox = _check_sandbox(report)\n    sandbox.set_input(inputs)\n\n\ndef reset_output(report=None):\n    if report is None:\n        report = MAIN_REPORT\n    sandbox = _check_sandbox(report)\n    sandbox.set_output(None)\n\n\ndef get_output(report=None):\n    if report is None:\n        report = MAIN_REPORT\n    sandbox = _check_sandbox(report)\n    return sandbox.output\n\n\ndef get_plots(report=None):\n    if report is None:\n        report = MAIN_REPORT\n    sandbox = _check_sandbox(report)\n    mock_plt = sandbox.modules['matplotlib.pyplot']\n    return mock_plt.plots\n\n\ndef capture_output(function, *args, **kwargs):\n    if 'report' in kwargs:\n        report = kwargs['report']\n    else:\n        report = MAIN_REPORT\n    sandbox = _check_sandbox(report)\n    sandbox.set_output(None)\n    sandbox.call(function.__name__, *args)\n    return sandbox.output\n\n\ndef get_sandbox(report=None):\n    if report is None:\n        report = MAIN_REPORT\n    sandbox = _check_sandbox(report)\n    return sandbox\n\n\ndef raise_exception(exception, position=None, report=None, message=None):\n    if report is None:\n        report = MAIN_REPORT\n    sandbox = _check_sandbox(report)\n    if exception is None:\n        return\n    extended = EXTENDED_ERROR_EXPLANATION.get(exception.__class__, \"\")\n    if message is None:\n        message = \"<pre>{}</pre>\\n{}\".format(str(exception), extended)\n    # Skulpt compatible name lookup\n    name = str(exception.__class__)[8:-2]\n    report.attach(name, category='Runtime', tool='Sandbox',\n                  mistake={'message': message,\n                           'error': exception,\n                           'position': position,\n                           'traceback': None})\n    sandbox.exception = exception\n\n\ndef get_student_data(report=None):\n    if report is None:\n        report = MAIN_REPORT\n    sandbox = _check_sandbox(report)\n    return sandbox\n\n\ndef set_sandbox(sandbox, report=None):\n    \"\"\"\n    Update the sandbox to hold the new sandbox instance. Particularly useful\n    for Skulpt, which needs to set the sandbox in an unusual way.\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    report['sandbox']['run'] = sandbox\n    return sandbox\n\n\ndef trace_lines(report=None):\n    if report is None:\n        report = MAIN_REPORT\n    sandbox = _check_sandbox(report)\n    if sandbox.tracer_style == 'coverage':\n        return sandbox.trace.lines - sandbox.trace.missing\n    else:\n        return []\n", "src/lib/pedal/sandbox/mocked.py": "\"\"\"\nMocked functions that can be used to prevent malicious or accidental `eval`\nbehavior.\n\"\"\"\nimport re\nimport types\n\nfrom pedal.sandbox.exceptions import (SandboxNoMoreInputsException,\n                                      SandboxPreventModule)\n\n\ndef _disabled_compile(source, filename, mode, flags=0, dont_inherit=False):\n    \"\"\"\n    A version of the built-in `compile` method that fails with a runtime\n    error.\n    \"\"\"\n    raise RuntimeError(\"You are not allowed to call 'compile'.\")\n\n\ndef _disabled_eval(object, globals=globals(), locals=locals()):\n    \"\"\"\n    A version of the built-in `eval` method that fails with a runtime\n    error.\n    \"\"\"\n    raise RuntimeError(\"You are not allowed to call 'eval'.\")\n\n\n# -------------------------------------------------------------\n\n\ndef _disabled_exec(object, globals=globals(), locals=locals()):\n    \"\"\"\n    A version of the built-in `exec` method that fails with a runtime\n    error.\n    \"\"\"\n    raise RuntimeError(\"You are not allowed to call 'exec'.\")\n\n\n# -------------------------------------------------------------\n\n\ndef _disabled_globals():\n    \"\"\"\n    A version of the built-in `globals` method that fails with a runtime\n    error.\n    \"\"\"\n    raise RuntimeError(\"You are not allowed to call 'globals'.\")\n    \nclass FunctionNotAllowed(Exception):\n    pass\n    \ndef disabled_builtin(name):\n    def _disabled_version(*args, **kwargs):\n        raise FunctionNotAllowed(\"You are not allowed to call '{}'.\".format(name))\n    return _disabled_version\n\n\n_OPEN_FORBIDDEN_NAMES = re.compile(r\"(^[./])|(\\.py$)\")\n_OPEN_FORBIDDEN_MODES = re.compile(r\"[wa+]\")\n\n\ndef _restricted_open(name, mode='r', buffering=-1):\n    if _OPEN_FORBIDDEN_NAMES.search(name):\n        raise RuntimeError(\"The filename you passed to 'open' is restricted.\")\n    elif _OPEN_FORBIDDEN_MODES.search(mode):\n        raise RuntimeError(\"You are not allowed to 'open' files for writing.\")\n    else:\n        return _original_builtins['open'](name, mode, buffering)\n\n\ntry:\n    __builtins__\nexcept NameError:\n    _default_builtins = {'globals': globals,\n                         'locals': locals,\n                         'open': open,\n                         'input': input}\nelse:\n    if isinstance(__builtins__, types.ModuleType):\n        _default_builtins = __builtins__.__dict__\n    else:\n        _default_builtins = __builtins__\n\n_original_builtins = {\n    'globals': _default_builtins['globals'],\n    'locals': _default_builtins['locals'],\n    'open': _default_builtins['open'],\n    'input': _default_builtins['input'],\n    'exec': _default_builtins.get('exec', _disabled_exec),\n    'eval': _default_builtins.get('eval', _disabled_eval),\n    'compile': _default_builtins.get('compile', _disabled_compile),\n}\n\n\ndef _make_inputs(*input_list, **kwargs):\n    \"\"\"\n    Helper function for creating mock user input.\n\n    Params:\n        input_list (list of str): The list of inputs to be returned\n    Returns:\n        function (str=>str): The mock input function that is returned, which\n                             will return the next element of input_list each\n                             time it is called.\n    \"\"\"\n    if 'repeat' in kwargs:\n        repeat = kwargs['repeat']\n    else:\n        repeat = None\n    generator = iter(input_list)\n\n    def mock_input(prompt=''):\n        print(prompt)\n        try:\n            return next(generator)\n        except StopIteration as SI:\n            if repeat is None:\n                # TODO: Make this a custom exception\n                raise SandboxNoMoreInputsException(\"User had no more input to give.\")\n            else:\n                return repeat\n\n    return mock_input\n\n\n_sys_modules = {}\n\n\ndef _override_builtins(namespace, custom_builtins):\n    \"\"\"\n    Add the custom builtins to the `namespace` (and the original `__builtins__`)\n    suitable for `exec`.\n    \"\"\"\n    # Obtain the dictionary of built-in methods, which might not exist in\n    # some python versions (e.g., Skulpt)\n\n    # Create a shallow copy of the dictionary of built-in methods. Then,\n    # we'll take specific ones that are unsafe and replace them.\n    namespace[\"__builtins__\"] = _default_builtins.copy()\n    for name, function in custom_builtins.items():\n        namespace[\"__builtins__\"][name] = function\n\n\ndef create_module(module_name):\n    submodule_names = module_name.split(\".\")\n    modules = {}\n    root = types.ModuleType(submodule_names[0])\n    modules[submodule_names[0]] = root\n    reconstructed_path = submodule_names[0]\n    for submodule_name in submodule_names[1:]:\n        reconstructed_path += \".\" + submodule_name\n        new_submodule = types.ModuleType(reconstructed_path)\n        setattr(root, submodule_name, new_submodule)\n        modules[reconstructed_path] = new_submodule\n    return root, modules\n\n\nclass MockModule:\n    def _generate_patches(self):\n        return {k: v for k, v in vars(self).items()\n                if not k.startswith('_')}\n\n    def _add_to_module(self, module):\n        for name, value in self._generate_patches().items():\n            setattr(module, name, value)\n\n\nclass BlockedModule(MockModule):\n    MODULE_NAME = \"this module\"\n\n    def _generate_patches(self):\n        return {'__getattr__': self.prevent_module}\n\n    def prevent_module(self, **kwargs):\n        raise SandboxPreventModule(\"You cannot import {module_name} from student code.\".format(\n            module_name=self.MODULE_NAME\n        ))\n\n\nclass MockPedal(BlockedModule):\n    MODULE_NAME = \"pedal\"\n\n\nclass MockPlt(MockModule):\n    \"\"\"\n    Mock MatPlotLib library that can be used to capture plot data.\n\n    Attributes:\n        plots (list of dict): The internal list of plot dictionaries.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._reset_plots()\n\n    def show(self, **kwargs):\n        self.plots.append(self.active_plot)\n        self._reset_plot()\n\n    def unshown_plots(self):\n        return self.active_plot['data']\n\n    def __repr__(self):\n        return repr(self.plots)\n\n    def __str__(self):\n        return str(self.plots)\n\n    def _reset_plots(self):\n        self.plots = []\n        self._reset_plot()\n\n    def _reset_plot(self):\n        self.active_plot = {'data': [],\n                            'xlabel': None, 'ylabel': None,\n                            'title': None, 'legend': False}\n\n    def hist(self, data, **kwargs):\n        label = kwargs.get('label', None)\n        self.active_plot['data'].append({'type': 'hist', 'values': data,\n                                         'label': label})\n\n    def plot(self, xs, ys=None, **kwargs):\n        label = kwargs.get('label', None)\n        if ys is None:\n            self.active_plot['data'].append({'type': 'line',\n                                             'x': list(range(len(xs))),\n                                             'y': xs, 'label': label})\n        else:\n            self.active_plot['data'].append({'type': 'line', 'x': xs,\n                                             'y': ys, 'label': label})\n\n    def scatter(self, xs, ys, **kwargs):\n        label = kwargs.get('label', None)\n        self.active_plot['data'].append({'type': 'scatter', 'x': xs,\n                                         'y': ys, 'label': label})\n\n    def xlabel(self, label, **kwargs):\n        self.active_plot['xlabel'] = label\n\n    def title(self, label, **kwargs):\n        self.active_plot['title'] = label\n\n    def suptitle(self, label, **kwargs):\n        self.title(label, **kwargs)\n\n    def ylabel(self, label, **kwargs):\n        self.active_plot['ylabel'] = label\n\n    def legend(self, **kwargs):\n        self.active_plot['legend'] = True\n\n    def _generate_patches(self):\n        def dummy(**kwargs):\n            pass\n\n        return dict(hist=self.hist, plot=self.plot,\n                    scatter=self.scatter, show=self.show,\n                    xlabel=self.xlabel, ylabel=self.ylabel,\n                    title=self.title, legend=self.legend,\n                    xticks=dummy, yticks=dummy,\n                    autoscale=dummy, axhline=dummy,\n                    axhspan=dummy, axvline=dummy,\n                    axvspan=dummy, clf=dummy,\n                    cla=dummy, close=dummy,\n                    figlegend=dummy, figimage=dummy,\n                    suptitle=self.suptitle, text=dummy,\n                    tick_params=dummy, ticklabel_format=dummy,\n                    tight_layout=dummy, xkcd=dummy,\n                    xlim=dummy, ylim=dummy,\n                    xscale=dummy, yscale=dummy)\n", "src/lib/pedal/sandbox/timeout.py": "\"\"\"\nA module that exposes a useful method (`timeout`) that can execute a\nfunction asynchronously and terminiate if it exceeds a given `duration`.\n\"\"\"\n\nimport sys\nimport time\n\ntry:\n    import threading\nexcept BaseException:\n    threading = None\ntry:\n    import ctypes\nexcept BaseException:\n    ctypes = None\n\n\nclass InterruptableThread(threading.Thread):\n    '''\n    A thread that can be interrupted.\n    '''\n\n    def __init__(self, func, args, kwargs):\n        threading.Thread.__init__(self)\n        self.func, self.args, self.kwargs = func, args, kwargs\n        self.daemon = True\n        self.result = None\n        self.exc_info = (None, None, None)\n\n    def run(self):\n        '''\n        Begin thread execution, calling the `func` that was originally\n        passed in.\n        '''\n        try:\n            self.result = self.func(*self.args, **self.kwargs)\n        except Exception:\n            self.exc_info = sys.exc_info()\n\n    @staticmethod\n    def _async_raise(thread_id, exception):\n        '''\n        Static method to raise an error asychronously using the ctypes module.\n        '''\n        # Cache the function for convenience\n        RaiseAsyncException = ctypes.pythonapi.PyThreadState_SetAsyncExc\n\n        states_modified = RaiseAsyncException(ctypes.c_long(thread_id),\n                                              ctypes.py_object(exception))\n        if states_modified == 0:\n            raise ValueError(\"nonexistent thread id\")\n        elif states_modified > 1:\n            RaiseAsyncException(thread_id, 0)\n            raise SystemError(\"PyThreadState_SetAsyncExc failed\")\n\n    def raise_exception(self, exception):\n        '''\n        Trigger a thread ending exception!\n        '''\n        assert self.isAlive(), \"thread must be started\"\n        for thread_id, thread in threading._active.items():\n            if thread is self:\n                InterruptableThread._async_raise(thread_id, exception)\n                return\n\n    def terminate(self):\n        self.raise_exception(SystemExit)\n\n\ndef timeout(duration, func, *args, **kwargs):\n    \"\"\"\n    Executes a function and kills it (throwing an exception) if it runs for\n    longer than the specified duration, in seconds.\n    \"\"\"\n\n    # If libraries are not available, then we execute normally\n    if None in (threading, ctypes):\n        return func(*args, **kwargs)\n\n    target_thread = InterruptableThread(func, args, kwargs)\n    target_thread.start()\n    target_thread.join(duration)\n\n    if target_thread.isAlive():\n        target_thread.terminate()\n        raise TimeoutError('Your code took too long to run '\n                           '(it was given {} seconds); '\n                           'maybe you have an infinite loop?'.format(duration))\n    else:\n        if target_thread.exc_info[0] is not None:\n            ei = target_thread.exc_info\n            # Python 2 had the three-argument raise statement; thanks to PEP\n            # 3109 for showing how to convert that to valid Python 3 statements.\n            e = ei[0](ei[1])\n            e.__traceback__ = ei[2]\n            raise e\n\n\n# =========================================================================\n\n\nclass _TimeoutData:\n    \"\"\"\n    Port of Craig Estep's AdaptiveTimeout JUnit rule from the VTCS student\n    library.\n    \"\"\"\n\n    # -------------------------------------------------------------\n    def __init__(self, ceiling):\n        self.ceiling = ceiling  # sec\n        self.maximum = ceiling * 2  # sec\n        self.minimum = 0.25  # sec\n        self.threshold = 0.6\n        self.rampup = 1.4\n        self.rampdown = 0.5\n        self.start = self.end = 0\n        self.non_terminating_methods = 0\n\n    # -------------------------------------------------------------\n\n    def before_test(self):\n        \"\"\"\n        Call this before a test case runs in order to reset the timer.\n        \"\"\"\n        self.start = time.time()\n\n    # -------------------------------------------------------------\n\n    def after_test(self):\n        \"\"\"\n        Call this after a test case runs. This will examine how long it took\n        the test to execute, and if it required an amount of time greater than\n        the current ceiling, it will adaptively adjust the allowed time for\n        the next test.\n        \"\"\"\n        self.end = time.time()\n        diff = self.end - self.start\n\n        if diff > self.ceiling:\n            self.non_terminating_methods += 1\n\n        if self.non_terminating_methods >= 2:\n            if self.ceiling * self.rampdown < self.minimum:\n                self.ceiling = self.minimum\n            else:\n                self.ceiling = (self.ceiling * self.rampdown)\n        elif diff > self.ceiling * self.threshold:\n            if self.ceiling * self.rampup > self.maximum:\n                self.ceiling = self.maximum\n            else:\n                self.ceiling = (self.ceiling * self.rampup)\n", "src/lib/pedal/sandbox/__init__.py": "from pedal.report import MAIN_REPORT\nfrom pedal.sandbox.sandbox import Sandbox\n\n# Compatibility API\n'''\nrun_student\nqueue_input\nreset_output\nget_output\n'''\n\n\ndef reset(report=None):\n    if report is None:\n        report = MAIN_REPORT\n    report['sandbox']['run'] = Sandbox(filename=report['source']['filename'])\n\n\ndef run(raise_exceptions=True, report=None, coverage=False, threaded=False, inputs=None):\n    if report is None:\n        report = MAIN_REPORT\n    if 'run' not in report['sandbox']:\n        report['sandbox']['run'] = Sandbox(filename=report['source']['filename'], threaded=threaded)\n    sandbox = report['sandbox']['run']\n    source_code = report['source']['code']\n    sandbox.record_coverage = coverage\n    sandbox.run(source_code, _as_filename=report['source']['filename'], _inputs=inputs)\n    if raise_exceptions and sandbox.exception is not None:\n        name = str(sandbox.exception.__class__)[8:-2]\n        report.attach(name, category='Runtime', tool='Sandbox',\n                      section=report['source']['section'],\n                      mistakes={'message': sandbox.format_exception(),\n                                'error': sandbox.exception})\n    return sandbox\n", "src/lib/pedal/sandbox/result.py": "class SandboxResult:\n    \"\"\"\n    Proxy class for wrapping results from executing student code. Attempts\n    to perfectly emulate the underlying data value, so that users will never\n    realize they have a proxy. The advantage is that special information is\n    available in the corresponding Sandbox about this result that can give\n    more context.\n    \n    Attributes:\n        value (any): The actual data stored in this class that we are proxying.\n            If the underlying proxy object has a field called `value`, then\n            you can use either `_actual_value` to access the proxied object.\n        _actual_call_id (int): The call that was used to generate this result.\n        _actual_sandbox (Sandbox): The sandbox that was used to generate this\n            result. If None, then the sandbox was lost.\n    \n    \"\"\"\n    ASSIGNABLE_ATTRS = ['value', '_actual_call_id', '_actual_sandbox',\n                        '_clone_this_result']\n\n    def __init__(self, value, call_id=None, sandbox=None):\n        \"\"\"\n        Args:\n            value (any): Literally any type of data.\n            call_id (int): The unique call ID that generated this result. If\n                None, then the SandboxResult was generated by manipulating an earlier\n                result.\n                TODO: We could actually remember the operations applied to this\n                instance and use them to reconstruct the transformations...\n            sandbox (Sandbox): The sandbox that was used to generate this\n                result. If None, then the sandbox was lost.\n        \"\"\"\n        self.value = value\n        self._actual_call_id = call_id\n        self._actual_sandbox = sandbox\n\n    def __getattribute__(self, name):\n        \"\"\"\n        Get the attribute with the given `name`. This allows us to pass\n        most attributes along to the underlying `value`, while still\n        maintaining access to the proxy's attributes.\n        \"\"\"\n        v = object.__getattribute__(self, \"value\")\n        if name == \"__class__\":\n            return v.__class__\n        elif name == \"__actual_class__\":\n            return object.__getattribute__(self, \"__class__\")\n        elif name == \"_actual_value\":\n            return v\n        elif name in SandboxResult.ASSIGNABLE_ATTRS:\n            return object.__getattribute__(self, name)\n        elif name == \"value\" and not hasattr(v, \"value\"):\n            return v\n        else:\n            return SandboxResult(object.__getattribute__(v, name),\n                                 object.__getattribute__(self, \"_actual_call_id\"),\n                                 object.__getattribute__(self, \"_actual_sandbox\"))\n\n    def __setattr__(self, name, value):\n        if name in SandboxResult.ASSIGNABLE_ATTRS:\n            object.__setattr__(self, name, value)\n        else:\n            setattr(self.value, name, value)\n\n    def __delattr__(self, name):\n        if name in SandboxResult.ASSIGNABLE_ATTRS:\n            object.__delattr__(self, name, value)\n        else:\n            delattr(self.value, name, value)\n\n    def _clone_this_result(self, new_value):\n        \"\"\"\n        Create a new SandboxResult based on this current one. Copies over the\n        `call_id` and `sandbox`.\n        \n        Args:\n            new_value (any): The new value to be proxying.\n        Returns:\n            SandboxResult\n        \"\"\"\n        return SandboxResult(new_value,\n                             call_id=self._actual_call_id,\n                             sandbox=self._actual_sandbox)\n\n    def __repr__(self):\n        \"\"\"\n        Returns the representation of the proxied object.\n        \n        Returns:\n            str: The `repr` of the proxied object.\n        \"\"\"\n        return repr(self.value)\n\n    def __str__(self):\n        \"\"\"\n        Returns the string representation of the proxied object.\n        \n        Returns:\n            str: The `str` of the proxied object.\n        \"\"\"\n        return str(self.value)\n\n    def __bytes__(self):\n        return bytes(self.value)\n\n    def __format__(self, format_spec):\n        return format(self.value, format_spec)\n\n    def __call__(self, *args):\n        \"\"\"\n        Returns the result of calling the proxied object with the args.\n        \n        Returns:\n            SandboxResult: A proxy of the Sandbox object.\n        \"\"\"\n        return self._clone_this_result(self.value(*args))\n\n    def __hash__(self):\n        return hash(self.value)\n\n    def __bool__(self):\n        return bool(self.value)\n\n    def __dir__(self):\n        return dir(self.value)\n\n    def __instancecheck__(self, instance):\n        return isinstance(self.value, instance)\n\n    def __subclasscheck__(self, subclass):\n        return issubclass(self.value, subclass)\n\n    def __len__(self):\n        return self._clone_this_result(len(self.value))\n\n    def __getitem__(self, key):\n        return self._clone_this_result(self.value[key])\n\n    def __setitem__(self, key, value):\n        self.value[key] = value\n\n    def __delitem__(self, key):\n        del self.value[key]\n\n    def __missing__(self, key):\n        return self.value.__missing__(key)\n\n    def __iter__(self):\n        return iter(self.value)\n\n    def __reversed__(self):\n        return reversed(self.value)\n\n    def __contains__(self, item):\n        return self.value.__contains__(item)\n\n    def __eq__(self, other):\n        \"\"\"\n        Test if the proxied object is equal to the given `other`.\n        \n        Args:\n            other (any): The other object.\n        \n        Returns:\n            bool or any: Returns whatever the proxy object's __eq__ returns.\n        \"\"\"\n        if isinstance(other, SandboxResult):\n            return self.value == other.value\n        return self.value == other\n\n    def __lt__(self, other):\n        if isinstance(other, SandboxResult):\n            return self.value < other.value\n        return self.value < other\n\n    def __le__(self, other):\n        if isinstance(other, SandboxResult):\n            return self.value <= other.value\n        return self.value <= other\n\n    def __gt__(self, other):\n        if isinstance(other, SandboxResult):\n            return self.value > other.value\n        return self.value > other\n\n    def __ge__(self, other):\n        if isinstance(other, SandboxResult):\n            return self.value >= other.value\n        return self.value >= other\n\n    def __ne__(self, other):\n        if isinstance(other, SandboxResult):\n            return self.value != other.value\n        return self.value != other\n\n    ## Numeric Operations\n\n    def __add__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value + other.value)\n        return self._clone_this_result(self.value + other)\n\n    def __sub__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value - other.value)\n        return self._clone_this_result(self.value - other)\n\n    def __mul__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value * other.value)\n        return self._clone_this_result(self.value * other)\n\n    def __matmul__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value.__matmul__(other.value))\n        return self._clone_this_result(self.value.__matmul__(other))\n\n    def __truediv__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value.__truediv__(other.value))\n        return self._clone_this_result(self.value.__truediv__(other))\n\n    def __floordiv__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value.__floordiv__(other.value))\n        return self._clone_this_result(self.value.__floordiv__(other))\n\n    def __mod__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value.__mod__(other.value))\n        return self._clone_this_result(self.value.__mod__(other))\n\n    def __divmod__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value.__divmod__(other.value))\n        return self._clone_this_result(self.value.__divmod__(other))\n\n    def __pow__(self, other, *modulo):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value.__pow__(other.value, *modulo))\n        return self._clone_this_result(self.value.__pow__(other, *modulo))\n\n    def __lshift__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value.__lshift__(other.value))\n        return self._clone_this_result(self.value.__lshift__(other))\n\n    def __rshift__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value.__rshift__(other.value))\n        return self._clone_this_result(self.value.__rshift__(other))\n\n    def __and__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value.__and__(other.value))\n        return self._clone_this_result(self.value.__and__(other))\n\n    def __xor__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value.__xor__(other.value))\n        return self._clone_this_result(self.value.__xor__(other))\n\n    def __or__(self, other):\n        if isinstance(other, SandboxResult):\n            return self._clone_this_result(self.value.__or__(other.value))\n        return self._clone_this_result(self.value.__or__(other))\n\n    def __radd__(self, other):\n        return self._clone_this_result(self.value.__radd__(other))\n\n    def __rsub__(self, other):\n        return self._clone_this_result(self.value.__rsub__(other))\n\n    def __rmul__(self, other):\n        return self._clone_this_result(self.value.__rmul__(other))\n\n    def __rmatmul__(self, other):\n        return self._clone_this_result(self.value.__rmatmul__(other))\n\n    def __rtruediv__(self, other):\n        return self._clone_this_result(self.value.__rtruediv__(other))\n\n    def __rfloordiv__(self, other):\n        return self._clone_this_result(self.value.__rfloordiv__(other))\n\n    def __rmod__(self, other):\n        return self._clone_this_result(self.value.__rmod__(other))\n\n    def __rdivmod__(self, other):\n        return self._clone_this_result(self.value.__rdivmod__(other))\n\n    def __rpow__(self, other):\n        return self._clone_this_result(self.value.__rpow__(other))\n\n    def __rlshift__(self, other):\n        return self._clone_this_result(self.value.__rlshift__(other))\n\n    def __rand__(self, other):\n        return self._clone_this_result(self.value.__rand__(other))\n\n    def __rxor__(self, other):\n        return self._clone_this_result(self.value.__rxor__(other))\n\n    def __ror__(self, other):\n        return self._clone_this_result(self.value.__ror__(other))\n\n    ## TODO: __iadd__ and other in-place assignment operators?\n\n    def __neg__(self):\n        return self._clone_this_result(self.value.__neg__())\n\n    def __pos__(self):\n        return self._clone_this_result(self.value.__pos__())\n\n    def __abs__(self):\n        return self._clone_this_result(self.value.__abs__())\n\n    def __invert__(self):\n        return self._clone_this_result(self.value.__invert__())\n\n    def __complex__(self):\n        return self._clone_this_result(self.value.__complex__())\n\n    def __int__(self):\n        return self._clone_this_result(self.value.__int__())\n\n    def __float__(self):\n        return self._clone_this_result(self.value.__float__())\n\n    def __round__(self, *ndigits):\n        return self._clone_this_result(self.value.__round__(*ndigits))\n\n    def __trunc__(self):\n        return self._clone_this_result(self.value.__trunc__())\n\n    def __floor__(self):\n        return self._clone_this_result(self.value.__floor__())\n\n    def __ceil__(self):\n        return self._clone_this_result(self.value.__ceil__())\n\n    def __enter__(self):\n        return self.value.__enter__()\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        return self.value.__exit__(exc_type, exc_value, traceback)\n\n    def __await__(self):\n        return self.value.__await__()\n\n    def __aiter__(self):\n        return self.value.__aiter__()\n\n    def __anext__(self):\n        return self.value.__anext__()\n\n    def __aenter__(self):\n        return self.value.__aenter__()\n\n    def __aexit__(self, exc_type, exc_value, traceback):\n        return self.value.__aexit__(exc_type, exc_value, traceback)\n", "src/lib/pedal/sandbox/sandbox.py": "from pprint import pprint\nimport ast\nimport re\nimport sys\nimport io\nimport os\nimport string\nfrom unittest.mock import patch, mock_open, MagicMock\n\nfrom pedal.report import MAIN_REPORT\nfrom pedal.sandbox import mocked\nfrom pedal.sandbox.exceptions import (SandboxTraceback, SandboxHasNoFunction,\n                                      SandboxHasNoVariable, _add_context_to_error)\nfrom pedal.sandbox.timeout import timeout\nfrom pedal.sandbox.messages import EXTENDED_ERROR_EXPLANATION\nfrom pedal.sandbox.result import SandboxResult\nfrom pedal.sandbox.tracer import (SandboxCallTracer, SandboxCoverageTracer,\n                                  SandboxBasicTracer)\n\n\ndef _dict_extends(d1, d2):\n    \"\"\"\n    Helper function to create a new dictionary with the contents of the two\n    given dictionaries. Does not modify either dictionary, and the values are\n    copied shallowly. If there are repeats, the second dictionary wins ties.\n\n    The function is written to ensure Skulpt compatibility.\n\n    Args:\n        d1 (dict): The first dictionary\n        d2 (dict): The second dictionary\n    Returns:\n        dict: The new dictionary\n    \"\"\"\n    d3 = {}\n    for key, value in d1.items():\n        d3[key] = value\n    for key, value in d2.items():\n        d3[key] = value\n    return d3\n\n\nclass SandboxVariable:\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n\n\nclass DataSandbox:\n    \"\"\"\n    Simplistic Mixin class that contains the functions for accessing a\n    self-contained student data namespace.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.data = {}\n\n    def get_names_by_type(self, type, exclude_builtins=True):\n        result = []\n        for name, value in self.data.items():\n            if isinstance(value, type):\n                if exclude_builtins and name.startswith('__'):\n                    continue\n                result.append(name)\n        return result\n\n    def get_values_by_type(self, type, exclude_builtins=True):\n        names = self.get_names_by_type(type, exclude_builtins)\n        return [self.data[name] for name in names]\n\n    def get_variables_by_type(self, type, exclude_builtins=True):\n        names = self.get_names_by_type(type, exclude_builtins)\n        return [(name, self.data[name]) for name in names]\n\n    @property\n    def functions(self):\n        \"\"\"\n        Retrieve a list of all the callable names in the students' namespace.\n        In other words, get a list of all the functions the student defined.\n\n        Returns:\n            list of callables\n        \"\"\"\n        return {k: v for k, v in self.data.items() if callable(v)}\n\n    @property\n    def var(self):\n        return {k: SandboxVariable(k, v) for k, v in self.data.items()}\n\n\nclass Sandbox(DataSandbox):\n    \"\"\"\n\n    The Sandbox is a container that can safely execute student code and store\n    the result.\n\n    Attributes:\n        data: The namespace produced by the students' code. This is basically\n            a dictionary mapping valid python names to their values.\n        raw_output (str): The exact literal results of all the `print` calls\n            made so far, including the \"\\n\" characters.\n        output (list of str): The current lines of output, broken up by\n            distinct print calls (not \"\\n\" characters). Note that this will\n            not have any \"\\n\" characters unless you explicitly printed them.\n        output_contexts (dict[str:list[str]]): The output for each call context.\n        call_id (int): The current call_id of the most recent call. Is\n            initially 0, indicating the original sandbox creation.\n        modules: A dictionary of the mocked modules (accessible by their\n            imported names).\n        context: A list of strings representing the code previously run through\n            this sandbox via .call.\n        contextualize (bool): Whether or not to contextualize stack frames.\n    \"\"\"\n\n    CONTEXT_MESSAGE = (\n        \"\\n\\nThe error above occurred when I ran:<br>\\n<pre>{context}</pre>\"\n    )\n    TRACER_STYLES = {\n        'coverage': SandboxCoverageTracer,\n        'calls': SandboxCallTracer,\n        'none': SandboxBasicTracer,\n    }\n\n    def __init__(self, initial_data=None,\n                 initial_raw_output=None,\n                 initial_exception=None,\n                 modules=None, full_traceback=False,\n                 tracer_style='none',\n                 threaded=False, report=None,\n                 context=None, result_proxy=SandboxResult,\n                 instructor_filename=\"instructor_tests.py\",\n                 allowed_functions=None):\n        \"\"\"\n        Args:\n            initial_data (dict[str:Any]): An initial namespace to provide when\n                executing the students' code. The keys must be strings and\n                should be valid Python names. Defaults to None, which will be\n                an empty namespace.\n            initial_exception (Exception): An initial exception to load into\n                the Sandbox. Usually you will let the students' code generate\n                its own exceptions, but if you're constructing a sandbox you\n                might need to specify one. Defaults to None.\n            modules: A dictionary of strings (valid python package names) that\n                map to either the value True (if we provide a default\n                implementation) or a user-created MockedModule. By default,\n                we mock out the following modules:\n                * matplotlib\n                * pedal\n            context (False, None, or list[str]): How to contextualize calls by\n                default in this Sandbox. False means no contextualization.\n                None (default) means contextualize automatically. If you give\n                a list[str], then it assumes you want to contextualize\n                automatically but starting off with the given strings.\n            initial_raw_output (str): The initial printed output for the\n                sandbox. Usually defaults to None to indicate a blank printed\n                area.\n            instructor_filename (str): The filename to display in tracebacks,\n                when executing student code in instructor tests. Although you\n                can specify something else, defaults to \"instructor_tests.py\".\n        \"\"\"\n        super().__init__()\n        if initial_data is None:\n            initial_data = {}\n        self.data = initial_data\n\n        # Context\n        self.call_id = 0\n        self.target_contexts = {self.call_id: []}\n        self.call_contexts = {self.call_id: []}\n        self.input_contexts = {self.call_id: []}\n        self.context = context\n        # Update outputs\n        self.set_output(initial_raw_output)\n        # filename\n        self.instructor_filename = instructor_filename\n        # Temporary data\n        self._temporaries = set()\n        self._backups = {}\n        # Exception\n        self.exception = initial_exception\n        self.exception_position = None\n        self.exception_formatted = None\n        self.report_exceptions_mode = False\n        # Input\n        self.inputs = None\n        # Modules\n        if modules is None:\n            modules = {'matplotlib': True,\n                       'pedal': mocked.MockPedal()}\n        self.mocked_modules = {}\n        self.modules = {}\n        self.add_mocks(modules)\n        self.mocked_functions = {\n            'compile': mocked._disabled_compile,\n            'eval': mocked._disabled_eval,\n            'exec': mocked._disabled_exec,\n            'globals': mocked._disabled_globals,\n            'open': mocked._restricted_open\n        }\n        if allowed_functions is not None:\n            for function_name in allowed_functions:\n                if function_name in self.mocked_functions:\n                    del self.mocked_functions[function_name]\n        # Patching\n        self._current_patches = []\n        # Settings\n        self.full_traceback = full_traceback\n        self.MAXIMUM_VALUE_LENGTH = 120\n        # Tracer Styles\n        self.tracer_style = tracer_style\n        # Proxying results\n        self.result_proxy = result_proxy\n        # report\n        if report is None:\n            report = MAIN_REPORT\n        self.report = report\n        # Threading\n        self.threaded = threaded\n        self.allowed_time = 1\n\n    def _set_tracer_style(self, tracer_style):\n        self._tracer_style = tracer_style.lower()\n        self.trace = self.TRACER_STYLES[tracer_style.lower()]()\n\n    def _get_tracer_style(self):\n        return self._tracer_style\n\n    tracer_style = property(_get_tracer_style, _set_tracer_style)\n\n    def add_mocks(self, modules):\n        \"\"\"\n        :param modules: Keyword listing of modules and their contents\n                        (MockedModules) or True (if its one that we have a\n                        default implementation for).\n        :type modules: dict\n        \"\"\"\n        for module_name, module_data in modules.items():\n            self._add_mock(module_name, module_data)\n\n    def _add_mock(self, module_name, module_data):\n        # MatPlotLib's PyPlot\n        if module_name == 'matplotlib':\n            matplotlib, modules = mocked.create_module('matplotlib.pyplot')\n            self.mocked_modules.update(modules)\n            if module_data is True:\n                mock_plt = mocked.MockPlt()\n                mock_plt._add_to_module(matplotlib.pyplot)\n                self.modules['matplotlib.pyplot'] = mock_plt\n            else:\n                module_data._add_to_module(matplotlib.pyplot)\n        else:\n            root, modules = mocked.create_module(module_name)\n            self.mocked_modules.update(modules)\n            self.modules[module_name] = module_data\n            module_data._add_to_module(root)\n\n    def set_output(self, raw_output):\n        \"\"\"\n        Change the current printed output for the sandbox to the given value.\n        If None is given, then clears all the given output (empty list for\n        `output` and empty string for `raw_output`).\n\n        Args:\n            raw_output (str): The new raw_output for the sandbox. To compute\n                the `output` attribute, the system splits and rstrips at\n                newlines.\n        \"\"\"\n        if raw_output is None:\n            self.raw_output = \"\"\n            self.output = []\n            self.output_contexts = {self.call_id: list(self.output)}\n        else:\n            self.raw_output = raw_output\n            lines = raw_output.rstrip().split(\"\\n\")\n            self.output = [line.rstrip() for line in lines]\n            self.output_contexts[self.call_id] = list(self.output)\n\n    def append_output(self, raw_output):\n        \"\"\"\n        Adds the string of `raw_output` to the current `raw_output` attribute.\n        The added string will be split on newlines and rstripped to append\n        to the `output` attribute.\n\n        Args:\n            raw_output (str): The new raw_output for the sandbox. To compute\n                the `output` attribute, the system splits and rstrips at\n                newlines.\n        \"\"\"\n        self.raw_output += raw_output\n        lines = raw_output.rstrip().split(\"\\n\")\n        lines = [line.rstrip() for line in lines]\n        if self.raw_output:\n            self.output.extend(lines)\n            self.output_contexts[self.call_id].extend(lines)\n\n    def set_input(self, inputs):\n        \"\"\"\n        Queues the given value as the next arguments to the `input` function.\n        \"\"\"\n        if isinstance(inputs, tuple):\n            self.inputs = mocked._make_inputs(*inputs)\n        else:\n            self.inputs = inputs\n\n    def _track_inputs(self, inputs):\n        \"\"\"\n        Wraps an input function with a tracker.\n        \"\"\"\n\n        def _input_tracker(*args, **kwargs):\n            value_entered = inputs(*args, **kwargs)\n            self.input_contexts[self.call_id].append(value_entered)\n            return value_entered\n\n        return _input_tracker\n\n    def _purge_temporaries(self):\n        \"\"\"\n        Delete any variables in the namespace that have been made as\n        temporaries. This happens automatically after you execute code.\n        \"\"\"\n        for key in self._temporaries:\n            if key in self._backups:\n                self.data[key] = self.backups[key]\n            else:\n                del self.data[key]\n        self._temporaries = set()\n\n    def _is_long_value(self, value):\n        return len(repr(value)) > 25\n\n    def _make_temporary(self, category, name, value, context):\n        \"\"\"\n        Create a temporary variable in the namespace for the given\n        category/name. This is used to load arguments into the namespace to\n        be used in function calls. Temporaries are only created if the value's\n        repr length is too long, as defined by _is_long_value.\n\n        Args:\n            category (str): A categorical division for the temporary variable\n                that can help keep the namespace distinctive - there are a\n                few different kinds of categories (e.g., for regular positional\n                args, star args, kwargs).\n            name (str): A distinctive ID for this variable. The final variable\n                name will be \"_temporary_<category>_<name>\".\n            value: The value for this argument.\n        Returns:\n            str: The new name for the temporary variable.\n        \"\"\"\n        if isinstance(value, SandboxVariable):\n            return value.name\n        if not self._is_long_value(value):\n            return repr(value)\n        key = '_temporary_{}_{}'.format(category, name)\n        if key in self.data:\n            self._backups[key] = self.data[key]\n        self._temporaries.add(key)\n        self.data[key] = value\n        if context is None:\n            self.call_contexts[self.call_id].append(\"{} = {}\".format(key, value))\n        return key\n\n    def run_file(filename, as_filename=None, modules=None, inputs=None,\n                 threaded=None, context=None, report_exceptions=None):\n        \"\"\"\n        Load the given filename and execute it within the current namespace.\n        \n        Args:\n            context (False, None, or list[str]): The context to give any\n                exceptions. If None, then the recorded context will be used. If\n                a string, tracebacks will be shown with the given context. If\n                False, no context will be given.\n        \"\"\"\n        if _as_filename is None:\n            _as_filename = filename\n        with open(filename, 'r') as code_file:\n            code = code_file.read() + '\\n'\n        self.run(code, as_filename, modules, inputs, threaded,\n                 context, report_exceptions)\n\n    def list(self, *args):\n        pass\n\n    def call(self, function, *args, **kwargs):\n        \"\"\"\n        Args:\n            function (str): The name of the function to call that was defined\n                by the user.\n            as_filename (str): The filename to use when calling this function.\n                Defaults to the instructor filename, since you are calling\n                code on the student's behalf.\n            target (str): The new variable in the namespace to assign to. By\n                default this will be \"_\". If you use None, then no variable\n                will be assigned to. Note that this could overwrite a variable\n                in the user namespace.\n                TODO: Add a feature to prevent user namespace overwriting.\n            input (list of str): The strings to send in to calls to input.\n                You can also pass in a generator to construct strings\n                dynamically.\n            threaded (bool): Whether or not the function execution should be\n                executed in a separate thread. Defaults to True. This prevents\n                timeouts from occuring in the students' code (a TimeOutError\n                will be thrown after 3 seconds).\n            context (False, None, or list[str]): The context to give any\n                exceptions. If None, then the recorded context will be used. If\n                a string, tracebacks will be shown with the given context. If\n                False, no context will be given.\n        Returns:\n            If the call was successful, returns the result of executing the\n            code. Otherwise, it will return an Exception relevant to the\n            failure (might be a SandboxException, might be a user-space\n            exception).\n        \"\"\"\n        # Confirm that the function_name exists\n        if function not in self.functions:\n            if function not in self.data:\n                self.exception = SandboxHasNoVariable(\n                    \"The function {function} does not exist.\".format(function=function)\n                )\n            else:\n                self.exception = SandboxHasNoFunction(\n                    \"The variable {function} is not a function.\".format(function=function)\n                )\n            return self.exception\n        # Parse kwargs for any special arguments.\n        as_filename = kwargs.pop('as_filename', self.instructor_filename)\n        target = kwargs.pop('target', '_')\n        modules = kwargs.pop('modules', {})\n        inputs = kwargs.pop('inputs', self.inputs)\n        threaded = kwargs.pop('threaded', self.threaded)\n        context = kwargs.pop('context', self.context)\n        report_exceptions = kwargs.pop('report_exceptions', self.report_exceptions_mode)\n        # Create the actual arguments and call\n        self.call_id += 1\n        self.target_contexts[self.call_id] = target\n        self.output_contexts[self.call_id] = []\n        self.call_contexts[self.call_id] = []\n        self.input_contexts[self.call_id] = []\n        actual, student = self._construct_call(function, args, kwargs, target,\n                                               context)\n        if context is None:\n            context = student\n        # if context is None:\n        # self.call_contexts[self.call_id].append(student_call)\n        # if context is not False:\n        #    self.call_contexts[self.call_id] = context\n        self.run(actual, as_filename, modules, inputs,\n                 threaded=threaded, context=context,\n                 report_exceptions=report_exceptions)\n        self._purge_temporaries()\n        if self.exception is None:\n            self._ = self.data[target]\n            if self.result_proxy is not None:\n                self._ = self.result_proxy(self._, call_id=self.call_id,\n                                           sandbox=self)\n            return self._\n        else:\n            # TODO: Might need to wrap this in case the student was supposed\n            # to return an exception - weird circumstance though\n            return self.exception\n\n    def make_safe_variable(self, name):\n        \"\"\"\n        Tries to construct a safe variable name in the current namespace, based\n        off the given one. This is accomplished by appending a \"_\" and a number\n        of increasing value until no comparable name exists in the namespace.\n        This is particularly useful when you want to create a variable name to\n        assign to, but you are concerned that the user might have a variable\n        with that name already, which their code relies on.\n        \n        Args:\n            name (str): A desired target name.\n        Returns:\n            str: A safe target name, based off the given one.\n        \"\"\"\n        current_addition = \"\"\n        attempt_index = 2\n        while name + current_addition in self.data:\n            current_addition = \"_{}\".format(attempt_index)\n            attempt_index += 1\n        return name + current_addition\n\n    def _construct_call(self, function, args, kwargs, target, context):\n        str_args = [self._make_temporary('arg', index, value, context)\n                    for index, value in enumerate(args)]\n        str_kwargs = [\"{}={}\".format(key,\n                                     self._make_temporary('kwarg', key, value, context))\n                      for key, value in kwargs.items()]\n        arguments = \", \".join(str_args + str_kwargs)\n        call = \"{}({})\".format(function, arguments)\n        if target is None:\n            actual = call\n        else:\n            actual = \"{} = {}\".format(target, call)\n        student_call = call if target is \"_\" else actual\n        return actual, student_call\n\n    def _start_patches(self, *patches):\n        self._current_patches.append(patches)\n        for patch in patches:\n            patch.start()\n\n    def _stop_patches(self):\n        patches = self._current_patches.pop()\n        for patch in patches:\n            patch.stop()\n\n    def _capture_exception(self, exception, exc_info, report_exceptions,\n                           context):\n        self.exception = exception\n        if context is not False:\n            if context is None:\n                contexts = [call\n                            for calls in self.call_contexts.values()\n                            for call in calls]\n                context = '\\n'.join(contexts[1:])\n            context = self.CONTEXT_MESSAGE.format(context=context)\n            self.exception = _add_context_to_error(self.exception, context)\n        line_offset = self.report['source'].get('line_offset', 0)\n        student_filename = self.report['source']['filename']\n        traceback = SandboxTraceback(self.exception, exc_info,\n                                     self.full_traceback,\n                                     self.instructor_filename,\n                                     line_offset, student_filename,\n                                     self.report['source']['lines'])\n        self.exception_position = {'line': traceback.line_number}\n        self.exception_formatted = traceback.format_exception()\n        self.exception_name = str(self.exception.__class__)[8:-2]\n        # Do we add the exception to the report?\n        if report_exceptions is False:\n            return True\n        if report_exceptions is None and not self.report_exceptions_mode:\n            return True\n        self.report.attach(self.exception_name,\n                           group=self.report.group,\n                           category='Runtime', tool='Sandbox',\n                           mistake={'message': self.exception_formatted,\n                                    'error': self.exception})\n        return False\n\n    def run(self, code, as_filename=None, modules=None, inputs=None,\n            threaded=None, report_exceptions=True, context=False):\n        \"\"\"\n        Execute the given string of code in this sandbox.\n        \n        Args:\n            code (str): The string of code to be executed.\n            as_filename (str): The filename to use when executing the code -\n                this is cosmetic, technically speaking, it has no relation\n                to anything on disk. It will be present in tracebacks.\n                Defaults to Source's filename.\n            modules (dict[str:Module]): Modules to mock.\n            inputs (list[str]): The inputs to give from STDIN, as a list of\n                strings. You can also give a function that emulates the\n                input function; e.g., consuming a prompt (str) and producing\n                strings. This could be used to make a more interactive input\n                system.\n            context (str): The context to give any exceptions.\n                If None, then the recorded context will be used. If a string,\n                tracebacks will be shown with the given context. If False,\n                no context will be given (the default).\n            threaded (bool): whether or not to run this code in a separate\n                thread. Defaults to :attribute:`Sandbox.threaded`.\n            report_exceptions (bool): Whether or not to capture exceptions.\n        \"\"\"\n        # Handle any threading if necessary\n        if threaded is None:\n            threaded = self.threaded\n        if threaded:\n            try:\n                return timeout(self.allowed_time, self.run, code, as_filename,\n                               modules, inputs, False,\n                               report_exceptions, context)\n            except TimeoutError as timeout_exception:\n                self._capture_exception(timeout_exception, sys.exc_info(),\n                                        report_exceptions)\n                return self\n        if as_filename is None:\n            as_filename = os.path.basename(self.report['source']['filename'])\n        if inputs is None:\n            if self.inputs is None:\n                inputs = mocked._make_inputs('0', repeat='0')\n            else:\n                inputs = self.inputs\n        if isinstance(inputs, (tuple, list)):\n            inputs = mocked._make_inputs(*inputs)\n        elif isinstance(inputs, str):\n            inputs = mocked._make_inputs(inputs)\n        inputs = self._track_inputs(inputs)\n        # Override builtins and mock stuff out\n        mocked_functions = self.mocked_functions.copy()\n        mocked_functions['input'] = inputs\n        mocked_functions['raw_input'] = inputs\n        mocked_functions['sys'] = sys\n        mocked_functions['os'] = os\n        mocked._override_builtins(self.data, mocked_functions)\n        \n\n        self.exception = None\n        self.exception_position = None\n        self.exception_formatted = None\n\n        # Patch in dangerous built-ins\n        capture_stdout = io.StringIO()\n        self._start_patches(\n            patch('sys.stdout', capture_stdout),\n            patch('time.sleep', return_value=None),\n            patch.dict('sys.modules', self.mocked_modules)\n        )\n        # Compile and run student code\n        try:\n            compiled_code = compile(code, as_filename, 'exec')\n            with self.trace._as_filename(as_filename, code):\n                exec(compiled_code, self.data)\n        except Exception as user_exception:\n            self._capture_exception(user_exception, sys.exc_info(),\n                                    report_exceptions, context)\n        finally:\n            self._stop_patches()\n            self.append_output(capture_stdout.getvalue())\n        if context is None:\n            self.call_contexts[self.call_id].append(code)\n        elif isinstance(context, str):\n            self.call_contexts[self.call_id].append(context)\n        elif context is not False:\n            self.call_contexts[self.call_id] = context\n        return self\n\n\ndef run(initial_data=None, initial_raw_output=None, initial_exception=None,\n        allowed_functions=None,\n        modules=None, inputs=None, report_exceptions=True, context=None,\n        full_traceback=False, tracer_style='none', threaded=False,\n        result_proxy=SandboxResult,\n        instructor_filename=\"instructor_tests.py\",\n        code=None, as_filename=None, report=None):\n    if report is None:\n        report = MAIN_REPORT\n    if 'run' not in report['sandbox']:\n        report['sandbox']['settings'] = [\n            initial_data, initial_raw_output, initial_exception, modules,\n            full_traceback, tracer_style, threaded, report, context,\n            result_proxy, instructor_filename, allowed_functions\n        ]\n        report['sandbox']['run'] = Sandbox(*report['sandbox']['settings'])\n\n    sandbox = report['sandbox']['run']\n    if code is None:\n        code = report['source']['code']\n    sandbox.run(code, as_filename, modules, inputs, threaded,\n                report_exceptions, context)\n    return sandbox\n\n\ndef reset(report=None):\n    if report is None:\n        report = MAIN_REPORT\n    if 'settings' in report['sandbox']:\n        report['sandbox']['run'] = Sandbox(*report['sandbox']['settings'])\n    else:\n        run(report=report)\n", "src/lib/pedal/sandbox/messages.py": "# Skulpt has weird errors, and is missing some errors. Compatibility.\ntry:\n    ParseError\nexcept NameError:\n    class ParseError(Exception):\n        pass\ntry:\n    SyntaxError\nexcept NameError:\n    class SyntaxError(Exception):\n        pass\ntry:\n    ReferenceError\nexcept NameError:\n    class ReferenceError(Exception):\n        pass\ntry:\n    EOFError\nexcept NameError:\n    class EOFError(Exception):\n        pass\ntry:\n    MemoryError\nexcept NameError:\n    class MemoryError(Exception):\n        pass\ntry:\n    OSError\nexcept NameError:\n    class OSError(Exception):\n        pass\ntry:\n    TokenError\nexcept NameError:\n    class TokenError(Exception):\n        pass\ntry:\n    TimeLimitError\nexcept NameError:\n    class TimeLimitError(Exception):\n        pass\n\nEXTENDED_ERROR_EXPLANATION = {\n    ParseError: \"A parse error means that Python does not understand the syntax on the line the error message points out. Common examples are forgetting commas beteween arguments or forgetting a <code>:</code> (colon) on a for statement.<br><b>Suggestion:</b> To fix a parse error you just need to look carefully at the line with the error and possibly the line before it.  Make sure it conforms to all of Python's rules.\",\n    TypeError: \"Type errors most often occur when an expression tries to combine two objects with types that should not be combined. Like using <code>+</code> to add a number to a list instead of <code>.append</code>, or dividing a string by a number.<br><b>Suggestion:</b> To fix a type error you will most likely need to trace through your code and make sure the variables have the types you expect them to have.\",\n    SyntaxError: \"This message indicates that Python can't figure out the syntax of a particular statement.  Some examples are assigning to a literal, or a function call.      <br><b>Suggestion: </b>Check your assignment statements and make sure that the left hand side of the assignment is a variable, not a literal (e.g., 7 or \\\"hello\\\") or a function.\",\n    NameError: \"A name error almost always means that you have used a variable before it has a value.  Often this may be a simple typo, so check the spelling carefully.  <br><b>Suggestion: </b>Check the right hand side of assignment statements and your function calls, this is the most likely place for a NameError to be found. It really helps to step through your code, one line at a time, mentally keeping track of your variables.\",\n    ValueError: \"A ValueError most often occurs when you pass a parameter to a built-in function, and the function is expecting one type and you pass something  different. For instance, if you try to convert a non-numeric string to an int, you will get a ValueError:<br><pre>  int(\\\"Corgi\\\") # ValueError: invalid literal for int() with base 10</pre> <br><b>Suggestion: </b>The error message gives you a pretty good hint about the name of the function as well as the value that is incorrect.  Look at the error message closely and then trace back to the variable containing the problematic value. }\",\n    AttributeError: \"This happens when you try to do <code>SOMETHING.WHATEVER</code> and either SOMETHING wasn't declared or WHATEVER isn't an attribute of SOMETHING. This error message is telling you that the object on the left hand side of the dot, does not have the attribute or method on the right hand side.      <br><b>Suggestion: </b>You were probably trying to either get access to some data (weather.get) or append (a_list.append). If it's the first one, you should make sure the module is imported and that you are called its function correctly. If it's the second one, you should make sure you spelled \\\"append\\\" right and that you are using a variable with a list for a value.\",\n    TokenError: \"Most of the time this error indicates that you have forgotten a right parenthesis or have forgotten to close a pair of quotes.  <br><b>Suggestion: </b>Check each line of your program and make sure that your parenthesis are balanced.\",\n    IndexError: \"This message means that you are trying to index past the end of a string or a list.  For example, if your list has 3 things in it and you try to access the item at position 5.  <br><b>Suggestion: </b>Remember that the first item in a list or string is at index position 0, quite often this message comes about because you are off by one.  Remember in a list of length 3 the last legal index is 2.<br><pre>favorite_colors = [\\\"red\\\", \\\"blue\\\", \\\"green\\\"]\\nfavorite_colors[2] # prints green favorite_color[3] # raises an IndexError</pre>\",\n    ImportError: \"This error message indicates that you are trying to import a module that does not exist, or is not in the same directory as your python script.  <br><b>Suggestion: </b>One problem may simply be that you have a typo - remember, you must not capitalize the module name. Another common problem is that you have placed the module in a different directory. Finally, if you're using a dataset module, then it might not be imported. Use the \\\"Import Datasets\\\" button below!\",\n    ReferenceError: \"This is a really hard error to get, so I'm not entirely sure what you did.  <br><b>Suggestion: </b>Bring this code to the instructor. \",\n    ZeroDivisionError: \"This tells you that you are trying to divide by 0. Typically this is because the value of the variable in the denominator of a division expression has the value 0.  <br><b>Suggestion: </b>Are you sure you are dividing by the right variable? Are you sure that that variable has the value you expect - is it possible that you counted the number of elements in an empty list, for instance?\",\n    IndentationError: \"This error occurs when you have not indented your code properly.  This is most likely to happen as part of an if, for, while or def statement.  <br><b>Suggestion: </b>Check your if, def, for, and while statements to be sure the lines are properly indented beneath them (seriously, this happens ALL the time).  Another source of this error comes from copying and pasting code where you have accidentally left some bits of code lying around that don't belong there anymore. Finally, a very sinister but unlikely possibility is that you have some tab characters in your code, which look identical to four spaces. Never, ever use tabs, and carefully check code from the internet to make sure it doesn't have tabs.\",\n    EOFError: \"If you are using input() or raw_input() commands, then this error happens when they don't get the right ending.  <br><b>Suggestion: </b>It's hard to protect against users. However, if you're using input(), you might be able to use raw_input() instead to avoid this problem. \",\n    IOError: \"This is a very easy error to get. The most common reason is that you were trying to open a file and it wasn't in the right place.   <br><b>Suggestion: </b>Make sure that the file is in the right place - print out the file path, and then check that it's definitely on your computer at that location. If you need help doing file processing, you should probably check with an instructor.\",\n    KeyError: \"A dictionary has a bunch of keys that you can use to get data. This error is caused by you trying to refer to a key that does not exist.  <br><b>Suggestion: </b>The most common reason you get this exception is that you have a typo in your dictionary access. Check your spelling. Also double check that the key definitely exists.\",\n    MemoryError: \"Somehow, you have run out of memory. <br><b>Suggestion: </b>Make sure you are filtering your dataset! Alternatively, bring your code to an instructor.\",\n    OSError: \"It's hard to say what an OSError is without deep checking. Many things can cause it.  <br><b>Suggestion: </b>Bring your code to an instructor.      \",\n    TimeLimitError: \"A TimeLimit error means that BlockPy wasn't able to process your program fast enough. Typically, this means that you're iterating through too many elements.\"}\n", "src/lib/pedal/sandbox/exceptions.py": "import traceback\nimport os\nimport sys\n\nclass SandboxException(Exception):\n    \"\"\"\n    Generic base exception for sandbox errors.\n    \"\"\"\n\n\nclass SandboxPreventModule(Exception):\n    \"\"\"\n    Caused by student attempting to load a module that they shouldn't.\n    \"\"\"\n\n\nclass SandboxHasNoFunction(SandboxException):\n    \"\"\"\n    Caused by attempting to access a function that the student hasn't created.\n    \"\"\"\n\n\nclass SandboxHasNoVariable(SandboxException):\n    \"\"\"\n    Caused by attempting to access a variable that the student hasn't created.\n    \"\"\"\n\n\nclass SandboxNoMoreInputsException(Exception):\n    \"\"\"\n    Caused by the student calling `input` when the instructor hasn't provided\n    enough inputs. Typically, the student has an infinite loop around their\n    `input` function.\n    \"\"\"\n\n\nBuiltinKeyError = KeyError\n\n\nclass KeyError(BuiltinKeyError):\n    \"\"\"\n    A version of KeyError that replaces the built-in with one small\n    modification: when printing an explanatory message, the message is not\n    rendered as a tuple. Because that's stupid and the fact that it made it\n    into CPython is just rude.\n    \n    See Also:\n        https://github.com/python/cpython/blob/master/Objects/exceptions.c#L1556\n    \"\"\"\n    __module__ = \"builtins\"\n\n    def __init__(self, original, message):\n        self.__cause__ = original.__cause__\n        self.__traceback__ = original.__traceback__\n        self.__context__ = original.__context__\n        self.message = message\n\n    def __str__(self):\n        return self.message\n\n\ndef _add_context_to_error(e, message):\n    if isinstance(e, BuiltinKeyError):\n        new_args = repr(e.args[0]) + message\n        e = KeyError(e, new_args)\n    if isinstance(e, OSError):\n        # TODO: Can't seem to modify the OSError, since they have so many args.\n        return e\n    elif e.args:\n        e.args = tuple([e.args[0] + message])\n    return e\nx=sys.stdout\nclass SandboxTraceback:\n    \"\"\"\n    Class for reformatting tracebacks to have more pertinent information.\n    \"\"\"\n\n    def __init__(self, exception, exc_info, full_traceback,\n                 instructor_filename, line_offset, student_filename,\n                 original_code_lines):\n        \"\"\"\n        Args:\n            exception (Exception): The exception that was raised.\n            exc_info (ExcInfo): The result of sys.exc_info() when the exception\n                was raised.\n            full_traceback (bool): Whether or not to provide the full traceback\n                or just the parts relevant to students.\n            instructor_filename (str): The name of the instructor file, which\n                can be used to avoid reporting instructor code in the\n                traceback.\n        \"\"\"\n        self.line_offset = line_offset\n        self.exception = exception\n        self.exc_info = exc_info\n        self.full_traceback = full_traceback\n        self.instructor_filename = instructor_filename\n        self.student_filename = student_filename\n        self.line_number = traceback.extract_tb(exc_info[2])[-1][1]\n        self.original_code_lines = original_code_lines\n\n    def _clean_traceback_line(self, line):\n        return line.replace(', in <module>', '', 1)\n\n    def format_exception(self, preamble=\"\"):\n        if not self.exception:\n            return \"\"\n        cl, exc, tb = self.exc_info\n        while tb and self._is_relevant_tb_level(tb):\n            tb = tb.tb_next\n        length = self._count_relevant_tb_levels(tb)\n        tb_e = traceback.TracebackException(cl, exc, tb, limit=length,\n                                            capture_locals=False)\n        # print(list(), file=x)\n        for frame in tb_e.stack:\n            if frame.filename == os.path.basename(self.student_filename):\n                frame.lineno += self.line_offset\n            frame._line = self.original_code_lines[frame.lineno-1]\n        lines = [self._clean_traceback_line(line)\n                 for line in tb_e.format()]\n        lines[0] = \"Traceback:\\n\"\n        return preamble + ''.join(lines)\n\n    def _count_relevant_tb_levels(self, tb):\n        length = 0\n        while tb and not self._is_relevant_tb_level(tb):\n            length += 1\n            tb = tb.tb_next\n        return length\n\n    def _is_relevant_tb_level(self, tb):\n        \"\"\"\n        Determines if the give part of the traceback is relevant to the user.\n\n        Returns:\n            boolean: True means it is NOT relevant\n        \"\"\"\n        # Are in verbose mode?\n        if self.full_traceback:\n            return False\n        filename, a_, b_, _ = traceback.extract_tb(tb, limit=1)[0]\n        # Is the error in the instructor file?\n        if filename == self.instructor_filename:\n            return True\n        # Is the error in this test directory?\n        current_directory = os.path.dirname(os.path.realpath(__file__))\n        if filename.startswith(current_directory):\n            return True\n        # Is the error related to a file in the parent directory?\n        parent_directory = os.path.dirname(current_directory)\n        # Currently we don't refer to this?\n        # Is the error in a local file?\n        if filename.startswith('.'):\n            return False\n        # Is the error in an absolute path?\n        if not os.path.isabs(filename):\n            return False\n        # Okay, it's not a student related file\n        return True\n", "src/lib/pedal/sandbox/tracer.py": "import sys\nimport os\n\ntry:\n    import coverage\nexcept ImportError:\n    coverage = None\n\ntry:\n    from bdb import Bdb, BdbQuit\nexcept ImportError:\n    class Bdb:\n        pass\n\n\n    class BdbQuit:\n        pass\n\n\nclass SandboxBasicTracer:\n    def __init__(self):\n        super().__init__()\n        self.filename = \"student.py\"\n\n    def _as_filename(self, filename, code):\n        if os.path.isabs(filename):\n            self.filename = filename\n        else:\n            self.filename = os.path.abspath(filename)\n        self.code = code\n        return self\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        pass\n\n\nclass SandboxCoverageTracer(SandboxBasicTracer):\n    def __init__(self):\n        super().__init__()\n        if coverage is None:\n            raise ImportError(\"The coverage package is not available.\")\n        self.n_missing = None\n        self.n_statements = None\n        self.pc_covered = None\n        self.missing = set()\n        self.lines = set()\n        # self.s = sys.stdout\n\n    def __enter__(self):\n        # Force coverage to accept the code\n        self.original = coverage.python.get_python_source\n\n        def _get_source_correctly(reading_filename):\n            print(reading_filename, file=self.s)\n            if reading_filename == self.filename:\n                return self.code\n            else:\n                return self.original(reading_filename)\n\n        coverage.python.get_python_source = _get_source_correctly\n        self.coverage = coverage.Coverage()\n        self.coverage.start()\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        self.coverage.stop()\n        self.coverage.save()\n        # Restore the get_python_source reader\n        coverage.python.get_python_source = self.original\n        self.original = None\n        # Actually analyze the data, attach some data\n        analysis = self.coverage._analyze(self.filename)\n        # print(vars(self.coverage._analyze(self.filename)), file=self.s)\n        self.n_missing = analysis.numbers.n_missing\n        self.n_statements = analysis.numbers.n_statements\n        self.pc_covered = analysis.numbers.pc_covered\n        self.missing = analysis.missing\n        self.lines = analysis.statements - analysis.missing\n    \n    @property\n    def percent_covered(self):\n        return self.pc_covered\n\n\nclass SandboxCallTracer(SandboxBasicTracer, Bdb):\n    def __init__(self):\n        super().__init__()\n        self.calls = {}\n\n    def user_call(self, frame, argument_list):\n        code = frame.f_code\n        name = code.co_name\n        if name not in self.calls:\n            self.calls[name] = []\n        self.calls[name].append(code)\n\n    def __enter__(self):\n        self.reset()\n        self._old_trace = sys.gettrace()\n        sys.settrace(self.trace_dispatch)\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        sys.settrace(self._old_trace)\n        self.quitting = True\n        # Return true to suppress exception (if it is a BdbQuit)\n        return isinstance(exc_type, BdbQuit)\n", "src/lib/pedal/report/imperative.py": "\"\"\"\nImperative style commands for constructing feedback in a convenient way.\nUses a global report object (MAIN_REPORT).\n\"\"\"\n\n__all__ = ['set_success', 'compliment', 'give_partial', 'explain',\n           'gently', 'hide_correctness', 'suppress', 'log', 'debug',\n           'clear_report', 'get_all_feedback', 'MAIN_REPORT']\n\nfrom pedal.report.report import Report\n\n#: The global Report object. Meant to be used as a default singleton\n#: for any tool, so that instructors do not have to create their own Report.\n#: Of course, all APIs are expected to work with a given Report, and only\n#: default to this Report when no others are given.\nMAIN_REPORT = Report()\n\n\ndef set_success():\n    \"\"\"\n    Creates Successful feedback for the user, indicating that the entire\n    assignment is done.\n    \"\"\"\n    MAIN_REPORT.set_success()\n\n\ndef compliment(message, line=None):\n    \"\"\"\n    Create a positive feedback for the user, potentially on a specific line of\n    code.\n\n    Args:\n        message (str): The message to display to the user.\n        line (int): The relevant line of code to reference.\n    \"\"\"\n    MAIN_REPORT.compliment(message, line)\n\n\ndef give_partial(value, message=None):\n    \"\"\"\n    Increases the user's current score by the `value`. Optionally display\n    a positive message too.\n\n    Args:\n        value (number): The number to increase the user's score by.\n        message (str): The message to display to the user.\n    \"\"\"\n    MAIN_REPORT.give_partial(value, message)\n\n\ndef explain(message, priority='medium', line=None, label='explain'):\n    MAIN_REPORT.explain(message, priority, line, label=label)\n\n\ndef gently(message, line=None, label='explain'):\n    MAIN_REPORT.gently(message, line, label=label)\n\n\ndef hide_correctness():\n    MAIN_REPORT.hide_correctness()\n\n\ndef suppress(category, label=True):\n    MAIN_REPORT.suppress(category, label)\n\n\ndef log(message):\n    MAIN_REPORT.log(message)\n\n\ndef debug(message):\n    MAIN_REPORT.debug(message)\n\n\ndef clear_report():\n    MAIN_REPORT.clear()\n\n\ndef get_all_feedback():\n    return MAIN_REPORT.feedback\n", "src/lib/pedal/report/feedback.py": "\"\"\"\nSimple data classes for storing feedback to present to learners.\n\"\"\"\n\n__all__ = ['Feedback']\n\n\nclass Feedback:\n    \"\"\"\n    A class for storing raw feedback.\n\n    Attributes:\n        label (str): An internal name for this specific piece of feedback.\n        tool (str): An internal name for indicating the tool that created\n                    this feedback.\n        category (str): A human-presentable name showable to the learner.\n                        More than one Feedback will be in a category, most\n                        likely.\n        priority (str): An indication of how important this feedback is.\n                        Might be \"high/medium/low\" or the name of a\n                        category (tool?) to supersede. Exactly how this gets\n                        used is up to the resolver. A special kind of priority\n                        is \"positive\" - which indicates that this feedback is\n                        positive, and the information is good to convey to the\n                        student.\n        group (int or str): The group that this piece of feedback should be\n            associated with. Some resolvers want to group feedback using this\n            identifier.\n        result (bool): Whether or not this feedback is associated with the\n                       learner completing the task (\"Success!\").\n        performance (float): A relative amount that this feedback contributes\n             to the students' performance (think in terms of\n             partial credit, like \"Triggering this feedback\n             is worth 20% (.2)\").\n        misconceptions (Message): A description of the misconception that\n            is believed to be in the student's mind,\n            or perhaps the relevant concept from the\n            material that should be associated with\n            this. (\"Variables must be initialized\n            before they are used\").\n        mistakes (Message): A description of the error or bug that the\n                              student has created (\"NameError on line 5: sum\n                              has not been defined\").\n        hints (Message): A suggestion for what the student can do\n                           (\"Initialize the sum variable on line 2\").\n        constraints (Message): A description of the task requirements or\n                                 task type that the student has violated\n                                 (\"You used a for loop, but this question\n                                 expected you to use recursion.\").\n        metacognitives (Message): A suggestion for more regulative\n                                    strategies (\"You have been working for\n                                    5 hours, perhaps it is time to take\n                                    a break?\").\n    \"\"\"\n    MESSAGE_TYPES = ['hint', 'mistake', 'misconception',\n                     'constraint', 'metacognitive']\n\n    def __init__(self, label, tool='instructor',\n                 category='Instructor feedback', priority=None, group=None,\n                 result=None, performance=None, misconception=None,\n                 mistake=None, hint=None, constraint=None,\n                 metacognitive=None):\n        # Metadata\n        self.label = label\n        self.tool = tool\n        self.category = category\n        self.priority = priority\n        self.group = group\n        # Data\n        self.result = result\n        self.performance = performance\n        self.misconception = misconception\n        self.mistake = mistake\n        self.hint = hint\n        self.constraint = constraint\n        self.metacognitive = metacognitive\n\n    def __str__(self):\n        return \"<Feedback ({})>\".format(self.label)\n\n    def __repr__(self):\n        metadata = \"\"\n        if self.tool is not None:\n            metadata += \", tool=\" + self.tool\n        if self.category is not None:\n            metadata += \", category=\" + self.category\n        if self.priority is not None:\n            metadata += \", priority=\" + self.priority\n        if self.group is not None:\n            metadata += \", group=\" + str(self.group)\n        data = \"\"\n        return \"Feedback({}{}{})\".format(self.label, metadata, data)\n\n\n\"\"\"\nA Message is one of:\n    str\n    Dict with a `message` field and any other suitable fields, such as:\n        html_message: An HTML message instead of a plaintext message.\n        line: The line number to highlight\n        error: The error message to render\n\"\"\"\n", "src/lib/pedal/report/__init__.py": "\"\"\"\nThe collection of classes and functions used to store the fundamental Report\nand Feedback objects.\n\"\"\"\n\nfrom pedal.report.report import Report\nfrom pedal.report.feedback import Feedback\nfrom pedal.report.imperative import *\n", "src/lib/pedal/report/report.py": "from pedal.report.feedback import Feedback\n\n__all__ = ['Report']\n\n\nclass Report:\n    \"\"\"\n    A class for storing Feedback generated by Tools, along with any auxiliary\n    data that the Tool might want to provide for other tools.\n\n    Attributes:\n        feedback (list of Feedback): The raw feedback generated for this Report\n                                     so far.\n        suppressions (list of tuple(str, str)): The categories and labels that\n                                                have been suppressed so far.\n        group (int or str): The label for the current group. Feedback given\n            by a Tool will automatically receive the current `group`. This\n            is used by the Source tool, for example, in order to group feedback\n            by sections.\n        group_names (dict[group:str]): A printable, student-facing name for the\n            group. When a group needs to be rendered out to the user, this\n            will override whatever label was going to be presented instead.\n        group_order (sequence or callable or None): The mechanism to use to\n            order groups. If a sequence, the order will be inferred based on\n            the order of elements in the sequence. If a callable, the callable\n            will be used as a key function for `sort`. If `None`, then defaults\n            to the natural ordering of the groups. Defaults to `None`.\n        hooks (dict[str: list[callable]): A dictionary mapping events to\n            a list of callable functions. Tools can register functions on\n            hooks to have them executed when the event is triggered by another\n            tool. For example, the Assertions tool has hooks on the Source tool\n            to trigger assertion resolutions before advancing to next sections.\n        _results (dict of str => any): Maps tool names to their data. The\n                                       namespace for a tool can be used to\n                                       store whatever they want, but will\n                                       probably be in a dictionary itself.\n    \"\"\"\n    group_order = None\n\n    def __init__(self):\n        \"\"\"\n        Creates a new Report instance.\n        \"\"\"\n        self.clear()\n\n    def clear(self):\n        self.feedback = []\n        self.suppressions = {}\n        self._results = {}\n        self.group = None\n        self.group_names = {}\n        self.hooks = {}\n\n    def set_success(self, group=None):\n        \"\"\"\n        Creates Successful feedback for the user, indicating that the entire\n        assignment is done.\n        \"\"\"\n        if group is None:\n            group = self.group\n        self.feedback.append(Feedback('set_success', priority='positive',\n                                      result=True, group=group))\n\n    def give_partial(self, value, message=None, group=None):\n        if value is None:\n            return False\n        if group is None:\n            group = self.group\n        self.feedback.append(Feedback('give_partial', performance=value,\n                                      priority='positive',\n                                      group=group,\n                                      mistake=message))\n        return True\n\n    def hide_correctness(self):\n        self.suppressions['success'] = []\n\n    def explain(self, message, priority='medium', line=None, group=None,\n                label='explain'):\n        misconception = {'message': message}\n        if line is not None:\n            misconception['line'] = line\n        if group is None:\n            group = self.group\n        self.attach(label, priority=priority, category='instructor',\n                    group=group, misconception=misconception)\n\n    def gently(self, message, line=None, group=None, label='explain'):\n        self.explain(message, priority='student', line=line, group=group,\n                     label=label)\n\n    def compliment(self, message, line=None, group=None, label='explain'):\n        self.explain(message, priority='positive', line=line, group=group,\n                     label=label)\n\n    def attach(self, label, **kwargs):\n        self.feedback.append(Feedback(label, **kwargs))\n\n    def log(self, message):\n        pass\n\n    def debug(self, message):\n        pass\n\n    def suppress(self, category, label=True, where=True):\n        \"\"\"\n        Args:\n            category (str): The category of feedback to suppress.\n            label (str): A specific label to match against and suppress.\n            where (bool or group): Which group of report to localize the\n                suppression to. If instead `True` is passed, the suppression\n                occurs in every group globally.\n                TODO: Currently, only global suppression is supported.\n        \"\"\"\n        category = category.lower()\n        if isinstance(label, str):\n            label = label.lower()\n        if category not in self.suppressions:\n            self.suppressions[category] = []\n        self.suppressions[category].append(label)\n\n    def add_hook(self, event, function):\n        \"\"\"\n        Register the `function` to be executed when the given `event` is\n        triggered.\n        \n        Args:\n            event (str): An event name. Multiple functions can be triggered for\n                the same `event`. The format is as follows:\n                    \"pedal.module.function.extra\"\n\n                The `\".extra\"` component is optional to add further nuance, but\n                the general idea is that you are referring to functions that,\n                when called, should trigger other functions to be called first.\n            function (callable): A callable function. This function should\n                accept a keyword parameter named `report`, which will \n        \"\"\"\n        if event not in self.hooks:\n            self.hooks[event] = []\n        self.hooks[event].append(function)\n\n    def execute_hooks(self, event):\n        if event in self.hooks:\n            for function in self.hooks[event]:\n                function(report=self)\n\n    def __getitem__(self, key):\n        if key not in self._results:\n            self._results[key] = {}\n        return self._results[key]\n\n    def __setitem__(self, key, value):\n        self._results[key] = value\n\n    def __contains__(self, key):\n        return key in self._results\n", "src/lib/pedal/toolkit/functions.py": "from pedal.cait.cait_api import parse_program\nfrom pedal.report.imperative import gently, explain, MAIN_REPORT\nfrom pedal.sandbox import compatibility\nimport ast\n\nDELTA = 0.001\n\n\ndef all_documented():\n    ast = parse_program()\n    defs = ast.find_all('FunctionDef') + ast.find_all(\"ClassDef\")\n    for a_def in defs:\n        if a_def.name == \"__init__\":\n            continue\n        if (a_def.body and\n                (a_def.body[0].ast_name != \"Expr\" or\n                 a_def.body[0].value.ast_name != \"Str\")):\n            if a_def.ast_name == 'FunctionDef':\n                gently(\"You have an undocumented function: \" + a_def.name)\n            else:\n                gently(\"You have an undocumented class: \" + a_def.name)\n            return False\n    return True\n\n\ndef get_arg_name(node):\n    name = node.id\n    if name is None:\n        return node.arg\n    else:\n        return name\n\n\ndef match_function(name, root=None):\n    if root is None:\n        ast = parse_program()\n    else:\n        ast = root\n    defs = ast.find_all('FunctionDef')\n    for a_def in defs:\n        if a_def._name == name:\n            return a_def\n    return None\n\n\ndef match_signature(name, length, *parameters):\n    ast = parse_program()\n    defs = ast.find_all('FunctionDef')\n    for a_def in defs:\n        if a_def._name == name:\n            found_length = len(a_def.args.args)\n            if found_length < length:\n                gently(\"The function named <code>{}</code> has fewer parameters ({}) than expected ({}). \"\n                       \"<br><br><i>(insuff_args)<i>\".format(name, found_length, length))\n            elif found_length > length:\n                gently(\"The function named <code>{}</code> has more parameters ({}) than expected ({}). \"\n                       \"<br><br><i>(excess_args)<i>\".format(name, found_length, length))\n            elif parameters:\n                for parameter, arg in zip(parameters, a_def.args.args):\n                    arg_name = get_arg_name(arg)\n                    if arg_name != parameter:\n                        gently(\"Error in definition of <code>{}</code>. Expected a parameter named {}, instead \"\n                               \"found {}. <br><br><i>(name_missing)<i>\".format(name, parameter, arg_name))\n                        return None\n                else:\n                    return a_def\n            else:\n                return a_def\n    else:\n        gently(\"No function named <code>{name}</code> was found.\"\n               \"<br><br><i>(missing_func_{name})<i>\".format(name=name))\n    return None\n\n\nGREEN_CHECK = \"<td class='green-check-mark'>&#10004;</td>\"\nRED_X = \"<td>&#10060;</td>\"\n\n\ndef output_test(name, *tests):\n    student = compatibility.get_student_data()\n    if name in student.data:\n        the_function = student.data[name]\n        if callable(the_function):\n            result = (\"<table class='blockpy-feedback-unit table table-condensed table-bordered table-hover'>\"\n                      \"<tr class='active'><th></th><th>Arguments</th><th>Expected</th><th>Actual</th></tr>\"\n                      )\n            success = True\n            success_count = 0\n            for test in tests:\n                inp = test[:-1]\n                inputs = ', '.join([\"<code>{}</code>\".format(repr(i)) for i in inp])\n                out = test[-1]\n                tip = \"\"\n                if isinstance(out, tuple):\n                    tip = out[1]\n                    out = out[0]\n                message = \"<td><code>{}</code></td>\" + (\"<td><pre>{}</pre></td>\" * 2)\n                test_out = compatibility.capture_output(the_function, *inp)\n                if isinstance(out, str):\n                    if len(test_out) < 1:\n                        message = message.format(inputs, repr(out), \"<i>No output</i>\", tip)\n                        message = \"<tr class=''>\" + RED_X + message + \"</tr>\"\n                        if tip:\n                            message += \"<tr class='info'><td colspan=4>\" + tip + \"</td></tr>\"\n                        success = False\n                    elif len(test_out) > 1:\n                        message = message.format(inputs, repr(out), \"<i>Too many outputs</i>\", tip)\n                        message = \"<tr class=''>\" + RED_X + message + \"</tr>\"\n                        if tip:\n                            message += \"<tr class='info'><td colspan=4>\" + tip + \"</td></tr>\"\n                        success = False\n                    elif out not in test_out:\n                        message = message.format(inputs, repr(out), repr(test_out[0]), tip)\n                        message = \"<tr class=''>\" + RED_X + message + \"</tr>\"\n                        if tip:\n                            message += \"<tr class='info'><td colspan=4>\" + tip + \"</td></tr>\"\n                        success = False\n                    else:\n                        message = message.format(inputs, repr(out), repr(test_out[0]), tip)\n                        message = \"<tr class=''>\" + GREEN_CHECK + message + \"</tr>\"\n                        success_count += 1\n                elif out != test_out:\n                    if len(test_out) < 1:\n                        message = message.format(inputs, repr(out), \"<i>No output</i>\", tip)\n                    else:\n                        message = message.format(inputs, repr(out), repr(test_out[0]), tip)\n                    message = \"<tr class=''>\" + RED_X + message + \"</tr>\"\n                    if tip:\n                        message += \"<tr class='info'><td colspan=4>\" + tip + \"</td></tr>\"\n                    success = False\n                else:\n                    message = message.format(inputs, repr(out), repr(test_out[0]), tip)\n                    message = \"<tr class=''>\" + GREEN_CHECK + message + \"</tr>\"\n                    success_count += 1\n                result += message\n            if success:\n                return the_function\n            else:\n                result = (\"I ran your function <code>{}</code> on some new arguments, and it gave the wrong output \"\n                          \"{}/{} times.\".format(name, len(tests) - success_count, len(tests)) + result)\n                gently(result + \"</table>\")\n                return None\n        else:\n            gently(\"You defined {}, but did not define it as a function.\"\n                   \"<br><br><i>(not_func_def)<i>\".format(name))\n            return None\n    else:\n        gently(\"The function <code>{}</code> was not defined.<br><br><i>(no_func_def)<i>\".format(name))\n        return None\n\n\ndef unit_test(name, *tests):\n    \"\"\"\n    Show a table\n    :param name:\n    :param tests:\n    :return:\n    \"\"\"\n    student = compatibility.get_student_data()\n    if name in student.data:\n        the_function = student.data[name]\n        if callable(the_function):\n            result = (\"<table class='blockpy-feedback-unit table table-condensed table-bordered table-hover'>\"\n                      \"<tr class='active'><th></th><th>Arguments</th><th>Returned</th><th>Expected</th></tr>\"\n                      )\n            success = True\n            success_count = 0\n            for test in tests:\n                inp = test[:-1]\n                inputs = ', '.join([\"<code>{}</code>\".format(repr(i)) for i in inp])\n                out = test[-1]\n                tip = \"\"\n                if isinstance(out, tuple):\n                    tip = out[1]\n                    out = out[0]\n                message = (\"<td><code>{}</code></td>\" * 3)\n                test_out = the_function(*inp)\n                message = message.format(inputs, repr(test_out), repr(out))\n                if (isinstance(out, float) and\n                        isinstance(test_out, (float, int)) and\n                        abs(out - test_out) < DELTA):\n                    message = \"<tr class=''>\" + GREEN_CHECK + message + \"</tr>\"\n                    success_count += 1\n                elif out != test_out:\n                    # gently(message)\n                    message = \"<tr class=''>\" + RED_X + message + \"</tr>\"\n                    if tip:\n                        message += \"<tr class='info'><td colspan=4>\" + tip + \"</td></tr>\"\n                    success = False\n                else:\n                    message = \"<tr class=''>\" + GREEN_CHECK + message + \"</tr>\"\n                    success_count += 1\n                result += message\n            if success:\n                return the_function\n            else:\n                result = \"I ran your function <code>{}</code> on some new arguments, \" \\\n                         \"and it failed {}/{} tests.\".format(name, len(tests) - success_count, len(tests)) + result\n                gently(result + \"</table>\")\n                return None\n        else:\n            gently(\"You defined {}, but did not define it as a function.\".format(name))\n            return None\n    else:\n        gently(\"The function <code>{}</code> was not defined.\".format(name))\n        return None\n\n\nclass _LineVisitor(ast.NodeVisitor):\n    \"\"\"\n    NodeVisitor subclass that visits every statement of a program and tracks\n    their line numbers in a list.\n    \n    Attributes:\n        lines (list[int]): The list of lines that were visited.\n    \"\"\"\n\n    def __init__(self):\n        self.lines = []\n\n    def _track_lines(self, node):\n        self.lines.append(node.lineno)\n        self.generic_visit(node)\n\n    visit_FunctionDef = _track_lines\n    visit_AsyncFunctionDef = _track_lines\n    visit_ClassDef = _track_lines\n    visit_Return = _track_lines\n    visit_Delete = _track_lines\n    visit_Assign = _track_lines\n    visit_AugAssign = _track_lines\n    visit_AnnAssign = _track_lines\n    visit_For = _track_lines\n    visit_AsyncFor = _track_lines\n    visit_While = _track_lines\n    visit_If = _track_lines\n    visit_With = _track_lines\n    visit_AsyncWith = _track_lines\n    visit_Raise = _track_lines\n    visit_Try = _track_lines\n    visit_Assert = _track_lines\n    visit_Import = _track_lines\n    visit_ImportFrom = _track_lines\n    visit_Global = _track_lines\n    visit_Nonlocal = _track_lines\n    visit_Expr = _track_lines\n    visit_Pass = _track_lines\n    visit_Continue = _track_lines\n    visit_Break = _track_lines\n\n\ndef check_coverage(report=None):\n    \"\"\"\n    Checks that all the statements in the program have been executed.\n    This function only works when a tracer_style has been set in the sandbox,\n    or you are using an environment that automatically traces calls (e.g.,\n    BlockPy).\n    \n    TODO: Make compatible with tracer_style='coverage'\n    \n    Args:\n        report (Report): The Report to draw source code from; if not given,\n            defaults to MAIN_REPORT.\n    Returns:\n        bool or set[int]: If the source file was not parsed, None is returned.\n            If there were fewer lines traced in execution than are found in\n            the AST, then the set of unexecuted lines are returned. Otherwise,\n            False is returned.\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    if not report['source']['success']:\n        return None, 0\n    lines_executed = set(compatibility.trace_lines())\n    if -1 in lines_executed:\n        lines_executed.remove(-1)\n    student_ast = report['source']['ast']\n    visitor = _LineVisitor()\n    visitor.visit(student_ast)\n    lines_in_code = set(visitor.lines)\n    if lines_executed < lines_in_code:\n        return lines_in_code - lines_executed, len(lines_executed)/len(lines_in_code)\n    else:\n        return False, 1\n\ndef ensure_coverage(percentage=.5, destructive=False, report=None):\n    '''\n    Note that this avoids destroying the current sandbox instance stored on the\n    report, if there is one present.\n    \n    Args:\n        destructive (bool): Whether or not to remove the sandbox.\n    '''\n    if report is None:\n        report = MAIN_REPORT\n    student_code = report['source']['code']\n    unexecuted_lines, percent_covered = check_coverage(report)\n    if unexecuted_lines:\n        if percent_covered <= percentage:\n            gently(\"Your code coverage is not adequate. You must cover at least half your code to receive feedback.\")\n            return False\n    return True\n\ndef ensure_cisc108_tests(test_count, report=None):\n    student = compatibility.get_student_data()\n    if 'assert_equal' not in student.data:\n        gently(\"You have not imported assert_equal from the cisc108 module.\")\n        return False\n    assert_equal = student.data['assert_equal']\n    if not hasattr(assert_equal, 'student_tests'):\n        gently(\"The assert_equal function has been modified. Do not let it be overwritten!\",\n               label=\"Assertion Function Corrupted\")\n        return False\n    student_tests = assert_equal.student_tests\n    if student_tests.tests == 0:\n        gently(\"You are not unit testing the result.\", label=\"No Student Unit Tests\")\n        return False\n    elif student_tests.tests < test_count:\n        gently(\"You have not written enough unit tests.\", label=\"Not Enough Student Unit Tests\")\n        return False\n    elif student_tests.failures > 0:\n        gently(\"Your unit tests are not passing.\", label=\"Student Unit Tests Failing\")\n        return False\n    return True\n", "src/lib/pedal/toolkit/files.py": "from pedal.cait.cait_api import parse_program\nfrom pedal.report.imperative import explain\nfrom pedal.toolkit.utilities import ensure_literal\n\n\ndef files_not_handled_correctly(*filenames):\n    \"\"\"\n    Statically detect if files have been opened and closed correctly.\n    This is only useful in the case of very simplistic file handling.\n    \"\"\"\n    if filenames and isinstance(filenames[0], int):\n        num_filenames = filenames[0]\n        actual_filenames = False\n    else:\n        num_filenames = len(filenames)\n        actual_filenames = True\n    ast = parse_program()\n    calls = ast.find_all(\"Call\")\n    called_open = []\n    closed = []\n    for a_call in calls:\n        if a_call.func.ast_name == 'Name':\n            if a_call.func.id == 'open':\n                if not a_call.args:\n                    explain(\"You have called the <code>open</code> function \"\n                            \"without any arguments. It needs a filename.\")\n                    return True\n                called_open.append(a_call)\n            elif a_call.func.id == 'close':\n                explain(\"You have attempted to call <code>close</code> as a \"\n                        \"function, but it is actually a method of the \"\n                        \"file object.\", 'verifier')\n                return True\n        elif a_call.func.ast_name == 'Attribute':\n            if a_call.func.attr == 'open':\n                explain(\"You have attempted to call <code>open</code> as a \"\n                        \"method, but it is actually a built-in function.\")\n                return True\n            elif a_call.func.attr == 'close':\n                closed.append(a_call)\n    if len(called_open) < num_filenames:\n        explain(\"You have not opened all the files you were supposed to.\")\n        return True\n    elif len(called_open) > num_filenames:\n        explain(\"You have opened more files than you were supposed to.\")\n        return True\n    withs = ast.find_all(\"With\")\n    if len(withs) + len(closed) < num_filenames:\n        explain(\"You have not closed all the files you were supposed to.\")\n        return True\n    elif len(withs) + len(closed) > num_filenames:\n        explain(\"You have closed more files than you were supposed to.\")\n        return True\n    if actual_filenames:\n        return ensure_literal(*filenames)\n    return False\n", "src/lib/pedal/toolkit/upload.py": "import re\nfrom pedal.source import get_program\nfrom pedal.sandbox.compatibility import get_output\nfrom pedal.report.imperative import gently, explain\n\n\n# Feedback for author's name\ndef check_author_name_on_header():\n    code = get_program()\n    m_author = re.search('Author: \\\\w+', code)\n    if not m_author:\n        gently(\"You need to add your name to the author field at the top of the file.\"\n               \"<br><br><i>(name_missing)<i></br></br>\")\n\n\ndef get_plots(output):\n    # The p[0] is the first plot in a graph/show\n    return [p[0] for p in output if isinstance(p[0], dict)]\n\n\ndef find_plot_of_type(plot_list, plot_type):\n    return [p['data'] for p in plot_list if p['type'] == plot_type]\n\n\n# Feedback for copying output of the program in the documentation\ndef check_output_on_header(expected_output):\n    code = get_program()\n    expected_output = str(expected_output)\n    between_stars = code.split(\"*****\")[2].strip()\n    between_stars = \"\\\\n\".join([x.strip() for x in between_stars.split(\"\\\\n\")])\n    if 'REPLACE THIS TEXT WITH THE OUTPUT OF THIS PROGRAM' in between_stars:\n        gently(\"In your code, you need to 'REPLACE THIS TEXT WITH THE OUTPUT OF THIS PROGRAM'\"\n               \"<br><br><i>(wrong_output_blank)<i></br></br>\")\n    elif expected_output not in between_stars:\n        gently(\"The output you copied between the *****, seems to be incorrect. You may have copied it into the wrong \"\n               \"location, or it is incomplete.<br><br><i>(wrong_output_fill)<i></br></br>\")\n\n\ndef check_problem_submission(prob_id):\n    if prob_id not in get_program():\n        explain(\"Make sure that you are turning in {}<br><br><i>(wrong_problem)<i></br></br>\".format(prob_id))\n        return True\n\n\ndef check_print_output(multiple_lines):\n    for line in multiple_lines:\n        if line not in get_output():\n            gently(\"You are not doing the correct calculation<br><br><i>(catch_all)<i></br></br>\")\n            return True\n\n\ndef find_in_code(regex):\n    code = get_program()\n    return re.search(regex, code)\n", "src/lib/pedal/toolkit/plotting.py": "from pedal.toolkit.utilities import function_is_called\nfrom pedal.cait.cait_api import parse_program, def_use_error\nfrom pedal.report.imperative import explain, gently\nfrom pedal.sandbox import compatibility\n\nPLOT_LABEL = {'plot': 'line plot',\n              'hist': 'histogram',\n              'scatter': 'scatter plot'}\n\n\ndef prevent_incorrect_plt():\n    ast = parse_program()\n    plts = [n for n in ast.find_all(\"Name\") if n.id == 'plt']\n    if plts and def_use_error(plts[0]):\n        explain(\"You have imported the <code>matplotlib.pyplot</code> module, \"\n                \"but you did not rename it to <code>plt</code> using \"\n                \"<code>import matplotlib.pyplot as plt</code>.<br><br><i>(plt_rename_err)<i>\", 'verifier')\n        return True\n    matplotlib_names = ['plot', 'hist', 'scatter',\n                        'title', 'xlabel', 'ylabel', 'show']\n    for name in matplotlib_names:\n        for n in ast.find_all(\"Name\"):\n            if n.id == name:\n                if def_use_error(n):\n                    explain((\"You have attempted to use the MatPlotLib \"\n                             \"function named <code>{0}</code>. However, you \"\n                             \"imported MatPlotLib in a way that does not \"\n                             \"allow you to use the function directly. I \"\n                             \"recommend you use <code>plt.{0}</code> instead, \"\n                             \"after you use <code>import matplotlib.pyplot as \"\n                             \"plt</code>.<br><br><i>(plt_wrong_import)<i>\").format(name), 'verifier')\n                    return True\n    return False\n\n\ndef ensure_correct_plot(function_name):\n    for a_plot, label in PLOT_LABEL.items():\n        if function_name == a_plot:\n            if not function_is_called(function_name):\n                gently(\"You are not calling the <code>{func_name}</code> function.\"\n                       \"<br><br><i>(no_{func_name}_call)<i>\".format(func_name=function_name))\n                return True\n        elif function_is_called(a_plot):\n            gently(\"You have called the <code>{}</code> function, which makes a {}.\"\n                   \"<br><br><i>(wrong_plt)<i>\".format(a_plot, label))\n            return True\n    return False\n\n\ndef ensure_show():\n    if not function_is_called(\"show\"):\n        gently(\"You have not called <code>show</code> function, which \"\n               \"actually creates the graph.<br><br><i>(no_show)<i>\")\n        return True\n    return False\n\n\ndef compare_data(plt_type, correct, given):\n    \"\"\"\n    Determines whether the given data matches any of the data found in the\n    correct data. This handles plots of different types: if a histogram\n    was plotted with the expected data for a line plot, it will return True.\n\n    Args:\n        plt_type (str): The expected type of this plot\n        correct (List of Int or List of List of Int): The expected data.\n        given (Dict): The actual plotted data and information\n    Returns:\n        bool: Whether the correct data was found in the given plot.\n    \"\"\"\n    # Infer arguments\n    if plt_type == 'hist':\n        correct_xs = None\n        correct_ys = correct\n    elif not correct:\n        correct_xs = []\n        correct_ys = []\n    elif isinstance(correct[0], (tuple, list)):\n        # We were given a list of lists of ints\n        correct_xs, correct_ys = correct\n    else:\n        # Assume it is a singular list\n        correct_xs = list(range(len(correct)))\n        correct_ys = correct\n\n    if given['type'] == 'hist':\n        return correct_ys == given['values']\n    elif plt_type == 'hist':\n        return correct_ys == given['y']\n    else:\n        return correct_xs == given['x'] and correct_ys == given['y']\n\n\nGRAPH_TYPES = {'line': 'line plot',\n               'hist': 'histogram',\n               'scatter': 'scatter plot'}\n\n\ndef check_for_plot(plt_type, data):\n    \"\"\"\n    Returns any errors found for this plot type and data.\n    In other words, if it returns False, the plot was found correctly.\n    \"\"\"\n    if plt_type == 'plot':\n        plt_type = 'line'\n    type_found = False\n    data_found = False\n    for graph in compatibility.get_plots():\n        for a_plot in graph['data']:\n            data_found_here = compare_data(plt_type, data, a_plot)\n            if a_plot['type'] == plt_type and data_found_here:\n                return False\n            if a_plot['type'] == plt_type:\n                type_found = True\n            if data_found_here:\n                data_found = True\n    plt_type = GRAPH_TYPES.get(plt_type, plt_type)\n    if type_found and data_found:\n        return (\"You have created a {}, but it does not have the right data. That data appears to have been plotted \"\n                \"in another graph.<br><br><i>(other_plt)<i>\".format(plt_type))\n    elif type_found:\n        return (\"You have created a {}, but it does not have the right data.\"\n                \"<br><br><i>(wrong_plt_data)<i>\".format(plt_type))\n    elif data_found:\n        return (\"You have plotted the right data, but you appear to have not plotted it as a {}.\"\n                \"<br><br><i>(wrong_plt_type)<i>\".format(plt_type))\n    else:\n        return (\"You have not created a {} with the proper data.\"\n                \"<br><br><i>(no_plt)<i>\".format(plt_type))\n", "src/lib/pedal/toolkit/__init__.py": "", "src/lib/pedal/toolkit/imports.py": "from pedal.cait.cait_api import parse_program\nfrom pedal.report.imperative import explain\n\n\ndef ensure_imports(*modules):\n    ast = parse_program()\n    for module in modules:\n        imports = ast.find_all(\"Import\")\n        import_froms = ast.find_all(\"ImportFrom\")\n        if not imports and not import_froms:\n            explain(\"You need to import the <code>{}</code> module.\".format(module))\n            return True\n        success = False\n        if imports:\n            if any(alias._name == module\n                   for i in imports\n                   for alias in i.names):\n                success = True\n        if import_froms:\n            if any(i.module == module for i in import_froms):\n                success = True\n        if not success:\n            explain(\"You need to import the <code>{}</code> module.\".format(module))\n            return True\n    return False\n", "src/lib/pedal/toolkit/signatures.py": "import re\n\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.report.imperative import gently, explain\n\n\"\"\"\nVerify indentation\n\nFormat:\n\n\nAny number of text. One final newline separates the next section.\n\nIf line is \"Args:\" or \"Returns:\"\n    Next line will be a \"param (type): Description\" or \"type: Description\"\n    If the next line is indented more than current level, then it is part of the previous part's description.\n    Otherwise, new entry\n\n\"Note:\"\n    Any level of indentation indicates\n\"\"\"\n\nPRIMITIVES = {\n    'text': ['text'],\n    'str': ['string', 'str', 'unicode'],\n    'bytes': ['bytes'],\n    'io': ['io'],\n    'file': ['file'],\n    'num': ['number', 'num', 'numeric'],\n    'int': ['int', 'integer'],\n    'float': ['float', 'floating'],\n    'bool': ['bool', 'boolean'],\n    'none': ['none'],\n    'any': ['any']\n}\nNORMALIZE_PRIMITIVES = {synonym: formal\n                        for formal, synonyms in PRIMITIVES.items()\n                        for synonym in synonyms}\nCONTAINERS = {\n    'list': (1, ['list']),\n    'set': (1, ['set']),\n    'optional': (1, ['optional', 'maybe']),\n    'dict': (2, ['dict', 'dictionary']),\n    'callable': (2, ['callable', 'function', 'func']),\n    'union': ('*', ['union', 'itemization']),\n    'tuple': ('*', ['tuple', 'pair']),\n}\nNORMALIZE_CONTAINERS = {synonym: formal\n                        for formal, (length, synonyms) in CONTAINERS.items()\n                        for synonym in synonyms}\n\nINHERITANCE = {\n    'int': 'num',\n    'float': 'num',\n    'bool': 'num',\n    'str': 'text',\n    'bytes': 'text',\n    'list': 'iterable',\n    'tuple': 'iterable',\n    'set': 'iterable',\n    'dict': 'iterable',\n    'file': 'iterable',\n    'text': 'iterable'\n}\n\nSPECIAL_PARAMETERS = [\"_returns\", \"yields\", \"prints\", \"_raises\",\n                      \"_report\", \"_root\"]\n\n'''\nType validation:\n    Caps does not matter\n    Primitives:\n    Containers\n    Unions\n        X or Y\n        X, Y, or Z\n        X, Y, Z\n    Function\n        (X -> Y)\n    \n    list[int, str, or bool], dict[int: str], or bool or int\n'''\n\n\nclass SignatureException(Exception):\n    pass\n\n\nclass Stack:\n    def __init__(self, identifier=\"union\"):\n        self.body = []\n        self.identifier = identifier\n\n    def append(self, value):\n        self.body.append(value)\n\n    def __repr__(self):\n        return \"{}[{}]\".format(self.identifier, \", \".join(map(repr, self.body)))\n\n    def __hash__(self):\n        return hash(tuple(self.identifier, self.body))\n\n    def __lt__(self, other):\n        if isinstance(other, Stack):\n            return self.identifier < other.identifier and self.body < other.body\n        return self.identifier < other\n\n    def __gt__(self, other):\n        if isinstance(other, Stack):\n            return self.identifier > other.identifier and self.body > other.body\n        return self.identifier > other\n\n    def __eq__(self, other):\n        if isinstance(other, Stack):\n            return self.identifier == other.identifier and self.body == other.body\n        return False\n\n\ndef _normalize_identifier(identifier):\n    if identifier in NORMALIZE_PRIMITIVES:\n        return NORMALIZE_PRIMITIVES[identifier]\n    elif identifier in NORMALIZE_CONTAINERS:\n        return NORMALIZE_CONTAINERS[identifier]\n    else:\n        return identifier\n\n\nSPECIAL_SYMBOLS = r\"\\s*(->|\\s*[\\[\\],\\(\\)\\:]|or)\\s*\"\n\n\ndef _parse_tokens(tokens):\n    result_stack = [Stack()]\n    tokens = list(reversed(list(tokens)))\n    while tokens:\n        current = tokens.pop()\n        # Ending a parenthetical, better stop here.\n        if current == \")\":\n            subexpression = result_stack.pop()\n            result_stack[-1].append(subexpression)\n        # Ending a square bracket, better stop here.\n        elif current == \"]\":\n            subexpression = result_stack.pop()\n            result_stack[-1].append(subexpression)\n        # We've reached the last token!\n        elif not tokens:\n            # And had no tokens before this one\n            # Return the set of tokens\n            result_stack[-1].append(_normalize_identifier(current))\n        # Starting a parentheized expression\n        elif current == \"(\":\n            result_stack.append(Stack())\n        # Nullary function\n        elif current == \"->\":\n            result_stack[-1].append(Stack(\"callable\"))\n        elif current in (\"or\", \",\", \":\"):\n            pass\n        else:\n            next = tokens.pop()\n            # X or ...\n            if current == \",\" and next == \"or\":\n                tokens.append(next)\n            if next in (\"or\", \",\", \"->\", \":\"):\n                result_stack[-1].append(_normalize_identifier(current))\n            # X [ ...\n            elif next == \"[\":\n                result_stack.append(Stack(_normalize_identifier(current)))\n            else:\n                tokens.append(next)\n                result_stack[-1].append(_normalize_identifier(current))\n    return result_stack.pop()\n\n\ndef sort_stacks(s):\n    if isinstance(s, Stack):\n        return (True, (s.identifier, s.body))\n    return (False, s)\n\n\ndef normalize_type(t):\n    t = t.strip()\n    tokens = re.split(SPECIAL_SYMBOLS, t)\n    tokens = [token for token in tokens if token]\n    parsed = _parse_tokens(tokens)\n    return parsed\n\n\ndef check_piece(left, right, indent=1):\n    if type(left) != type(right):\n        return False\n    elif isinstance(left, Stack):\n        if left.identifier != right.identifier:\n            return False\n        elif len(left.body) != len(right.body):\n            return False\n        elif left.identifier == \"union\":\n            # Handle them in any order\n            left.body.sort(key=sort_stacks)\n            right.body.sort(key=sort_stacks)\n        # Match them in exact order\n        for l, r in zip(left.body, right.body):\n            if not check_piece(l, r, indent=indent + 1):\n                return False\n        return True\n    else:\n        return left == right\n\n\ndef type_check(left, right):\n    left = normalize_type(left)\n    right = normalize_type(right)\n    return check_piece(left, right)\n    \ndef find_colon(str):\n    parens_stack = []\n    for i, character in enumerate(str):\n        if character in '[(':\n            parens_stack.append(character)\n        elif character in '])':\n            parens_stack.pop()\n        elif character == ':' and not parens_stack:\n            return i\n    return 0\n    \nARGS = ('args:', 'arg:', 'argument:', 'arguments:',\n        'parameters:', 'params:', 'parameter:', 'param:')\nARG_PATTERN = r'(.+)\\s*\\((.+)\\)\\s*:(.+)'\nRETURNS = ('returns:', 'return:')\ndef parse_docstring(doc):\n    # First line's indentation may be different from rest - trust first\n    # non empty line after the first one.\n    # Remove taht number of spaces from subsequent lines\n    # If Line is \"Args:\" or other special...\n    # \n    lines = doc.split(\"\\n\")\n    body = [lines[0]]\n    args = {}\n    current_arg = None\n    returns = []\n    current_component = 'body'\n    indentation = None\n    inner_indentation = None\n    for line in lines[1:]:\n        # Blank line, not interesting!\n        if not line.strip():\n            continue\n        # Get the actual text\n        if indentation is None:\n            indentation = len(line) - len(line.lstrip())\n        line = line[indentation:]\n        potential_command = line.lower().strip()\n        # New command region?\n        if potential_command in ARGS:\n            current_component = 'args'\n            inner_indentation = None\n            continue\n        elif potential_command in RETURNS:\n            current_component = 'returns'\n            inner_indentation = None\n            continue\n        # Okay, it's content - let's process it\n        if current_component == 'body':\n            body.append(line)\n        else:\n            if inner_indentation is None:\n                inner_indentation = len(line) - len(line.lstrip())\n            line = line[inner_indentation:]\n            # Skip indented lines\n            if not re.match(r'\\s', line):\n                if current_component == 'args':\n                    match = re.search(ARG_PATTERN, line)\n                    current_arg = match.group(1)\n                    type_str = match.group(2)\n                    args[current_arg.strip()] = type_str.strip()\n                elif current_component == 'returns':\n                    position = find_colon(line)\n                    return_type, comment = line[:position], line[position:]\n                    returns.append(return_type.strip())\n    return body, args, ' or '.join(returns)\n\ndef function_signature(function_name, returns=None, yields=None,\n                       prints=None, raises=None, report=None, root=None,\n                       **kwargs):\n    \"\"\"\n    Determines whether the function with this signature is in the AST.\n    \n    TODO: Implement raises, prints, yields\n    \"\"\"\n    if root is None:\n        root = parse_program()\n    # If you encounter any special parameters with a \"_\", then fix their\n    # name. This allows for students to have parameters with the given name.\n    for special_parameter in SPECIAL_PARAMETERS:\n        if special_parameter in kwargs:\n            kwargs[special_parameter[1:]] = kwargs.pop(special_parameter)\n    # Go get the actual docstring, parse it\n    docstring = None\n    for function_def in root.find_all(\"FunctionDef\"):\n        if function_def._name == function_name:\n            if function_def.body:\n                if (function_def.body[0].ast_name == \"Expr\" and\n                        function_def.body[0].value.ast_name == \"Str\"):\n                    docstring = function_def.body[0].value.s\n    # Try to match each element in turn.\n    if docstring is None:\n        return False\n\n    try:\n        body, args, parsed_returns = parse_docstring(docstring)\n    except Exception as e:\n        return [e], False\n    failing_parameters = []\n    for name, type in kwargs.items():\n        if name in args:\n            if not type_check(type, args[name]):\n                failing_parameters.append(name)\n        else:\n            failing_parameters.append(name)\n    if returns is None and not returns:\n        return failing_parameters, True\n    elif returns is not None and returns:\n        return failing_parameters, type_check(parsed_returns, returns)\n    else:\n        return failing_parameters, False\n    \n\ndef class_signature(class_name, report=None, root=None, **attributes):\n    \"\"\"\n\n    Args:\n        class_name:\n        **attributes:\n        report:\n        root:\n\n    Returns:\n\n    \"\"\"\n    if root is None:\n        root = parse_program()\n\n\n\"\"\"\n\n\"\"\"\n", "src/lib/pedal/toolkit/utilities.py": "from pedal.cait.cait_api import parse_program\nfrom pedal.report.imperative import gently, explain\n\n\ndef is_top_level(ast_node):\n    ast = parse_program()\n    for element in ast.body:\n        if element.ast_name == 'Expr':\n            if element.value == ast_node:\n                return True\n        elif element == ast_node:\n            return True\n    return False\n\n\ndef no_nested_function_definitions():\n    ast = parse_program()\n    defs = ast.find_all('FunctionDef')\n    for a_def in defs:\n        if not is_top_level(a_def):\n            gently(\"You have defined a function inside of another block. For instance, you may have placed it inside \"\n                   \"another function definition, or inside of a loop. Do not nest your function definition!\"\n                   \"<br><br><i>(nest_func)<i>\")\n            return False\n    return True\n\n\ndef function_prints():\n    ast = parse_program()\n    defs = ast.find_all('FunctionDef')\n    for a_def in defs:\n        all_calls = a_def.find_all('Call')\n        for a_call in all_calls:\n            if a_call.func.ast_name == 'Name':\n                if a_call.func.id == 'print':\n                    return True\n    return False\n\n\ndef find_function_calls(name, root=None):\n    if root is None:\n        root = parse_program()\n    all_calls = root.find_all('Call')\n    calls = []\n    for a_call in all_calls:\n        if a_call.func.ast_name == 'Attribute':\n            if a_call.func.attr == name:\n                calls.append(a_call)\n        elif a_call.func.ast_name == 'Name':\n            if a_call.func.id == name:\n                calls.append(a_call)\n    return calls\n\n\ndef function_is_called(name):\n    return len(find_function_calls(name))\n\n\ndef no_nonlist_nums():\n    pass\n\n\ndef only_printing_variables():\n    ast = parse_program()\n    all_calls = ast.find_all('Call')\n    for a_call in all_calls:\n        if a_call.func.ast_name == 'Name' and a_call.func.id == \"print\":\n            for arg in a_call.args:\n                if arg.ast_name != \"Name\":\n                    return False\n                elif arg.id in ('True', 'False', 'None'):\n                    return False\n    return True\n\n\ndef find_prior_initializations(node):\n    if node.ast_name != \"Name\":\n        return None\n    ast = parse_program()\n    assignments = ast.find_all(\"Assign\")\n    cur_line_no = node.lineno\n    all_assignments = []\n    for assignment in assignments:\n        if assignment.has(node):\n            if assignment.lineno < cur_line_no:\n                all_assignments.append(assignment)\n    return all_assignments\n\n\ndef prevent_unused_result():\n    ast = parse_program()\n    exprs = ast.find_all('Expr')\n    for expr in exprs:\n        if expr.value.ast_name == \"Call\":\n            a_call = expr.value\n            if a_call.func.ast_name == 'Attribute':\n                if a_call.func.attr == 'append':\n                    pass\n                elif a_call.func.attr in ('replace', 'strip', 'lstrip', 'rstrip'):\n                    gently(\"Remember! You cannot modify a string directly. Instead, you should assign the result back \"\n                           \"to the string variable.<br><br><i>(str_mutate)<i>\")\n\n\ndef prevent_builtin_usage(function_names):\n    # Prevent direction calls\n    ast = parse_program()\n    all_calls = ast.find_all('Call')\n    for a_call in all_calls:\n        if a_call.func.ast_name == 'Name':\n            if a_call.func.id in function_names:\n                explain(\"You cannot use the builtin function <code>{}</code>.<br><br><i>(builtin_use)<i>\".format(\n                    a_call.func.id))\n                return a_call.func.id\n    return None\n\n# TODO: UGLY HACK. This is to avoid muted=False kwargs in the following\n#       functions. Apparently skulpt doesn't support this syntax.\nmuted = False\n\ndef prevent_literal(*literals):\n    '''\n    Confirms that the literal is not in the code, returning False if it is not.\n    \n    Args:\n        *literals (Any...): A series of literal values to look for.\n    Returns:\n        AstNode or False: If the literal is found in the code, then it is returned.\n    '''\n    ast = parse_program()\n    str_values = [s.s for s in ast.find_all(\"Str\")]\n    num_values = [n.n for n in ast.find_all(\"Num\")]\n    name_values = ([name.id for name in ast.find_all(\"Name\")]+\n                   [name.value for name in ast.find_all(\"NameConstant\")])\n    for literal in literals:\n        if isinstance(literal, (int, float)):\n            if literal in num_values:\n                if not muted:\n                    explain(\"Do not use the literal value <code>{}</code> in your code.\"\n                            \"<br><br><i>(hard_code)<i>\".format(repr(literal)))\n                return literal\n        elif isinstance(literal, str):\n            if literal in str_values:\n                if not muted:\n                    explain(\"Do not use the literal value <code>{}</code> in your code.\"\n                            \"<br><br><i>(hard_code)<i>\".format(repr(literal)))\n                return literal\n        elif literal in (True, False, None):\n            if str(literal) in name_values:\n                if not muted:\n                    explain(\"Do not use the literal value <code>{}</code> in your code.\"\n                            \"<br><br><i>(hard_code)<i>\".format(repr(literal)))\n                return literal\n    return False\n\ndef ensure_literal(*literals):\n    '''\n    Confirms that the literal IS in the code, returning False if it is not.\n    \n    Args:\n        *literals (Any...): A series of literal values to look for.\n    Returns:\n        AstNode or False: If the literal is found in the code, then it is returned.\n    '''\n    ast = parse_program()\n    str_values = [s.s for s in ast.find_all(\"Str\")]\n    num_values = [n.n for n in ast.find_all(\"Num\")]\n    name_values = ([str(name.id) for name in ast.find_all(\"Name\")]+\n                   [str(name.value) for name in ast.find_all(\"NameConstant\")])\n    for literal in literals:\n        if literal in (True, False, None):\n            if str(literal) not in name_values:\n                if not muted:\n                    explain(\"You need the literal value <code>{}</code> in your code.\"\n                            \"<br><br><i>(missing_literal)<i>\".format(repr(literal)))\n                return True\n        elif isinstance(literal, (int, float)):\n            if literal not in num_values:\n                if not muted:\n                    explain(\"You need the literal value <code>{}</code> in your code.\"\n                            \"<br><br><i>(missing_literal)<i>\".format(repr(literal)))\n                return literal\n        elif isinstance(literal, str):\n            if literal not in str_values:\n                if not muted:\n                    explain(\"You need the literal value <code>{}</code> in your code.\"\n                            \"<br><br><i>(missing_literal)<i>\".format(repr(literal)))\n                return literal\n    return False\n\n\ndef prevent_advanced_iteration():\n    ast = parse_program()\n    if ast.find_all('While'):\n        explain(\"You should not use a <code>while</code> loop to solve this problem.\"\n                \"<br><br><i>(while_usage)<i>\")\n    prevent_builtin_usage(['sum', 'map', 'filter', 'reduce', 'len', 'max', 'min',\n                           'max', 'sorted', 'all', 'any', 'getattr', 'setattr',\n                           'eval', 'exec', 'iter'])\n\n\nCOMPARE_OP_NAMES = {\n    \"==\": \"Eq\",\n    \"<\": \"Lt\",\n    \"<=\": \"Lte\",\n    \">=\": \"Gte\",\n    \">\": \"Gt\",\n    \"!=\": \"NotEq\",\n    \"is\": \"Is\",\n    \"is not\": \"IsNot\",\n    \"in\": \"In\",\n    \"not in\": \"NotIn\"}\nBOOL_OP_NAMES = {\n    \"and\": \"And\",\n    \"or\": \"Or\"}\nBIN_OP_NAMES = {\n    \"+\": \"Add\",\n    \"-\": \"Sub\",\n    \"*\": \"Mult\",\n    \"/\": \"Div\",\n    \"//\": \"FloorDiv\",\n    \"%\": \"Mod\",\n    \"**\": \"Pow\",\n    \">>\": \"LShift\",\n    \"<<\": \"RShift\",\n    \"|\": \"BitOr\",\n    \"^\": \"BitXor\",\n    \"&\": \"BitAnd\",\n    \"@\": \"MatMult\"}\nUNARY_OP_NAMES = {\n    # \"+=\": \"UAdd\",\n    # \"-=\": \"USub\",\n    \"not\": \"Not\",\n    \"~\": \"Invert\"\n}\n\n\ndef ensure_operation(op_name, root=None):\n    if root is None:\n        root = parse_program()\n    result = find_operation(op_name, root)\n    if not result:\n        gently(\"You are not using the <code>{}</code> operator.<br><br><i>(missing_op)<i>\".format(op_name))\n    return result\n\n\ndef prevent_operation(op_name, root=None):\n    if root is None:\n        root = parse_program()\n    result = find_operation(op_name, root)\n    if result:\n        gently(\"You may not use the <code>{}</code> operator.<br><br><i>(bad_op)<i>\".format(op_name))\n    return result\n\n\ndef find_operation(op_name, root):\n    if op_name in COMPARE_OP_NAMES:\n        compares = root.find_all(\"Compare\")\n        for compare in compares:\n            for op in compare.ops:\n                if op.ast_name == COMPARE_OP_NAMES[op_name]:\n                    return compare\n    elif op_name in BOOL_OP_NAMES:\n        boolops = root.find_all(\"BoolOp\")\n        for boolop in boolops:\n            if boolop.op_name == BOOL_OP_NAMES[op_name]:\n                return boolop\n    elif op_name in BIN_OP_NAMES:\n        binops = root.find_all(\"BinOp\")\n        for binop in binops:\n            if binop.op_name == BIN_OP_NAMES[op_name]:\n                return binop\n    elif op_name in UNARY_OP_NAMES:\n        unaryops = root.find_all(\"UnaryOp\")\n        for unaryop in unaryops:\n            if unaryop.op_name == UNARY_OP_NAMES[op_name]:\n                return unaryop\n    return False\n\n\ndef ensure_recursion(function_name, root=None):\n    if root is None:\n        root = parse_program()\n    all_calls = root.find_all('Call')\n    calls = []\n    for a_call in all_calls:\n        if a_call.func.ast_name == 'Attribute':\n            if a_call.func.attr == function_name:\n                calls.append(a_call)\n        elif a_call.func.ast_name == 'Name':\n            if a_call.func.id == function_name:\n                calls.append(a_call)\n    return calls\n\n\ndef ensure_assignment(variable_name, type=None, value=None, root=None):\n    \"\"\"\n    Consumes a variable name\n    TODO: Implement the value parameter\n\n    :param variable_name: The variable name the student is expected to define.\n    :type variable_name: str\n    :param type: The string type of the node on the right side of the\n                 assignment. Check GreenTreeSnakes (e.g., \"Num\", or \"Str\").\n    :type type: str\n    :return: False or str\n    \"\"\"\n    if root is None:\n        root = parse_program()\n    assignments = root.find_all(\"Assign\")\n    potentials = []\n    for assign in assignments:\n        if assign.targets[0].ast_name != \"Name\":\n            continue\n        if assign.targets[0].id == variable_name:\n            potentials.append(assign)\n            if type is None:\n                return assign\n            elif (type == 'Bool' and\n                  assign.value.ast_name == 'Name' and\n                  assign.value.id in ('True', 'False')):\n                return assign\n            elif (type == 'Bool' and\n                  assign.value.ast_name == 'NameConstant' and\n                  assign.value.value in (True, False)):\n                return assign\n            elif assign.value.ast_name == type:\n                return assign\n    if potentials and potentials[0].value.ast_name not in (\"Str\", \"Bool\", \"Num\", \"List\", \"Tuple\"):\n        explain((\"You needed to assign a literal value to {variable}, but you \"\n                 \"created an expression instead.\").format(variable=variable_name))\n    elif type is None:\n        explain((\"You have not properly assigned anything to the variable \"\n                 \"{variable}.\").format(variable=variable_name))\n    else:\n        explain((\"You have not assigned a {type} to the variable {variable}.\"\n                 \"\").format(type=type, variable=variable_name))\n    return False\n", "src/lib/pedal/toolkit/printing.py": "from pedal.report.imperative import gently\nfrom pedal.toolkit.utilities import find_function_calls, is_top_level\n\n\ndef ensure_prints(count):\n    prints = find_function_calls('print')\n    if not prints:\n        gently(\"You are not using the print function!<br><br><i>(no_print)<i>\")\n        return False\n    elif len(prints) > count:\n        gently(\"You are printing too many times!<br><br><i>(multiple_print)<i>\")\n        return False\n    elif len(prints) < count:\n        gently(\"You are not printing enough things!<br><br><i>(too_few_print)<i>\")\n        return False\n    else:\n        for a_print in prints:\n            if not is_top_level(a_print):\n                gently(\"You have a print function that is not at the top level. That is incorrect for this problem!\"\n                       \"<br><br><i>(not_top_level_print)<i>\")\n                return False\n    return prints\n", "src/lib/pedal/tifa/type_operations.py": "import ast\n\nfrom pedal.tifa.type_definitions import (UnknownType, NumType, BoolType,\n                                         TupleType, ListType, StrType,\n                                         DictType, SetType, GeneratorType,\n                                         DayType, TimeType)\n\n\ndef merge_types(left, right):\n    # TODO: Check that lists/sets have the same subtypes\n    if isinstance(left, (ListType, SetType, GeneratorType)):\n        if left.empty:\n            return right.subtype\n        else:\n            return left.subtype.clone()\n    elif isinstance(left, TupleType):\n        return left.subtypes + right.subtypes\n\n\ndef NumType_any(*x):\n    return NumType()\n\n\ndef StrType_any(*x):\n    return StrType()\n\n\ndef BoolType_any(*x):\n    return BoolType()\n\n\ndef keep_left(left, right):\n    return left\n\n\ndef keep_right(left, right):\n    return right\n\n\nVALID_BINOP_TYPES = {\n    ast.Add: {NumType: {NumType: NumType_any},\n              StrType: {StrType: StrType_any},\n              ListType: {ListType: merge_types},\n              TupleType: {TupleType: merge_types}},\n    ast.Sub: {NumType: {NumType: NumType_any},\n              SetType: {SetType: merge_types}},\n    ast.Div: {NumType: {NumType: NumType_any}},\n    ast.FloorDiv: {NumType: {NumType: NumType_any}},\n    ast.Mult: {NumType: {NumType: NumType_any,\n                         StrType: StrType_any,\n                         ListType: keep_right,\n                         TupleType: keep_right},\n               StrType: {NumType: StrType_any},\n               ListType: {NumType: keep_left},\n               TupleType: {NumType: keep_left}},\n    ast.Pow: {NumType: {NumType: NumType_any}},\n    # TODO: Should we allow old-fashioned string interpolation?\n    # Currently, I vote no because it makes the code harder and is bad form.\n    ast.Mod: {NumType: {NumType: NumType_any}},\n    ast.LShift: {NumType: {NumType: NumType_any}},\n    ast.RShift: {NumType: {NumType: NumType_any}},\n    ast.BitOr: {NumType: {NumType: NumType_any},\n                BoolType: {NumType: NumType_any,\n                           BoolType: BoolType_any},\n                SetType: {SetType: merge_types}},\n    ast.BitXor: {NumType: {NumType: NumType_any},\n                 BoolType: {NumType: NumType_any,\n                            BoolType: BoolType_any},\n                 SetType: {SetType: merge_types}},\n    ast.BitAnd: {NumType: {NumType: NumType_any},\n                 BoolType: {NumType: NumType_any,\n                            BoolType: BoolType_any},\n                 SetType: {SetType: merge_types}}\n}\nVALID_UNARYOP_TYPES = {\n    ast.UAdd: {NumType: NumType},\n    ast.USub: {NumType: NumType},\n    ast.Invert: {NumType: NumType}\n}\n\n\ndef are_types_equal(left, right):\n    \"\"\"\n    Determine if two types are equal.\n\n    This could be more Polymorphic - move the code for each type into\n    its respective class instead.\n    \"\"\"\n    if left is None or right is None:\n        return False\n    elif isinstance(left, UnknownType) or isinstance(right, UnknownType):\n        return False\n    elif not isinstance(left, type(right)):\n        return False\n    elif isinstance(left, (GeneratorType, ListType)):\n        if left.empty or right.empty:\n            return True\n        else:\n            return are_types_equal(left.subtype, right.subtype)\n    elif isinstance(left, TupleType):\n        if left.empty or right.empty:\n            return True\n        elif len(left.subtypes) != len(right.subtypes):\n            return False\n        else:\n            for l, r in zip(left.subtypes, right.subtypes):\n                if not are_types_equal(l, r):\n                    return False\n            return True\n    elif isinstance(left, DictType):\n        if left.empty or right.empty:\n            return True\n        elif left.literals is not None and right.literals is not None:\n            if len(left.literals) != len(right.literals):\n                return False\n            else:\n                for l, r in zip(left.literals, right.literals):\n                    if not are_types_equal(l, r):\n                        return False\n                for l, r in zip(left.values, right.values):\n                    if not are_types_equal(l, r):\n                        return False\n                return True\n        elif left.literals is not None or right.literals is not None:\n            return False\n        else:\n            keys_equal = are_types_equal(left.keys, right.keys)\n            values_equal = are_types_equal(left.values, right.values)\n            return keys_equal and values_equal\n    else:\n        return True\n\n\nORDERABLE_TYPES = (NumType, BoolType, StrType, ListType, DayType, TimeType,\n                   SetType, TupleType)\nINDEXABLE_TYPES = (StrType, ListType, SetType, TupleType, DictType)\n", "src/lib/pedal/tifa/__init__.py": "\"\"\"\nPython Type Inferencer and Flow Analyzer (TIFA)\n\nTIFA uses a number of simplifications of the Python language.\n  * Variables cannot change type\n  * Variables cannot be deleted\n  * Complex types have to be homogenous\n  * No introspection or reflective characteristics\n  * No dunder methods\n  * No closures (maybe?)\n  * You cannot write a variable out of scope\n  * You cannot read a mutable variable out of scope\n  * No multiple inheritance\n\nAdditionally, it reads the following as issues:\n  * Cannot read a variable without having first written to it.\n  * Cannot rewrite a variable unless it has been read.\n\nImportant concepts:\n\n.. glossary::\n\n    Issue\n        A problematic situation in the submitted code that will be reported\n        but may not stop the execution. However, when an Issue occurs,\n        any results may be invalid.\n\n    Error\n        A situation in execution that terminates the program.\n\n    Name\n        A name of a variable\n\n    Scope\n        The context of a function, with its own namespaces. Represented\n        internally using numeric IDs (Scope IDs).\n\n    Scope Chain\n        A stack of scopes, with the innermost scope on top.\n\n    Fully Qualified Name\n        A string representation of a variable and its scope\n        chain, written using \"/\". For example: 0/1/4/my_variable_name\n\n    Path\n        A single path of execution through the control flow; every program\n        has at least one sequential path, but IFs, FORs, WHILEs, etc. can\n        cause multiple paths. Paths are represented using numeric IDs (Path\n        IDs).\n\n    State\n        Information about a Name that indicates things like the variable's\n        current type and whether that name has been read, set, or\n        overwritten.\n\n    Identifier\n        A wrapper around variables, used to hold their potential\n        non-existence (which is an Issue but not an Error).\n\n    Type\n        A symbolic representation of the variable's type.\n\n    Literal\n        Sometimes, we need a specialized representation of a literal value\n        to be passed around. This is particularly important for accessing\n        elements in an tuples.\n\n    Name Map\n        (Path x Fully Qualified Names) => States\n\"\"\"\n\nfrom pedal.tifa.tifa import Tifa\nfrom pedal.report import MAIN_REPORT\n\nNAME = 'TIFA'\nSHORT_DESCRIPTION = \"Finds common issues caused by students.\"\nDESCRIPTION = '''Python Type Inferencer and Flow Analyzer (TIFA)\n\nTifa traverses an AST to detect common issues made by students.\n'''\nREQUIRES = ['Source']\nOPTIONALS = []\n\n\ndef tifa_analysis(python_3=True, report=None):\n    \"\"\"\n    Perform the TIFA analysis and attach the results to the Report.\n\n    Args:\n        python_3 (bool): Whether to expect a Python3 formated file, or Python\n            2. This has slight nuance on certain AST elements.\n        report (:class:`Report`): The Report object to attach results to.\n            Defaults to :data:`MAIN_REPORT`.\n    \"\"\"\n    if report is None:\n        report = MAIN_REPORT\n    t = Tifa(python_3=python_3, report=report)\n    t.process_code(report['source']['code'])\n    return t\n\n\n__all__ = ['NAME', 'DESCRIPTION', 'SHORT_DESCRIPTION',\n           'REQUIRES', 'OPTIONALS',\n           'tifa_analysis', 'Tifa']\n", "src/lib/pedal/tifa/builtin_definitions.py": "from pedal.tifa.type_definitions import (UnknownType, FunctionType,\n                                         NumType, NoneType, BoolType,\n                                         TupleType, ListType, StrType,\n                                         FileType, DictType, ModuleType,\n                                         SetType, DayType, TimeType, ClassType,\n                                         LiteralNum)\n\ndef get_builtin_module(name):\n    if name == 'matplotlib':\n        return ModuleType('matplotlib',\n                          submodules={\n                              'pyplot': ModuleType('pyplot', fields={\n                                  'plot': FunctionType(name='plot', returns=NoneType()),\n                                  'hist': FunctionType(name='hist', returns=NoneType()),\n                                  'scatter': FunctionType(name='scatter', returns=NoneType()),\n                                  'show': FunctionType(name='show', returns=NoneType()),\n                                  'xlabel': FunctionType(name='xlabel', returns=NoneType()),\n                                  'ylabel': FunctionType(name='ylabel', returns=NoneType()),\n                                  'title': FunctionType(name='title', returns=NoneType()),\n                              })\n                          })\n    elif name == 'pprint':\n        return ModuleType('pprint',\n                          fields={\n                              'pprint': FunctionType(name='pprint', returns=NoneType())\n                          })\n    elif name == 'random':\n        return ModuleType('random',\n                          fields={\n                              'randint': FunctionType(name='randint', returns=NumType())\n                          })\n    elif name == 'string':\n        return ModuleType('string',\n                          fields={\n                              'letters': StrType(empty=False),\n                              'digits': StrType(empty=False),\n                              'ascii_letters': StrType(empty=False),\n                              'punctuation': StrType(empty=False),\n                              'printable': StrType(empty=False),\n                              'whitespace': StrType(empty=False),\n                              'ascii_uppercase': StrType(empty=False),\n                              'ascii_lowercase': StrType(empty=False),\n                              'hexdigits': StrType(empty=False),\n                              'octdigits': StrType(empty=False),\n                          })\n    elif name == 'turtle':\n        return ModuleType('turtle',\n                          fields={\n                              'forward': FunctionType(name='forward', returns=NoneType()),\n                              'backward': FunctionType(name='backward', returns=NoneType()),\n                              'color': FunctionType(name='color', returns=NoneType()),\n                              'right': FunctionType(name='right', returns=NoneType()),\n                              'left': FunctionType(name='left', returns=NoneType()),\n                          })\n    elif name == 'parking':\n        return ModuleType('parking',\n                          fields={\n                              'Time': FunctionType(name='Time', returns=TimeType()),\n                              'now': FunctionType(name='now', returns=TimeType()),\n                              'Day': FunctionType(name='Day', returns=DayType()),\n                              'today': FunctionType(name='today', returns=DayType()),\n                          }),\n    elif name == 'math':\n        return ModuleType('math',\n                          fields={\n                              'ceil': FunctionType(name='ceil', returns=NumType()),\n                              'copysign': FunctionType(name='copysign', returns=NumType()),\n                              'fabs': FunctionType(name='fabs', returns=NumType()),\n                              'factorial': FunctionType(name='factorial', returns=NumType()),\n                              'floor': FunctionType(name='floor', returns=NumType()),\n                              'fmod': FunctionType(name='fmod', returns=NumType()),\n                              'frexp': FunctionType(name='frexp', returns=NumType()),\n                              'fsum': FunctionType(name='fsum', returns=NumType()),\n                              'gcd': FunctionType(name='gcd', returns=NumType()),\n                              'isclose': FunctionType(name='isclose', returns=BoolType()),\n                              'isfinite': FunctionType(name='isfinite', returns=BoolType()),\n                              'isinf': FunctionType(name='isinf', returns=BoolType()),\n                              'isnan': FunctionType(name='isnan', returns=BoolType()),\n                              'ldexp': FunctionType(name='ldexp', returns=NumType()),\n                              'modf': FunctionType(name='modf', returns=NumType()),\n                              'trunc': FunctionType(name='trunc', returns=NumType()),\n                              'log': FunctionType(name='log', returns=NumType()),\n                              'log1p': FunctionType(name='log1p', returns=NumType()),\n                              'log2': FunctionType(name='log2', returns=NumType()),\n                              'log10': FunctionType(name='log10', returns=NumType()),\n                              'pow': FunctionType(name='pow', returns=NumType()),\n                              'sqrt': FunctionType(name='sqrt', returns=NumType()),\n                              'sin': FunctionType(name='sin', returns=NumType()),\n                              'cos': FunctionType(name='cos', returns=NumType()),\n                              'tan': FunctionType(name='tan', returns=NumType()),\n                              'asin': FunctionType(name='asin', returns=NumType()),\n                              'acos': FunctionType(name='acos', returns=NumType()),\n                              'atan': FunctionType(name='atan', returns=NumType()),\n                              'atan2': FunctionType(name='atan2', returns=NumType()),\n                              'hypot': FunctionType(name='hypot', returns=NumType()),\n                              'degrees': FunctionType(name='degrees', returns=NumType()),\n                              'radians': FunctionType(name='radians', returns=NumType()),\n                              'sinh': FunctionType(name='sinh', returns=NumType()),\n                              'cosh': FunctionType(name='cosh', returns=NumType()),\n                              'tanh': FunctionType(name='tanh', returns=NumType()),\n                              'asinh': FunctionType(name='asinh', returns=NumType()),\n                              'acosh': FunctionType(name='acosh', returns=NumType()),\n                              'atanh': FunctionType(name='atanh', returns=NumType()),\n                              'erf': FunctionType(name='erf', returns=NumType()),\n                              'erfc': FunctionType(name='erfc', returns=NumType()),\n                              'gamma': FunctionType(name='gamma', returns=NumType()),\n                              'lgamma': FunctionType(name='lgamma', returns=NumType()),\n                              'pi': NumType(),\n                              'e': NumType(),\n                              'tau': NumType(),\n                              'inf': NumType(),\n                              'nan': NumType(),\n                          })\n\n\ndef _builtin_sequence_constructor(sequence_type):\n    \"\"\"\n    Helper function for creating constructors for the Set and List types.\n    These constructors use the subtype of the arguments.\n\n    Args:\n        sequence_type (Type): A function for creating new sequence types.\n    \"\"\"\n\n    def sequence_call(tifa, function_type, callee, args, position):\n        # TODO: Should inherit the emptiness too\n        return_type = sequence_type(empty=True)\n        if args:\n            return_type.subtype = args[0].index(LiteralNum(0))\n            return_type.empty = False\n        return return_type\n\n    return sequence_call\n\n\ndef _builtin_zip(tifa, function_type, callee, args, position):\n    \"\"\"\n    Definition of the built-in zip function, which consumes a series of\n    sequences and returns a list of tuples, with each tuple composed of the\n    elements of the sequence paired (or rather, tupled) together.\n    \"\"\"\n    if args:\n        tupled_types = TupleType(subtypes=[])\n        for arg in args:\n            tupled_types.append(arg.index(0))\n        return ListType(tupled_types, empty=False)\n    return ListType(empty=True)\n\n\ndef get_builtin_function(name):\n    # Void Functions\n    if name == \"print\":\n        return FunctionType(name=\"print\", returns=NoneType())\n    # Math Functions\n    elif name == \"int\":\n        return FunctionType(name=\"int\", returns=NumType())\n    elif name == \"abs\":\n        return FunctionType(name=\"abs\", returns=NumType())\n    elif name == \"float\":\n        return FunctionType(name=\"float\", returns=NumType())\n    elif name == \"len\":\n        return FunctionType(name=\"len\", returns=NumType())\n    elif name == \"ord\":\n        return FunctionType(name=\"ord\", returns=NumType())\n    elif name == \"pow\":\n        return FunctionType(name=\"pow\", returns=NumType())\n    elif name == \"round\":\n        return FunctionType(name=\"round\", returns=NumType())\n    elif name == \"sum\":\n        return FunctionType(name=\"sum\", returns=NumType())\n    # Boolean Functions\n    elif name == \"bool\":\n        return FunctionType(name=\"bool\", returns=BoolType())\n    elif name == \"all\":\n        return FunctionType(name=\"all\", returns=BoolType())\n    elif name == \"any\":\n        return FunctionType(name=\"any\", returns=BoolType())\n    elif name == \"isinstance\":\n        return FunctionType(name=\"isinstance\", returns=BoolType())\n    # String Functions\n    elif name == \"input\":\n        return FunctionType(name=\"input\", returns=StrType())\n    elif name == \"str\":\n        return FunctionType(name=\"str\", returns=StrType())\n    elif name == \"chr\":\n        return FunctionType(name=\"chr\", returns=StrType())\n    elif name == \"repr\":\n        return FunctionType(name=\"repr\", returns=StrType())\n    # File Functions\n    elif name == \"open\":\n        return FunctionType(name=\"open\", returns=FileType())\n    # List Functions\n    elif name == \"map\":\n        return FunctionType(name=\"map\", returns=ListType(empty=False))\n    elif name == \"list\":\n        return FunctionType(name=\"list\",\n                            definition=_builtin_sequence_constructor(ListType))\n    # Set Functions\n    elif name == \"set\":\n        return FunctionType(name=\"set\",\n                            definition=_builtin_sequence_constructor(SetType))\n    # Dict Functions\n    elif name == \"dict\":\n        return FunctionType(name=\"dict\", returns=DictType())\n    # Pass through\n    elif name == \"sorted\":\n        return FunctionType(name=\"sorted\", returns='identity')\n    elif name == \"reversed\":\n        return FunctionType(name=\"reversed\", returns='identity')\n    elif name == \"filter\":\n        return FunctionType(name=\"filter\", returns='identity')\n    # Special Functions\n    elif name == \"type\":\n        return FunctionType(name=\"type\", returns=UnknownType())\n    elif name == \"range\":\n        return FunctionType(name=\"range\", returns=ListType(NumType(), empty=False))\n    elif name == \"dir\":\n        return FunctionType(name=\"dir\", returns=ListType(StrType(), empty=False))\n    elif name == \"max\":\n        return FunctionType(name=\"max\", returns='element')\n    elif name == \"min\":\n        return FunctionType(name=\"min\", returns='element')\n    elif name == \"zip\":\n        return FunctionType(name=\"zip\", returns=_builtin_zip)\n    elif name == \"__import__\":\n        return FunctionType(name=\"__import__\", returns=ModuleType())\n    elif name == \"globals\":\n        return FunctionType(name=\"globals\",\n                            returns=DictType(keys=StrType(),\n                                             values=UnknownType(),\n                                             empty=False))\n", "src/lib/pedal/tifa/type_definitions.py": "def are_literals_equal(first, second):\n    if first is None or second is None:\n        return False\n    elif not isinstance(first, type(second)):\n        return False\n    else:\n        if isinstance(first, LiteralTuple):\n            if len(first.value) != len(second.value):\n                return False\n            for l, s in zip(first.value, second.value):\n                if not are_literals_equal(l, s):\n                    return False\n            return True\n        elif not isinstance(first, LiteralValue):\n            return True\n        else:\n            return first.value == second.value\n\n\nclass LiteralValue:\n    \"\"\"\n    A special literal representation of a value, used to represent access on\n    certain container types.\n    \"\"\"\n\n    def __init__(self, value):\n        self.value = value\n\n\nclass LiteralNum(LiteralValue):\n    \"\"\"\n    Used to capture indexes of containers.\n    \"\"\"\n\n    def type(self):\n        return NumType()\n\n\nclass LiteralBool(LiteralValue):\n    def type(self):\n        return BoolType()\n\n\nclass LiteralStr(LiteralValue):\n    def type(self):\n        return StrType()\n\n\nclass LiteralTuple(LiteralValue):\n    def type(self):\n        return TupleType(self.value)\n\n\nclass LiteralNone(LiteralValue):\n    def type(self):\n        return LiteralNone()\n\n\ndef literal_from_json(val):\n    if val['type'] == 'LiteralStr':\n        return LiteralStr(val['value'])\n    elif val['type'] == 'LiteralNum':\n        return LiteralNum(val['value'])\n    elif val['type'] == 'LiteralBool':\n        return LiteralBool(val['value'])\n\n\ndef _dict_extends(d1, d2):\n    \"\"\"\n    Helper function to create a new dictionary with the contents of the two\n    given dictionaries. Does not modify either dictionary, and the values are\n    copied shallowly. If there are repeates, the second dictionary wins ties.\n\n    The function is written to ensure Skulpt compatibility.\n\n    Args:\n        d1 (dict): The first dictionary\n        d2 (dict): The second dictionary\n    \"\"\"\n    d3 = {}\n    for key, value in d1.items():\n        d3[key] = value\n    for key, value in d2.items():\n        d3[key] = value\n    return d3\n\n\nclass Type:\n    \"\"\"\n    Parent class for all other types, used to provide a common interface.\n\n    TODO: Handle more complicated object-oriented types and custom types\n    (classes).\n    \"\"\"\n    fields = {}\n    immutable = False\n    singular_name = 'a type'\n\n    def clone(self):\n        return self.__class__()\n\n    def __str__(self):\n        return str(self.__class__.__name__)\n\n    def clone_mutably(self):\n        if self.immutable:\n            return self.clone()\n        else:\n            return self\n\n    def index(self, i):\n        return self.clone()\n\n    def load_attr(self, attr, tifa, callee=None, callee_position=None):\n        if attr in self.fields:\n            return self.fields[attr]\n        # TODO: Handle more kinds of common mistakes\n        if attr == \"append\":\n            tifa.report_issue('Append to non-list',\n                              {'name': tifa.identify_caller(callee),\n                               'position': callee_position, 'type': self})\n        return UnknownType()\n\n    def is_empty(self):\n        return True\n\n    def is_equal(self, other):\n        # TODO: Make this more sophisticated!\n        if type(self) not in TYPE_LOOKUPS:\n            return False\n        return other in TYPE_LOOKUPS[type(self)]\n\n    def is_instance(self, other):\n        # TODO: Implement this correctly\n        return self.is_equal(other)\n\n\nclass UnknownType(Type):\n    \"\"\"\n    A special type used to indicate an unknowable type.\n    \"\"\"\n\n\nclass RecursedType(Type):\n    \"\"\"\n    A special type used as a placeholder for the result of a\n    recursive call that we have already process. This type will\n    be dominated by any actual types, but will not cause an issue.\n    \"\"\"\n\n\nclass FunctionType(Type):\n    \"\"\"\n    \n    Special values for `returns`:\n        identity: Returns the first argument's type\n        element: Returns the first argument's first element's type\n        void: Returns the NoneType\n    \"\"\"\n    singular_name = 'a function'\n\n    def __init__(self, definition=None, name=\"*Anonymous\", returns=None):\n        if returns is not None and definition is None:\n            if returns == 'identity':\n                def definition(ti, ty, na, args, ca):\n                    if args:\n                        return args[0].clone()\n                    return UnknownType()\n            elif returns == 'element':\n                def definition(ti, ty, na, args, ca):\n                    if args:\n                        return args[0].index(0)\n                    return UnknownType()\n            elif returns == 'void':\n                def definition(ti, ty, na, args, ca):\n                    return NoneType()\n            else:\n                def definition(ti, ty, na, args, ca):\n                    return returns.clone()\n        self.definition = definition\n        self.name = name\n\n\nclass ClassType(Type):\n    singular_name = 'a class'\n\n    def __init__(self, name):\n        self.name = name\n        self.fields = {}\n        self.scope_id = None\n\n    def add_attr(self, name, type):\n        self.fields[name] = type\n\n    def get_constructor(self):\n        i = InstanceType(self)\n        return FunctionType(name='__init__', returns=i)\n\n    def clone(self):\n        return ClassType(self.name)\n\n\nclass InstanceType(Type):\n    def __init__(self, parent):\n        self.parent = parent\n        self.fields = parent.fields\n\n    def __str__(self):\n        return \"InstanceTypeOf\" + str(self.parent.name)\n\n    def clone(self):\n        return InstanceType(self.parent)\n\n    def add_attr(self, name, type):\n        # TODO: What if this is a type change?\n        self.parent.add_attr(name, type)\n\n\nclass NumType(Type):\n    singular_name = 'a number'\n    immutable = True\n\n    def index(self, i):\n        return UnknownType()\n\n\nclass NoneType(Type):\n    singular_name = 'a None'\n    immutable = True\n\n\nclass BoolType(Type):\n    singular_name = 'a boolean'\n    immutable = True\n\n\nclass TupleType(Type):\n    \"\"\"\n    \"\"\"\n    singular_name = 'a tuple'\n\n    def __init__(self, subtypes=None):\n        if subtypes is None:\n            subtypes = []\n        self.subtypes = subtypes\n\n    def index(self, i):\n        if isinstance(i, LiteralNum):\n            return self.subtypes[i.value].clone()\n        else:\n            return self.subtypes[i].clone()\n\n    def clone(self):\n        return TupleType([t.clone() for t in self.subtypes])\n\n    immutable = True\n\n\nclass ListType(Type):\n    singular_name = 'a list'\n\n    def __init__(self, subtype=None, empty=True):\n        if subtype is None:\n            subtype = UnknownType()\n        self.subtype = subtype\n        self.empty = empty\n\n    def index(self, i):\n        return self.subtype.clone()\n\n    def clone(self):\n        return ListType(self.subtype.clone(), self.empty)\n\n    def load_attr(self, attr, tifa, callee=None, callee_position=None):\n        if attr == 'append':\n            def _append(tifa, function_type, callee, args, position):\n                if args:\n                    cloned_type = ListType(subtype=args[0].clone(),\n                                           empty=False)\n                    if callee:\n                        tifa.append_variable(callee, cloned_type, position)\n                    self.empty = False\n                    self.subtype = args[0]\n\n            return FunctionType(_append, 'append')\n        return Type.load_attr(self, attr, tifa, callee, callee_position)\n\n    def is_empty(self):\n        return self.empty\n\n\nclass StrType(Type):\n    singular_name = 'a string'\n\n    def __init__(self, empty=False):\n        self.empty = empty\n\n    def index(self, i):\n        return StrType()\n\n    def is_empty(self):\n        return self.empty\n\n    fields = _dict_extends(Type.fields, {})\n    immutable = True\n\n\nStrType.fields.update({\n    # Methods that return strings\n    \"capitalize\": FunctionType(name='capitalize', returns=StrType()),\n    \"center\": FunctionType(name='center', returns=StrType()),\n    \"expandtabs\": FunctionType(name='expandtabs', returns=StrType()),\n    \"join\": FunctionType(name='join', returns=StrType()),\n    \"ljust\": FunctionType(name='ljust', returns=StrType()),\n    \"lower\": FunctionType(name='lower', returns=StrType()),\n    \"lstrip\": FunctionType(name='lstrip', returns=StrType()),\n    \"replace\": FunctionType(name='replace', returns=StrType()),\n    \"rjust\": FunctionType(name='rjust', returns=StrType()),\n    \"rstrip\": FunctionType(name='rstrip', returns=StrType()),\n    \"strip\": FunctionType(name='strip', returns=StrType()),\n    \"swapcase\": FunctionType(name='swapcase', returns=StrType()),\n    \"title\": FunctionType(name='title', returns=StrType()),\n    \"translate\": FunctionType(name='translate', returns=StrType()),\n    \"upper\": FunctionType(name='upper', returns=StrType()),\n    \"zfill\": FunctionType(name='zfill', returns=StrType()),\n    # Methods that return numbers\n    \"count\": FunctionType(name='count', returns=NumType()),\n    \"find\": FunctionType(name='find', returns=NumType()),\n    \"rfind\": FunctionType(name='rfind', returns=NumType()),\n    \"index\": FunctionType(name='index', returns=NumType()),\n    \"rindex\": FunctionType(name='rindex', returns=NumType()),\n    # Methods that return booleans\n    \"startswith\": FunctionType(name='startswith', returns=BoolType()),\n    \"endswith\": FunctionType(name='endswith', returns=BoolType()),\n    \"isalnum\": FunctionType(name='isalnum', returns=BoolType()),\n    \"isalpha\": FunctionType(name='isalpha', returns=BoolType()),\n    \"isdigit\": FunctionType(name='isdigit', returns=BoolType()),\n    \"islower\": FunctionType(name='islower', returns=BoolType()),\n    \"isspace\": FunctionType(name='isspace', returns=BoolType()),\n    \"istitle\": FunctionType(name='istitle', returns=BoolType()),\n    \"isupper\": FunctionType(name='isupper', returns=BoolType()),\n    # Methods that return List of Strings\n    \"rsplit\": FunctionType(name='rsplit', returns=ListType(StrType(), empty=False)),\n    \"split\": FunctionType(name='split', returns=ListType(StrType(), empty=False)),\n    \"splitlines\": FunctionType(name='splitlines', returns=ListType(StrType(), empty=False))\n})\n\n\nclass FileType(Type):\n    singular_name = 'a file'\n\n    def index(self, i):\n        return StrType()\n\n    fields = _dict_extends(Type.fields, {\n        'close': FunctionType(name='close', returns='void'),\n        'read': FunctionType(name='read', returns=StrType()),\n        'readlines': FunctionType(name='readlines', returns=ListType(StrType(), False))\n    })\n\n    def is_empty(self):\n        return False\n\n\nclass DictType(Type):\n    singular_name = 'a dictionary'\n\n    def __init__(self, empty=False, literals=None, keys=None, values=None):\n        self.empty = empty\n        self.literals = literals\n        self.values = values\n        self.keys = keys\n\n    def clone(self):\n        return DictType(self.empty, self.literals, self.keys, self.values)\n\n    def is_empty(self):\n        return self.empty\n\n    def index(self, i):\n        if self.empty:\n            return UnknownType()\n        elif self.literals is not None:\n            for literal, value in zip(self.literals, self.values):\n                if are_literals_equal(literal, i):\n                    return value.clone()\n            return UnknownType()\n        else:\n            return self.keys.clone()\n\n    def load_attr(self, attr, tifa, callee=None, callee_position=None):\n        if attr == 'items':\n            def _items(tifa, function_type, callee, args, position):\n                if self.literals is None:\n                    return ListType(TupleType([self.keys, self.values]),\n                                    empty=False)\n                else:\n                    return ListType(TupleType([self.literals[0].type(),\n                                               self.values[0]]),\n                                    empty=False)\n\n            return FunctionType(_items, 'items')\n        elif attr == 'keys':\n            def _keys(tifa, function_type, callee, args, position):\n                if self.literals is None:\n                    return ListType(self.keys, empty=False)\n                else:\n                    return ListType(self.literals[0].type(), empty=False)\n\n            return FunctionType(_keys, 'keys')\n        elif attr == 'values':\n            def _values(tifa, function_type, callee, args, position):\n                if self.literals is None:\n                    return ListType(self.values, empty=False)\n                else:\n                    return ListType(self.values[0], empty=False)\n\n            return FunctionType(_values, 'values')\n        return Type.load_attr(self, attr, tifa, callee, callee_position)\n\n\nclass ModuleType(Type):\n    singular_name = 'a module'\n\n    def __init__(self, name=\"*UnknownModule\", submodules=None, fields=None):\n        self.name = name\n        if submodules is None:\n            submodules = {}\n        self.submodules = submodules\n        if fields is None:\n            fields = {}\n        self.fields = fields\n\n\nclass SetType(ListType):\n    singular_name = 'a set'\n\n\nclass GeneratorType(ListType):\n    singular_name = 'a generator'\n\n\n# Custom parking class in blockpy\n\nclass TimeType(Type):\n    singular_name = 'a time of day'\n\n\nclass DayType(Type):\n    singular_name = 'a day of the week'\n\n\ntry:\n    from numbers import Number\nexcept Exception:\n    Number = int\n\nTYPE_LOOKUPS = {\n    FunctionType: ('function', FunctionType, 'FunctionType'),\n    ClassType: ('class', ClassType, 'ClassType'),\n    InstanceType: ('instance', InstanceType, 'InstanceType'),\n    NumType: ('num', int, float, complex, NumType, Number, 'NumType'),\n    BoolType: ('bool', bool, BoolType, 'BoolType'),\n    NoneType: ('None', None, NoneType, 'NoneType'),\n    TupleType: ('tuple', tuple, TupleType, 'TupleType'),\n    ListType: ('list', list, ListType, 'ListType'),\n    StrType: ('str', str, StrType, 'StrType'),\n    FileType: ('file', FileType, 'FileType'),\n    DictType: ('dict', dict, DictType, 'DictType'),\n    SetType: ('set', set, SetType, 'SetType'),\n}\n\n\ndef type_from_json(val):\n    if val['type'] == 'DictType':\n        values = [type_from_json(v) for v in val['values']]\n        empty = val.get('empty', None)\n        if 'literals' in val:\n            literals = [literal_from_json(l) for l in val['literals']]\n            return DictType(empty, literals=literals, values=values)\n        else:\n            keys = [type_from_json(k) for k in val['keys']]\n            return DictType(empty, keys=keys, values=values)\n    elif val['type'] == 'ListType':\n        return ListType(type_from_json(val.get('subtype', None)),\n                        val.get('empty', None))\n    elif val['type'] == 'StrType':\n        return StrType(val.get('empty', None))\n    elif val['type'] == 'BoolType':\n        return BoolType()\n    elif val['type'] == 'NoneType':\n        return NoneType()\n    elif val['type'] == 'NumType':\n        return NumType()\n    elif val['type'] == 'ModuleType':\n        submodules = {name: type_from_json(m)\n                      for name, m in val.get('submodules', {}).items()}\n        fields = {name: type_from_json(m)\n                  for name, m in val.get('fields', {}).items()}\n        return ModuleType(name=val.get('name'), submodules=submodules,\n                          fields=fields)\n    elif val['type'] == 'FunctionType':\n        returns = type_from_json(val.get('returns', {'type': 'NoneType'}))\n        return FunctionType(name=val.get('name'), returns=returns)\n\n\ndef type_to_literal(type):\n    if isinstance(type, NumType):\n        return LiteralNum(0)\n    elif isinstance(type, StrType):\n        return LiteralStr(\"\")\n    else:\n        # TODO: Finish the mapping\n        return LiteralStr(\"\")\n", "src/lib/pedal/tifa/messages.py": "import ast\n\nOPERATION_DESCRIPTION = {\n    ast.Pow: \"an exponent\",\n    ast.Add: \"an addition\",\n    ast.Mult: \"a multiplication\",\n    ast.Sub: \"a subtraction\",\n    ast.Div: \"a division\",\n    ast.FloorDiv: \"a division\",\n    ast.Mod: \"a modulo\",\n    ast.LShift: \"a left shift\",\n    ast.RShift: \"a right shift\",\n    ast.BitOr: \"a bit or\",\n    ast.BitAnd: \"a bit and\",\n    ast.BitXor: \"a bit xor\",\n    ast.And: \"an and\",\n    ast.Or: \"an or\",\n    ast.Eq: \"an ==\",\n    ast.NotEq: \"a !=\",\n    ast.Lt: \"a <\",\n    ast.LtE: \"a <=\",\n    ast.Gt: \"a >\",\n    ast.GtE: \"a >=\",\n    ast.Is: \"an is\",\n    ast.IsNot: \"an is not\",\n    ast.In: \"an in\",\n    ast.NotIn: \"an not in\",\n}\n\n\ndef _format_message(issue, data):\n    if issue == 'Action after return':\n        # A path had a statement after a return.\n        return (\"You performed an action after already returning from a \"\n                \"function, on line {line}. You can only return on a path \"\n                \"once.\").format(line=data['position']['line'])\n    elif issue == 'Return outside function':\n        # Attempted to return outside of a function\n        return (\"You attempted to return outside of a function on line {line}.\"\n                \" But you can only return from within a function.\"\n                ).format(line=data['position']['line'])\n    elif issue == 'Write out of scope':\n        # DEPRECATED\n        # Attempted to modify a variable in a higher scope\n        return False\n        return (\"You attempted to write a variable from a higher scope \"\n                \"(outside the function) on line {line}. You should only \"\n                \"use variables inside the function they were declared in.\"\n                ).format(line=data['position']['line'])\n    elif issue == 'Unconnected blocks':\n        # Any names with ____\n        return (\"It looks like you have unconnected blocks on line {line}. \"\n                \"Before you run your program, you must make sure that all \"\n                \"of your blocks are connected that there are no unfilled \"\n                \"holes.\").format(line=data['position']['line'])\n    elif issue == 'Iteration Problem':\n        # Iteration list is the iteration variable\n        return (\"The variable <code>{name}</code> was iterated on line \"\n                \"{line} but you used the same variable as the iteration \"\n                \"variable. You should choose a different variable name \"\n                \"for the iteration variable. Usually, the iteration variable \"\n                \"is the singular form of the iteration list (e.g., \"\n                \"<code>for a_dog in dogs:</code>).\").format(\n            line=data['position']['line'],\n            name=data['name'])\n    elif issue == 'Initialization Problem':\n        # A variable was read before it was defined\n        return (\"The variable <code>{name}</code> was used on line {line}, \"\n                \"but it was not given a value on a previous line. \"\n                \"You cannot use a variable until it has been given a value.\"\n                ).format(line=data['position']['line'], name=data['name'])\n    elif issue == 'Possible Initialization Problem':\n        # A variable was read but was not defined in every branch\n        if data['name'] == '*return':\n            return False\n        return (\"The variable <code>{name}</code> was used on line {line}, \"\n                \"but it was possibly not given a value on a previous \"\n                \"line. You cannot use a variable until it has been given \"\n                \"a value. Check to make sure that this variable was \"\n                \"declared in all of the branches of your decision.\"\n                ).format(line=data['position']['line'], name=data['name'])\n    elif issue == 'Unused Variable':\n        # A variable was not read after it was defined\n        name = data['name']\n        if data['type'].is_equal('function'):\n            kind = 'function'\n            body = 'definition'\n        else:\n            kind = 'variable'\n            body = 'value'\n        return (\"The {kind} <code>{name}</code> was given a {body}, but \"\n                \"was never used after that.\"\n                ).format(name=name, kind=kind, body=body)\n    elif issue == 'Overwritten Variable':\n        return (\"The variable <code>{name}</code> was given a value, but \"\n                \"<code>{name}</code> was changed on line {line} before it \"\n                \"was used. One of the times that you gave <code>{name}</code> \"\n                \"a value was incorrect.\"\n                ).format(line=data['position']['line'], name=data['name'])\n    elif issue == 'Iterating over non-list':\n        if 'name' not in data or data['name'] is None:\n            expression = \"expression\"\n        else:\n            expression = \"variable <code>{}</code>\".format(data['name'])\n        return (\"The {expression} is not a list, but you used \"\n                \"it in the iteration on line {line}. You should only iterate \"\n                \"over sequences like lists.\"\n                ).format(line=data['position']['line'], expression=expression)\n    elif issue == 'Iterating over empty list':\n        if 'name' not in data or data['name'] is None:\n            expression = \"expression\"\n        else:\n            expression = \"variable <code>{}</code>\".format(data['name'])\n        return (\"The {expression} was set as an empty list, \"\n                \"and then you attempted to use it in an iteration on line \"\n                \"{line}. You should only iterate over non-empty lists.\"\n                ).format(line=data['position']['line'], expression=expression)\n    elif issue == 'Incompatible types':\n        op = OPERATION_DESCRIPTION.get(data['operation'].__class__,\n                                       str(data['operation']))\n        left = data['left'].singular_name\n        right = data['right'].singular_name\n        line = data['position']['line']\n        return (\"You used {op} operation with {left} and {right} on line \"\n                \"{line}. But you can't do that with that operator. Make \"\n                \"sure both sides of the operator are the right type.\"\n                ).format(op=op, left=left, right=right, line=line)\n    elif issue == 'Read out of scope':\n        return (\"You attempted to read a variable from a different scope on \"\n                \"line {line}. You should only use variables inside the \"\n                \"function they were declared in.\"\n                ).format(line=data['position']['line'])\n    return False\n\n\n'''\nTODO: Finish these checks\n\"Empty Body\": [], # Any use of pass on its own\n\"Malformed Conditional\": [], # An if/else with empty else or if\n\"Unnecessary Pass\": [], # Any use of pass\n\"Append to non-list\": [], # Attempted to use the append method on a non-list\n\"Used iteration list\": [], #\n\"Unused iteration variable\": [], #\n\"Type changes\": [], #\n\"Unknown functions\": [], #\n\"Not a function\": [], # Attempt to call non-function as function\n\"Recursive Call\": [],\n\"Incorrect Arity\": [],\n\"Aliased built-in\": [], #\n\"Method not in Type\": [], # A method was used that didn't exist for that type\n\"Submodule not found\": [],\n\"Module not found\": [],\n\"Else on loop body\": [], # Used an Else on a For or While\n'''\n", "src/lib/pedal/tifa/tifa.py": "import ast\nfrom pprint import pprint\n\nfrom pedal.report import MAIN_REPORT\n\nfrom pedal.tifa.type_definitions import (UnknownType, RecursedType,\n                                         FunctionType, ClassType, InstanceType,\n                                         NumType, NoneType, BoolType, TupleType,\n                                         ListType, StrType, GeneratorType,\n                                         DictType, ModuleType, SetType,\n                                         # FileType, DayType, TimeType,\n                                         type_from_json, type_to_literal,\n                                         LiteralNum, LiteralBool,\n                                         LiteralNone, LiteralStr,\n                                         LiteralTuple)\nfrom pedal.tifa.builtin_definitions import (get_builtin_module, get_builtin_function)\nfrom pedal.tifa.type_operations import (merge_types, are_types_equal,\n                                        VALID_UNARYOP_TYPES, VALID_BINOP_TYPES,\n                                        ORDERABLE_TYPES, INDEXABLE_TYPES)\nfrom pedal.tifa.identifier import Identifier\nfrom pedal.tifa.state import State\nfrom pedal.tifa.messages import _format_message\n\n__all__ = ['Tifa']\n\n\nclass Tifa(ast.NodeVisitor):\n    \"\"\"\n    TIFA Class for traversing an AST and finding common issues.\n\n    Args:\n        python_3 (bool): Whether to parse the code in regular PYTHON_3 mode or\n                         the modified AST that Skulpt uses.\n        report (Report): The report object to store data and feedback in. If\n                         left None, defaults to the global MAIN_REPORT.\n    \"\"\"\n\n    def __init__(self, python_3=True, report=None):\n        if report is None:\n            report = MAIN_REPORT\n        self.report = report\n        self._initialize_report()\n        self.PYTHON_3 = python_3\n\n    def _initialize_report(self):\n        \"\"\"\n        Initialize a successful report with possible set of issues.\n        \"\"\"\n        self.report['tifa'] = {\n            'success': True,\n            'variables': {},\n            'top_level_variables': {},\n            'issues': {}\n        }\n\n    def report_issue(self, issue, data=None):\n        \"\"\"\n        Report the given issue with associated metadata, including the position\n        if not explicitly included.\n        \"\"\"\n        if data is None:\n            data = {}\n        if 'position' not in data:\n            data['position'] = self.locate()\n        data['message'] = _format_message(issue, data)\n        if issue not in self.report['tifa']['issues']:\n            self.report['tifa']['issues'][issue] = []\n        self.report['tifa']['issues'][issue].append(data)\n        if data['message']:\n            self.report.attach(issue, category='Analyzer', tool='TIFA',\n                               mistake=data)\n\n    def locate(self, node=None):\n        \"\"\"\n        Return a dictionary representing the current location within the\n        AST.\n\n        Returns:\n            Position dict: A dictionary with the fields 'column' and 'line',\n                           indicating the current position in the source code.\n        \"\"\"\n        if node is None:\n            if self.node_chain:\n                node = self.node_chain[-1]\n            else:\n                node = self.final_node\n        return {'column': node.col_offset, 'line': node.lineno}\n\n    def process_code(self, code, filename=\"__main__\"):\n        \"\"\"\n        Processes the AST of the given source code to generate a report.\n\n        Args:\n            code (str): The Python source code\n            filename (str): The filename of the source code (defaults to __main__)\n        Returns:\n            Report: The successful or successful report object\n        \"\"\"\n        # Code\n        self.source = code.split(\"\\n\") if code else []\n        filename = filename\n\n        # Attempt parsing - might fail!\n        try:\n            ast_tree = ast.parse(code, filename)\n        except Exception as error:\n            self.report['tifa']['success'] = False\n            self.report['tifa']['error'] = error\n            self.report.attach('tifa_error', category='Analyzer', tool='TIFA',\n                               mistake={\n                                   'message': \"Could not parse code\",\n                                   'error': error\n                               })\n            return self.report['tifa']\n        try:\n            return self.process_ast(ast_tree)\n        except Exception as error:\n            self.report['tifa']['success'] = False\n            self.report['tifa']['error'] = error\n            self.report.attach('tifa_error', category='Analyzer', tool='TIFA',\n                               mistake={\n                                   'message': \"Could not process code\",\n                                   'error': error\n                               })\n            return self.report['tifa']\n\n    def process_ast(self, ast_tree):\n        \"\"\"\n        Given an AST, actually performs the type and flow analyses to return a \n        report.\n\n        Args:\n            ast (Ast): The AST object\n        Returns:\n            Report: The final report object created (also available as a field).\n        \"\"\"\n        self._reset()\n        # Traverse every node\n        self.visit(ast_tree)\n\n        # Check afterwards\n        self.report['tifa']['variables'] = self.name_map\n        self._finish_scope()\n\n        # Collect top level variables\n        self._collect_top_level_variables()\n        # print(self.report['variables'])\n\n        return self.report['tifa']\n\n    def _collect_top_level_variables(self):\n        \"\"\"\n        Walk through the variables and add any at the top level to the\n        top_level_variables field of the report.\n        \"\"\"\n        top_level_variables = self.report['tifa']['top_level_variables']\n        main_path_vars = self.name_map[self.path_chain[0]]\n        for full_name in main_path_vars:\n            split_name = full_name.split(\"/\")\n            if len(split_name) == 2 and split_name[0] == str(self.scope_chain[0]):\n                name = split_name[1]\n                top_level_variables[name] = main_path_vars[full_name]\n\n    def _reset(self):\n        \"\"\"\n        Reinitialize fields for maintaining the system\n        \"\"\"\n        # Unique Global IDs\n        self.path_id = 0\n        self.scope_id = 0\n        self.ast_id = 0\n\n        # Human readable names\n        self.path_names = ['*Module']\n        self.scope_names = ['*Module']\n        self.node_chain = []\n\n        # Complete record of all Names\n        self.scope_chain = [self.scope_id]\n        self.path_chain = [self.path_id]\n        self.name_map = {}\n        self.name_map[self.path_id] = {}\n        self.definition_chain = []\n        self.path_parents = {}\n        self.final_node = None\n        self.class_scopes = {}\n\n    def find_variable_scope(self, name):\n        \"\"\"\n        Walk through this scope and all enclosing scopes, finding the relevant\n        identifier given by `name`.\n\n        Args:\n            name (str): The name of the variable\n        Returns:\n            Identifier: An Identifier for the variable, which could potentially\n                        not exist.\n        \"\"\"\n        for scope_level, scope in enumerate(self.scope_chain):\n            for path_id in self.path_chain:\n                path = self.name_map[path_id]\n                full_name = \"/\".join(map(str, self.scope_chain[scope_level:])) + \"/\" + name\n                if full_name in path:\n                    is_root_scope = (scope_level == 0)\n                    return Identifier(True, is_root_scope,\n                                      full_name, path[full_name])\n\n        return Identifier(False)\n\n    def find_variable_out_of_scope(self, name):\n        \"\"\"\n        Walk through every scope and determine if this variable can be found\n        elsewhere (which would be an issue).\n\n        Args:\n            name (str): The name of the variable\n        Returns:\n            Identifier: An Identifier for the variable, which could potentially\n                        not exist.\n        \"\"\"\n        for path in self.name_map.values():\n            for full_name in path:\n                unscoped_name = full_name.split(\"/\")[-1]\n                if name == unscoped_name:\n                    return Identifier(True, False, unscoped_name, path[full_name])\n        return Identifier(False)\n\n    def find_path_parent(self, path_id, name):\n        if name in self.name_map[path_id]:\n            return Identifier(True, state=self.name_map[path_id][name])\n        else:\n            path_parent = self.path_parents.get(path_id)\n            if path_parent is None:\n                return Identifier(False)\n            else:\n                return self.find_path_parent(path_parent, name)\n\n    def _finish_scope(self):\n        \"\"\"\n        Walk through all the variables present in this scope and ensure that\n        they have been read and not overwritten.\n        \"\"\"\n        path_id = self.path_chain[0]\n        for name in self.name_map[path_id]:\n            if Tifa.in_scope(name, self.scope_chain):\n                state = self.name_map[path_id][name]\n                if state.over == 'yes':\n                    position = state.over_position\n                    self.report_issue('Overwritten Variable',\n                                      {'name': state.name, 'position': position})\n                if state.read == 'no':\n                    self.report_issue('Unused Variable',\n                                      {'name': state.name, 'type': state.type,\n                                       'position': state.position})\n\n    def visit(self, node):\n        \"\"\"\n        Process this node by calling its appropriate visit_*\n\n        Args:\n            node (AST): The node to visit\n        Returns:\n            Type: The type calculated during the visit.\n        \"\"\"\n        # Start processing the node\n        self.node_chain.append(node)\n        self.ast_id += 1\n\n        # Actions after return?\n        if len(self.scope_chain) > 1:\n            return_state = self.find_variable_scope(\"*return\")\n            if return_state.exists and return_state.in_scope:\n                if return_state.state.set == \"yes\":\n                    self.report_issue(\"Action after return\")\n\n        # No? All good, let's enter the node\n        self.final_node = node\n        result = ast.NodeVisitor.visit(self, node)\n\n        # Pop the node out of the chain\n        self.ast_id -= 1\n        self.node_chain.pop()\n\n        # If a node failed to return something, return the UNKNOWN TYPE\n        if result is None:\n            return UnknownType()\n        else:\n            return result\n\n    def _visit_nodes(self, nodes):\n        \"\"\"\n        Visit all the nodes in the given list.\n\n        Args:\n            nodes (list): A list of values, of which any AST nodes will be\n                          visited.\n        \"\"\"\n        for node in nodes:\n            if isinstance(node, ast.AST):\n                self.visit(node)\n\n    def walk_targets(self, targets, type, walker):\n        \"\"\"\n        Iterate through the targets and call the given function on each one.\n\n        Args:\n            targets (list of Ast nodes): A list of potential targets to be\n                                         traversed.\n            type (Type): The given type to be unraveled and applied to the\n                         targets.\n            walker (Ast Node, Type -> None): A function that will process\n                                             each target and unravel the type.\n        \"\"\"\n        for target in targets:\n            walker(target, type)\n\n    def _walk_target(self, target, type):\n        \"\"\"\n        Recursively apply the type to the target\n\n        Args:\n            target (Ast): The current AST node to process\n            type (Type): The type to apply to this node\n        \"\"\"\n        if isinstance(target, ast.Name):\n            self.store_iter_variable(target.id, type, self.locate(target))\n            return target.id\n        elif isinstance(target, (ast.Tuple, ast.List)):\n            result = None\n            for i, elt in enumerate(target.elts):\n                elt_type = type.index(LiteralNum(i))\n                potential_name = self._walk_target(elt, elt_type)\n                if potential_name is not None and result is None:\n                    result = potential_name\n            return result\n\n    def visit_Assign(self, node):\n        \"\"\"\n        Simple assignment statement:\n        __targets__ = __value__\n\n        Args:\n            node (AST): An Assign node\n        Returns:\n            None\n        \"\"\"\n        # Handle value\n        value_type = self.visit(node.value)\n        # Handle targets\n        self._visit_nodes(node.targets)\n\n        # TODO: Properly handle assignments with subscripts\n        def action(target, type):\n            if isinstance(target, ast.Name):\n                self.store_variable(target.id, type)\n            elif isinstance(target, (ast.Tuple, ast.List)):\n                for i, elt in enumerate(target.elts):\n                    eltType = type.index(LiteralNum(i))\n                    action(elt, eltType)\n            elif isinstance(target, ast.Subscript):\n                pass\n            elif isinstance(target, ast.Attribute):\n                left_hand_type = self.visit(target.value)\n                if isinstance(left_hand_type, InstanceType):\n                    left_hand_type.add_attr(target.attr, type)\n                # TODO: Otherwise we attempted to assign to a non-instance\n                # TODO: Handle minor type changes (e.g., appending to an inner list)\n\n        self.walk_targets(node.targets, value_type, action)\n\n    def visit_AugAssign(self, node):\n        # Handle value\n        right = self.visit(node.value)\n        # Handle target\n        left = self.visit(node.target)\n        # Target is always a Name, Subscript, or Attribute\n        name = self.identify_caller(node.target)\n\n        # Handle operation\n        self.load_variable(name)\n        if isinstance(left, UnknownType) or isinstance(right, UnknownType):\n            return UnknownType()\n        elif type(node.op) in VALID_BINOP_TYPES:\n            op_lookup = VALID_BINOP_TYPES[type(node.op)]\n            if type(left) in op_lookup:\n                op_lookup = op_lookup[type(left)]\n                if type(right) in op_lookup:\n                    op_lookup = op_lookup[type(right)]\n                    result_type = op_lookup(left, right)\n                    self.store_variable(name, result_type)\n                    return result_type\n\n        self.report_issue(\"Incompatible types\",\n                          {\"left\": left, \"right\": right,\n                           \"operation\": node.op})\n\n    def visit_Attribute(self, node):\n        # Handle value\n        value_type = self.visit(node.value)\n        # Handle ctx\n        # TODO: Handling contexts\n        # Handle attr\n        return value_type.load_attr(node.attr, self, node.value, self.locate())\n\n    def visit_BinOp(self, node):\n        # Handle left and right\n        left = self.visit(node.left)\n        right = self.visit(node.right)\n\n        # Handle operation\n        if isinstance(left, UnknownType) or isinstance(right, UnknownType):\n            return UnknownType()\n        elif type(node.op) in VALID_BINOP_TYPES:\n            op_lookup = VALID_BINOP_TYPES[type(node.op)]\n            if type(left) in op_lookup:\n                op_lookup = op_lookup[type(left)]\n                if type(right) in op_lookup:\n                    op_lookup = op_lookup[type(right)]\n                    return op_lookup(left, right)\n\n        self.report_issue(\"Incompatible types\",\n                          {\"left\": left, \"right\": right,\n                           \"operation\": node.op})\n        return UnknownType()\n\n    def visit_Bool(self, node):\n        return BoolType()\n\n    def visit_BoolOp(self, node):\n        # Handle left and right\n        values = []\n        for value in node.values:\n            values.append(self.visit(value))\n\n        # TODO: Truthiness is not supported! Probably need a Union type\n        # TODO: Literals used as truthy value\n\n        # Handle operation\n        return BoolType()\n\n    def visit_Call(self, node):\n        # Handle func part (Name or Attribute)\n        function_type = self.visit(node.func)\n        # TODO: Need to grab the actual type in some situations\n        callee = self.identify_caller(node)\n\n        # Handle args\n        arguments = [self.visit(arg) for arg in node.args]\n\n        # TODO: Handle keywords\n        # TODO: Handle starargs\n        # TODO: Handle kwargs\n        if isinstance(function_type, FunctionType):\n            # Test if we have called this definition before\n            if function_type.definition not in self.definition_chain:\n                self.definition_chain.append(function_type.definition)\n                # Function invocation\n                result = function_type.definition(self, function_type, callee,\n                                                  arguments, self.locate())\n                self.definition_chain.pop()\n                return result\n            else:\n                self.report_issue(\"Recursive Call\", {\"name\": callee})\n        elif isinstance(function_type, ClassType):\n            constructor = function_type.get_constructor().definition\n            self.definition_chain.append(constructor)\n            result = constructor(self, constructor, callee, arguments, self.locate())\n            self.definition_chain.pop()\n            if '__init__' in function_type.fields:\n                initializer = function_type.fields['__init__']\n                if isinstance(initializer, FunctionType):\n                    self.definition_chain.append(initializer)\n                    initializer.definition(self, initializer, result, [result] + arguments, self.locate())\n                    self.definition_chain.pop()\n            return result\n        else:\n            self.report_issue(\"Not a function\", {\"name\": callee})\n        return UnknownType()\n\n    def visit_ClassDef(self, node):\n        class_name = node.name\n        new_class_type = ClassType(class_name)\n        self.store_variable(class_name, new_class_type)\n        # TODO: Define a new scope definition that executes the body\n        # TODO: find __init__, execute that\n        definitions_scope = self.scope_chain[:]\n        class_scope = Tifa.NewScope(self, definitions_scope, class_type=new_class_type)\n        with class_scope:\n            self.generic_visit(node)\n\n    def visit_Compare(self, node):\n        # Handle left and right\n        left = self.visit(node.left)\n        comparators = [self.visit(compare) for compare in node.comparators]\n\n        # Handle ops\n        for op, right in zip(node.ops, comparators):\n            if isinstance(op, (ast.Eq, ast.NotEq, ast.Is, ast.IsNot)):\n                continue\n            elif isinstance(op, (ast.Lt, ast.LtE, ast.GtE, ast.Gt)):\n                if are_types_equal(left, right):\n                    if isinstance(left, ORDERABLE_TYPES):\n                        continue\n            elif isinstance(op, (ast.In, ast.NotIn)):\n                if isinstance(right, INDEXABLE_TYPES):\n                    continue\n            self.report_issue(\"Incompatible types\",\n                              {\"left\": left, \"right\": right,\n                               \"operation\": op})\n        return BoolType()\n\n    def _visit_collection_loop(self, node):\n        # Handle the iteration list\n        iter = node.iter\n        iter_list_name = None\n        if isinstance(iter, ast.Name):\n            iter_list_name = iter.id\n            if iter_list_name == \"___\":\n                self.report_issue(\"Unconnected blocks\",\n                                  {\"position\": self.locate(iter)})\n            state = self.iterate_variable(iter_list_name, self.locate(iter))\n            iter_type = state.type\n        else:\n            iter_type = self.visit(iter)\n\n        if iter_type.is_empty():\n            self.report_issue(\"Iterating over empty list\",\n                              {\"name\": iter_list_name,\n                               \"position\": self.locate(iter)})\n\n        if not isinstance(iter_type, INDEXABLE_TYPES):\n            self.report_issue(\"Iterating over non-list\",\n                              {\"name\": iter_list_name,\n                               \"position\": self.locate(iter)})\n\n        iter_subtype = iter_type.index(LiteralNum(0))\n\n        # Handle the iteration variable\n        iter_variable_name = self._walk_target(node.target, iter_subtype)\n\n        if iter_variable_name and iter_list_name:\n            if iter_variable_name == iter_list_name:\n                self.report_issue(\"Iteration Problem\",\n                                  {\"name\": iter_variable_name,\n                                   \"position\": self.locate(node.target)})\n\n    def visit_comprehension(self, node):\n        self._visit_collection_loop(node)\n        # Handle the bodies\n        self.visit_statements(node.ifs)\n\n    def visit_Dict(self, node):\n        \"\"\"\n        Three types of dictionaries\n        - empty\n        - uniform type\n        - record\n        \"\"\"\n        type = DictType()\n        if not node.keys:\n            type.empty = True\n        else:\n            type.empty = False\n            all_literals = True\n            keys, values, literals = [], [], []\n            for key, value in zip(node.keys, node.values):\n                literal = self.get_literal(key)\n                key, value = self.visit(key), self.visit(value)\n                values.append(value)\n                keys.append(key)\n                if literal is not None:\n                    literals.append(literal)\n                else:\n                    all_literals = False\n\n            if all_literals:\n                type.literals = literals\n                type.values = values\n            else:\n                type.keys = key\n                type.values = value\n        return type\n\n    def visit_DictComp(self, node):\n        # TODO: Handle comprehension scope\n        for generator in node.generators:\n            self.visit(generator)\n        keys = self.visit(node.key)\n        values = self.visit(node.value)\n        return DictType(keys=keys, values=values)\n\n    def visit_For(self, node):\n        self._visit_collection_loop(node)\n        # Handle the bodies\n        self.visit_statements(node.body)\n        self.visit_statements(node.orelse)\n\n    def visit_FunctionDef(self, node):\n        # Name\n        function_name = node.name\n        position = self.locate()\n        definitions_scope = self.scope_chain[:]\n\n        def definition(tifa, call_type, call_name, parameters, call_position):\n            function_scope = Tifa.NewScope(self, definitions_scope)\n            with function_scope:\n                # Process arguments\n                args = node.args.args\n                if len(args) != len(parameters):\n                    self.report_issue('Incorrect Arity', {\"position\": position})\n                # TODO: Handle special types of parameters\n                for arg, parameter in zip(args, parameters):\n                    name = arg.arg if self.PYTHON_3 else arg.id\n                    if parameter is not None:\n                        parameter = parameter.clone_mutably()\n                        self.store_variable(name, parameter, position)\n                if len(args) < len(parameters):\n                    for undefined_parameter in parameters[len(args):]:\n                        self.store_variable(name, UnknownType(), position)\n                self.visit_statements(node.body)\n                return_state = self.find_variable_scope(\"*return\")\n                return_value = NoneType()\n                # If the pseudo variable exists, we load it and get its type\n                if return_state.exists and return_state.in_scope:\n                    return_state = self.load_variable(\"*return\", call_position)\n                    return_value = return_state.type\n            return return_value\n\n        function = FunctionType(definition=definition, name=function_name)\n        self.store_variable(function_name, function)\n        return function\n\n    def visit_GeneratorExp(self, node):\n        # TODO: Handle comprehension scope\n        for generator in node.generators:\n            self.visit(generator)\n        return GeneratorType(self.visit(node.elt))\n\n    def visit_If(self, node):\n        # Visit the conditional\n        self.visit(node.test)\n\n        if len(node.orelse) == 1 and isinstance(node.orelse[0], ast.Pass):\n            self.report_issue(\"Malformed Conditional\")\n        elif len(node.body) == 1 and isinstance(node.body[0], ast.Pass):\n            if node.orelse:\n                self.report_issue(\"Malformed Conditional\")\n\n        # Visit the bodies\n        this_path_id = self.path_chain[0]\n        if_path = Tifa.NewPath(self, this_path_id, \"i\")\n        with if_path:\n            for statement in node.body:\n                self.visit(statement)\n        else_path = Tifa.NewPath(self, this_path_id, \"e\")\n        with else_path:\n            for statement in node.orelse:\n                self.visit(statement)\n\n        # Combine two paths into one\n        # Check for any names that are on the IF path\n        self.merge_paths(this_path_id, if_path.id, else_path.id)\n\n    def visit_IfExp(self, node):\n        # Visit the conditional\n        self.visit(node.test)\n\n        # Visit the body\n        body = self.visit(node.body)\n\n        # Visit the orelse\n        orelse = self.visit(node.orelse)\n\n        if are_types_equal(body, orelse):\n            return body\n\n        # TODO: Union type?\n        return UnknownType()\n\n    def visit_Import(self, node):\n        # Handle names\n        for alias in node.names:\n            asname = alias.asname or alias.name\n            module_type = self.load_module(alias.name)\n            self.store_variable(asname, module_type)\n\n    def visit_ImportFrom(self, node):\n        # Handle names\n        for alias in node.names:\n            if node.module is None:\n                asname = alias.asname or alias.name\n                module_type = self.load_module(alias.name)\n            else:\n                module_name = node.module\n                asname = alias.asname or alias.name\n                module_type = self.load_module(module_name)\n            name_type = module_type.load_attr(alias.name, self,\n                                              callee_position=self.locate())\n            self.store_variable(asname, name_type)\n\n    def visit_Lambda(self, node):\n        # Name\n        position = self.locate()\n        definitions_scope = self.scope_chain[:]\n\n        def definition(tifa, call_type, call_name, parameters, call_position):\n            function_scope = Tifa.NewScope(self, definitions_scope)\n            with function_scope:\n                # Process arguments\n                args = node.args.args\n                if len(args) != len(parameters):\n                    self.report_issue('Incorrect Arity', {\"position\": position})\n                # TODO: Handle special types of parameters\n                for arg, parameter in zip(args, parameters):\n                    name = arg.arg if self.PYTHON_3 else arg.id\n                    if parameter is not None:\n                        parameter = parameter.clone_mutably()\n                        self.store_variable(name, parameter, position)\n                if len(args) < len(parameters):\n                    for undefined_parameter in parameters[len(args):]:\n                        self.store_variable(name, UnknownType(), position)\n                return_value = self.visit(node.body)\n            return return_value\n\n        return FunctionType(definition=definition)\n\n    def visit_List(self, node):\n        type = ListType()\n        if node.elts:\n            type.empty = False\n            # TODO: confirm homogenous subtype\n            for elt in node.elts:\n                type.subtype = self.visit(elt)\n        else:\n            type.empty = True\n        return type\n\n    def visit_ListComp(self, node):\n        # TODO: Handle comprehension scope\n        for generator in node.generators:\n            self.visit(generator)\n        return ListType(self.visit(node.elt))\n\n    def visit_Name(self, node):\n        name = node.id\n        if name == \"___\":\n            self.report_issue(\"Unconnected blocks\")\n        if isinstance(node.ctx, ast.Load):\n            if name == \"True\" or name == \"False\":\n                return BoolType()\n            elif name == \"None\":\n                return NoneType()\n            else:\n                variable = self.find_variable_scope(name)\n                builtin = get_builtin_function(name)\n                if not variable.exists and builtin:\n                    return builtin\n                else:\n                    state = self.load_variable(name)\n                    return state.type\n        else:\n            variable = self.find_variable_scope(name)\n            if variable.exists:\n                return variable.state.type\n            else:\n                return UnknownType()\n\n    def visit_Num(self, node):\n        return NumType()\n\n    def visit_Return(self, node):\n        if len(self.scope_chain) == 1:\n            self.report_issue(\"Return outside function\")\n        if node.value is not None:\n            self.return_variable(self.visit(node.value))\n        else:\n            self.return_variable(NoneType())\n\n    def visit_SetComp(self, node):\n        # TODO: Handle comprehension scope\n        for generator in node.generators:\n            self.visit(generator)\n        return SetType(self.visit(node.elt))\n\n    def visit_statements(self, nodes):\n        # TODO: Check for pass in the middle of a series of statement\n        if any(isinstance(node, ast.Pass) for node in nodes):\n            pass\n        return [self.visit(statement) for statement in nodes]\n\n    def visit_Str(self, node):\n        if node.s == \"\":\n            return StrType(True)\n        else:\n            return StrType(False)\n\n    def visit_Subscript(self, node):\n        # Handle value\n        value_type = self.visit(node.value)\n        # Handle slice\n        if isinstance(node.slice, ast.Index):\n            literal = self.get_literal(node.slice.value)\n            if literal is None:\n                dynamic_literal = type_to_literal(self.visit(node.slice.value))\n                return value_type.index(dynamic_literal)\n            else:\n                return value_type.index(literal)\n        elif isinstance(node.slice, ast.Slice):\n            if node.slice.lower is not None:\n                self.visit(node.slice.lower)\n            if node.slice.upper is not None:\n                self.visit(node.slice.upper)\n            if node.slice.step is not None:\n                self.visit(node.slice.step)\n            return value_type\n\n    def visit_Tuple(self, node):\n        type = TupleType()\n        if not node.elts:\n            type.empty = True\n            type.subtypes = []\n        else:\n            type.empty = False\n            # TODO: confirm homogenous subtype\n            type.subtypes = [self.visit(elt) for elt in node.elts]\n        return type\n\n    def visit_UnaryOp(self, node):\n        # Handle operand\n        operand = self.visit(node.operand)\n\n        if isinstance(node.op, ast.Not):\n            return BoolType()\n        elif isinstance(operand, UnknownType):\n            return UnknownType()\n        elif type(node.op) in VALID_UNARYOP_TYPES:\n            op_lookup = VALID_UNARYOP_TYPES[type(node.op)]\n            if type(node.op) in op_lookup:\n                op_lookup = op_lookup[type(node.op)]\n                if type(operand) in op_lookup:\n                    op_lookup = op_lookup[type(operand)]\n                    return op_lookup(operand)\n        return UnknownType()\n\n    def visit_While(self, node):\n        # Visit conditional\n        self.visit(node.test)\n\n        # Visit the bodies\n        this_path_id = self.path_id\n        # One path is that we never enter the body\n        empty_path = Tifa.NewPath(self, this_path_id, \"e\")\n        with empty_path:\n            pass\n        # Another path is that we loop through the body and check the test again\n        body_path = Tifa.NewPath(self, this_path_id, \"w\")\n        with body_path:\n            for statement in node.body:\n                self.visit(statement)\n            # Revisit conditional\n            self.visit(node.test)\n        # If there's else bodies (WEIRD) then we should check them afterwards\n        if node.orelse:\n            self.report_issue(\"Else on loop body\")\n            for statement in node.orelse:\n                self.visit(statement)\n\n        # Combine two paths into one\n        # Check for any names that are on the IF path\n        self.merge_paths(this_path_id, body_path.id, empty_path.id)\n\n    def visit_With(self, node):\n        if self.PYTHON_3:\n            for item in node.items:\n                type_value = self.visit(item.context_expr)\n                self.visit(item.optional_vars)\n                self._walk_target(item.optional_vars, type_value)\n        else:\n            type_value = self.visit(node.context_expr)\n            # self.visit(node.optional_vars)\n            self._walk_target(node.optional_vars, type_value)\n        # Handle the bodies\n        self.visit_statements(node.body)\n\n    def _scope_chain_str(self, name=None):\n        \"\"\"\n        Convert the current scope chain to a string representation (divided \n        by \"/\").\n\n        Returns:\n            str: String representation of the scope chain.\n        \"\"\"\n        if name:\n            return \"/\".join(map(str, self.scope_chain)) + \"/\" + name\n        else:\n            return \"/\".join(map(str, self.scope_chain))\n\n    def identify_caller(self, node):\n        \"\"\"\n        Figures out the variable that was used to kick off this call,\n        which is almost always the relevant Name to track as being updated.\n        If the origin wasn't a Name, nothing will need to be updated so None\n        is returned instead.\n\n        TODO: Is this sufficient?\n\n        Args:\n            node (AST): An AST node\n        Returns:\n            str or None: The name of the variable or None if no origin could\n                         be found.\n        \"\"\"\n        if isinstance(node, ast.Name):\n            return node.id\n        elif isinstance(node, ast.Call):\n            return self.identify_caller(node.func)\n        elif isinstance(node, (ast.Attribute, ast.Subscript)):\n            return self.identify_caller(node.value)\n        return None\n\n    def iterate_variable(self, name, position=None):\n        \"\"\"\n        Update the variable by iterating through it - this doesn't do anything\n        fancy yet.\n        \"\"\"\n        return self.load_variable(name, position)\n\n    def store_iter_variable(self, name, type, position=None):\n        state = self.store_variable(name, type, position)\n        state.read = 'yes'\n        return state\n\n    def return_variable(self, type):\n        return self.store_variable(\"*return\", type)\n\n    def append_variable(self, name, type, position=None):\n        return self.store_variable(name, type, position)\n\n    def store_variable(self, name, type, position=None):\n        \"\"\"\n        Update the variable with the given name to now have the new type.\n\n        Args:\n            name (str): The unqualified name of the variable. The variable will\n                        be assumed to be in the current scope.\n            type (Type): The new type of this variable.\n        Returns:\n            State: The new state of the variable.\n        \"\"\"\n        if position is None:\n            position = self.locate()\n        full_name = self._scope_chain_str(name)\n        current_path = self.path_chain[0]\n        variable = self.find_variable_scope(name)\n        if not variable.exists:\n            # Create a new instance of the variable on the current path\n            new_state = State(name, [], type, 'store', position,\n                              read='no', set='yes', over='no')\n            self.name_map[current_path][full_name] = new_state\n        else:\n            new_state = self.trace_state(variable.state, \"store\", position)\n            if not variable.in_scope:\n                self.report_issue(\"Write out of scope\", {'name': name})\n            # Type change?\n            if not are_types_equal(type, variable.state.type):\n                self.report_issue(\"Type changes\",\n                                  {'name': name, 'old': variable.state.type,\n                                   'new': type, 'position': position})\n            new_state.type = type\n            # Overwritten?\n            if variable.state.set == 'yes' and variable.state.read == 'no':\n                new_state.over_position = position\n                new_state.over = 'yes'\n            else:\n                new_state.set = 'yes'\n                new_state.read = 'no'\n            self.name_map[current_path][full_name] = new_state\n        # If this is a class scope...\n        current_scope = self.scope_chain[0]\n        if current_scope in self.class_scopes:\n            self.class_scopes[current_scope].add_attr(name, new_state.type)\n        return new_state\n\n    def load_variable(self, name, position=None):\n        \"\"\"\n        Retrieve the variable with the given name.\n\n        Args:\n            name (str): The unqualified name of the variable. If the variable is\n                        not found in the current scope or an enclosing sope, all\n                        other scopes will be searched to see if it was read out\n                        of scope.\n        Returns:\n            State: The current state of the variable.\n        \"\"\"\n        full_name = self._scope_chain_str(name)\n        current_path = self.path_chain[0]\n        variable = self.find_variable_scope(name)\n        if position is None:\n            position = self.locate()\n        if not variable.exists:\n            out_of_scope_var = self.find_variable_out_of_scope(name)\n            # Create a new instance of the variable on the current path\n            if out_of_scope_var.exists:\n                self.report_issue(\"Read out of scope\", {'name': name})\n            else:\n                self.report_issue(\"Initialization Problem\", {'name': name})\n            new_state = State(name, [], UnknownType(), 'load', position,\n                              read='yes', set='no', over='no')\n            self.name_map[current_path][full_name] = new_state\n        else:\n            new_state = self.trace_state(variable.state, \"load\", position)\n            if variable.state.set == 'no':\n                self.report_issue(\"Initialization Problem\", {'name': name})\n            if variable.state.set == 'maybe':\n                self.report_issue(\"Possible Initialization Problem\", {'name': name})\n            new_state.read = 'yes'\n            if not variable.in_scope:\n                self.name_map[current_path][variable.scoped_name] = new_state\n            else:\n                self.name_map[current_path][full_name] = new_state\n        return new_state\n\n    def load_module(self, chain):\n        \"\"\"\n        Finds the module in the set of available modules.\n\n        Args:\n            chain (str): A chain of module imports (e.g., \"matplotlib.pyplot\")\n        Returns:\n            ModuleType: The specific module with its members, or an empty\n                        module type.\n        \"\"\"\n        module_names = chain.split('.')\n        potential_module = get_builtin_module(module_names[0])\n        if potential_module is not None:\n            base_module = potential_module\n            for module in module_names:\n                if (isinstance(base_module, ModuleType) and\n                        module in base_module.submodules):\n                    base_module = base_module.submodules[module]\n                else:\n                    self.report_issue(\"Module not found\", {\"name\": chain})\n            return base_module\n        else:\n            try:\n                actual_module = __import__(chain, globals(), {},\n                                           ['_tifa_definitions'])\n                definitions = actual_module._tifa_definitions()\n                return type_from_json(definitions)\n            except Exception as e:\n                self.report_issue(\"Module not found\",\n                                  {\"name\": chain, \"error\": str(e)})\n                return ModuleType()\n\n    def combine_states(self, left, right):\n        state = State(left.name, [left], left.type, 'branch', self.locate(),\n                      read=left.read, set=left.set, over=left.over,\n                      over_position=left.over_position)\n        if right is None:\n            state.read = 'no' if left.read == 'no' else 'maybe'\n            state.set = 'no' if left.set == 'no' else 'maybe'\n            state.over = 'no' if left.over == 'no' else 'maybe'\n        else:\n            if not are_types_equal(left.type, right.type):\n                self.report_issue(\"Type changes\", {'name': left.name,\n                                                   'old': left.type,\n                                                   'new': right.type})\n            state.read = Tifa.match_rso(left.read, right.read)\n            state.set = Tifa.match_rso(left.set, right.set)\n            state.over = Tifa.match_rso(left.over, right.over)\n            if left.over == 'no':\n                state.over_position = right.over_position\n            state.trace.append(right)\n        return state\n\n    def merge_paths(self, parent_path_id, left_path_id, right_path_id):\n        \"\"\"\n        Combines any variables on the left and right path into the parent\n        name space.\n\n        Args:\n            parent_path_id (int): The parent path of the left and right branches\n            left_path_id (int): One of the two paths\n            right_path_id (int): The other of the two paths.\n        \"\"\"\n        # Combine two paths into one\n        # Check for any names that are on the IF path\n        for left_name in self.name_map[left_path_id]:\n            left_state = self.name_map[left_path_id][left_name]\n            right_identifier = self.find_path_parent(right_path_id, left_name)\n            if right_identifier.exists:\n                # Was on both IF and ELSE path\n                right_state = right_identifier.state\n            else:\n                # Was only on IF path, potentially on the parent path\n                right_state = self.name_map[parent_path_id].get(left_name)\n            combined = self.combine_states(left_state, right_state)\n            self.name_map[parent_path_id][left_name] = combined\n        # Check for names that are on the ELSE path but not the IF path\n        for right_name in self.name_map[right_path_id]:\n            if right_name not in self.name_map[left_path_id]:\n                right_state = self.name_map[right_path_id][right_name]\n                # Potentially on the parent path\n                parent_state = self.name_map[parent_path_id].get(right_name)\n                combined = self.combine_states(right_state, parent_state)\n                self.name_map[parent_path_id][right_name] = combined\n\n    def trace_state(self, state, method, position):\n        \"\"\"\n        Makes a copy of the given state with the given method type.\n\n        Args:\n            state (State): The state to copy (as in, we trace a copy of it!)\n            method (str): The operation being applied to the state.\n        Returns:\n            State: The new State\n        \"\"\"\n        return state.copy(method, position)\n\n    @staticmethod\n    def in_scope(full_name, scope_chain):\n        \"\"\"\n        Determine if the fully qualified variable name is in the given scope\n        chain.\n\n        Args:\n            full_name (str): A fully qualified variable name\n            scope_chain (list): A representation of a scope chain.\n        Returns:\n            bool: Whether the variable lives in this scope\n        \"\"\"\n        # Get this entity's full scope chain\n        name_scopes = full_name.split(\"/\")[:-1]\n        # against the reverse scope chain\n        checking_scopes = [str(s) for s in scope_chain[::-1]]\n        return name_scopes == checking_scopes\n\n    @staticmethod\n    def match_rso(left, right):\n        if left == right:\n            return left\n        else:\n            return \"maybe\"\n\n    def get_literal(self, node):\n        if isinstance(node, ast.Num):\n            return LiteralNum(node.n)\n        elif isinstance(node, ast.Str):\n            return LiteralStr(node.s)\n        elif isinstance(node, ast.Tuple):\n            values = []\n            for elt in node.elts:\n                subvalue = self.get_literal(elt)\n                if subvalue is not None:\n                    values.append(subvalue)\n                else:\n                    return None\n            return LiteralTuple(values)\n        elif isinstance(node, ast.Name):\n            if node.id == \"None\":\n                return LiteralNone()\n            elif node.id == \"False\":\n                return LiteralBool(False)\n            elif node.id == \"True\":\n                return LiteralBool(True)\n        return None\n\n    class NewPath:\n        \"\"\"\n        Context manager for entering and leaving execution paths (e.g., if\n        statements).)\n\n        Args:\n            tifa (Tifa): The tifa instance, so we can modify some of its\n                         properties that track variables and paths.\n            origin_path (int): The path ID parent to this one.\n            name (str): The symbolic name of this path, typically 'i' for an IF\n                        body and 'e' for ELSE body.\n\n        Fields:\n            id (int): The path ID of this path\n        \"\"\"\n\n        def __init__(self, tifa, origin_path, name):\n            self.tifa = tifa\n            self.name = name\n            self.origin_path = origin_path\n            self.id = None\n\n        def __enter__(self):\n            self.tifa.path_id += 1\n            self.id = self.tifa.path_id\n            self.tifa.path_names.append(str(self.id) + self.name)\n            self.tifa.path_chain.insert(0, self.id)\n            self.tifa.name_map[self.id] = {}\n            self.tifa.path_parents[self.id] = self.origin_path\n\n        def __exit__(self, type, value, traceback):\n            self.tifa.path_names.pop()\n            self.tifa.path_chain.pop(0)\n\n    class NewScope:\n        \"\"\"\n        Context manager for entering and leaving scopes (e.g., inside of\n        function calls).\n\n        Args:\n            tifa (Tifa): The tifa instance, so we can modify some of its\n                         properties that track variables and paths.\n            definitions_scope_chain (list of int): The scope chain of the\n                                                   definition\n        \"\"\"\n\n        def __init__(self, tifa, definitions_scope_chain, class_type=None):\n            self.tifa = tifa\n            self.definitions_scope_chain = definitions_scope_chain\n            self.class_type = class_type\n\n        def __enter__(self):\n            # Manage scope\n            self.old_scope = self.tifa.scope_chain[:]\n            # Move to the definition's scope chain\n            self.tifa.scope_chain = self.definitions_scope_chain[:]\n            # And then enter its body's new scope\n            self.tifa.scope_id += 1\n            self.tifa.scope_chain.insert(0, self.tifa.scope_id)\n            # Register as class potentially\n            if self.class_type is not None:\n                self.class_type.scope_id = self.tifa.scope_id\n                self.tifa.class_scopes[self.tifa.scope_id] = self.class_type\n\n        def __exit__(self, type, value, traceback):\n            # Finish up the scope\n            self.tifa._finish_scope()\n            # Leave the body\n            self.tifa.scope_chain.pop(0)\n            # Restore the scope\n            self.tifa.scope_chain = self.old_scope\n", "src/lib/pedal/tifa/identifier.py": "class Identifier:\n    \"\"\"\n    A representation of an Identifier, encapsulating its current level of\n    existence, scope and State.\n\n    Attributes:\n        exists (bool): Whether or not the variable actually is defined anywhere.\n                       It is possible that a variable was retrieved that does\n                       not actually exist yet, which indicates it might need to\n                       be created.\n        in_scope (bool): Whether or not the variable exists in the current\n                         scope. Used to detect the presence of certain kinds\n                         of errors where the user is using a variable from\n                         a different scope.\n        scoped_name (str): The fully qualified name of the variable, including\n                           its scope chain.\n        state (State): The current state of the variable.\n    \"\"\"\n\n    def __init__(self, exists, in_scope=False, scoped_name=\"UNKNOWN\", state=\"\"):\n        self.exists = exists\n        self.in_scope = in_scope\n        self.scoped_name = scoped_name\n        self.state = state\n", "src/lib/pedal/tifa/state.py": "def check_trace(state):\n    past_types = [state.type]\n    for past_state in state.trace:\n        past_types.extend(check_trace(past_state))\n    return past_types\n\n\nclass State:\n    \"\"\"\n    A representation of a variable at a particular point in time of the program.\n\n    Attributes:\n        name (str): The name of the variable, without its scope chain\n        trace (list of State): A recursive definition of previous States for\n                               this State.\n        type (Type): The current type of this variable.\n        method (str): One of 'store', 'read', (TODO). Indicates the change that\n                      occurred to this variable at this State.\n        position (dict): A Position dictionary indicating where this State\n                         change occurred in the source code.\n        read (str): One of 'yes', 'no', or 'maybe'. Indicates if this variable\n                    has been read since it was last changed. If merged from a\n                    diverging path, it is possible that it was \"maybe\" read.\n        set (str): One of 'yes', 'no', or 'maybe'. Indicates if this variable\n                    has been set since it was last read. If merged from a\n                    diverging path, it is possible that it was \"maybe\" changed.\n        over (str): One of 'yes', 'no', or 'maybe'. Indicates if this variable\n                    has been overwritten since it was last set. If merged from a\n                    diverging path, it is possible that it was \"maybe\" changed.\n        over_position (dict): A Position indicating where the State was\n                              previously set versus when it was overwritten.\n    \"\"\"\n\n    def __init__(self, name, trace, type, method, position,\n                 read='maybe', set='maybe', over='maybe', over_position=None):\n        self.name = name\n        self.trace = trace\n        self.type = type\n        self.method = method\n        self.position = position\n        self.over_position = over_position\n        self.read = read\n        self.set = set\n        self.over = over\n\n    def copy(self, method, position):\n        \"\"\"\n        Make a copy of this State, copying this state into the new State's trace\n        \"\"\"\n        return State(self.name, [self], self.type, method, position,\n                     self.read, self.set, self.over, self.over_position)\n\n    def __str__(self):\n        \"\"\"\n        Create a string representation of this State.\n        \"\"\"\n        return \"{method}(r:{read},s:{set},o:{over},{type})\".format(\n            method=self.method,\n            read=self.read[0],\n            set=self.set[0],\n            over=self.over[0],\n            type=self.type.__class__.__name__\n        )\n\n    def __repr__(self):\n        \"\"\"\n        Create a string representation of this State.\n        \"\"\"\n        return str(self)\n\n    def was_type(self, a_type):\n        \"\"\"\n        Retrieve all the types that this variable took on over its entire\n        trace.\n        \"\"\"\n        past_types = check_trace(self)\n        return any(past_type.is_equal(a_type) for past_type in past_types)\n", "src/lib/pedal/tifa/_faster_type_definitions.js": "var $builtinmodule = function (name) {\n\"use strict\";\n\n    var mod = {};\n    \n    /*\n    // Function Template\n    new Sk.builtin.func(function () {\n        // Body\n    });\n    \n    // Class Template\n    var class_constructor = function ($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self, parameters) {\n            // Body\n        });\n        $loc._internalGenericGetAttr = Sk.builtin.object.prototype.GenericSetAttr;\n    };\n    Sk.misceval.buildClass(mod, class_constructor, class_name_as_string, []);\n    */\n    var types_list = [\n        \"UnknownType\", \"RecursedType\",\n        \"FunctionType\", \"ClassType\", \"InstanceType\",\n        \"NumType\", \"NoneType\", \"BoolType\", \"TupleType\",\n        \"ListType\", \"StrType\", \"GeneratorType\",\n        \"DictType\", \"ModuleType\", \"SetType\"\n    ]\n    for (var i=0; i<types_list.length; i++) {\n        var class_constructor = function ($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function (self, name, submodule, fields) {\n                // Body\n            });\n        };\n        mod[types_list[i]] = Sk.misceval.buildClass(mod, class_constructor, types_list[i], []);\n    }\n    \n    var literals_list = [\n        \"LiteralNum\", \"LiteralBool\", \"LiteralNone\", \"LiteralStr\", \"LiteralTuple\"\n    ]\n    for (var i=0; i<literals_list.length; i++) {\n        var class_constructor = function ($gbl, $loc) {\n            $loc.type = new Sk.builtin.func(function (self) {\n                // Body\n            });\n        };\n        mod[literals_list[i]] = Sk.misceval.buildClass(mod, class_constructor, literals_list[i], []);\n    }\n    \n    mod.type_from_json = new Sk.builtin.func(function () {\n        // Body\n    });\n    mod.type_to_literal = new Sk.builtin.func(function () {\n        // Body\n    });                                         \n    \n    return mod;\n\n};\n", "src/lib/pedal/questions/__init__.py": "\"\"\"\nA tool for providing dynamic questions to learners.\n\"\"\"\n\nNAME = 'Questions'\nSHORT_DESCRIPTION = \"Provides dynamic questions to learners\"\nDESCRIPTION = '''\n'''\nREQUIRES = []\nOPTIONALS = []\nCATEGORY = 'Instructions'\n\n__all__ = ['NAME', 'DESCRIPTION', 'SHORT_DESCRIPTION', 'REQUIRES', 'OPTIONALS',\n           'Question', 'Pool', 'set_seed']\n\nfrom pedal.report.imperative import MAIN_REPORT\nfrom pedal.questions.setup import _setup_questions, set_seed, _name_hash\n\nclass Question:\n    def __init__(self, name, instructions, tests, seed=None, report=None):\n        self.name = name\n        self.instructions = instructions\n        self.tests = tests\n        self.seed = seed\n        if report is None:\n            report = MAIN_REPORT\n        self.report = report\n        self.answered = False\n    \n    def answer(self):\n        self.answered = True\n    \n    def ask(self):\n        for test in self.tests:\n            test(self)\n        if not self.answered:\n            self.report.attach('Question', category='Instructions', tool='Questions',\n                               group=self.report.group,\n                               priority='instructions',\n                               hint=self.instructions)\n\nclass Pool:\n    _POOL_TRACKER = 0\n    def __init__(self, name, choices, seed=None, report=None, position=None):\n        self.name = name\n        self.choices = choices\n        self.seed = seed\n        if report is None:\n            report = MAIN_REPORT\n        self.report = report\n        if position is None:\n            position = Pool._POOL_TRACKER\n            Pool._POOL_TRACKER += 1\n        self.position = position\n\n    def choose(self, force=None):\n        _setup_questions(self.report)\n        if force is None:\n            if self.seed is None:\n                force = self.report['questions']['seed']\n                if isinstance(force, str):\n                    force = _name_hash(force+self.name)\n                # Assume iterable; could be check that throws better error\n                if not isinstance(force, int):\n                    force = force[self.position]\n            else:\n                force = self.seed\n        return self.choices[force % len(self.choices)]\n    \n    @property\n    def answered(self):\n        for choice in self.choices:\n            if choice.answered:\n                return True\n        return False\n", "src/lib/pedal/questions/setup.py": "from pedal.report.imperative import MAIN_REPORT\n\nimport hashlib\n\ndef _name_hash(name):\n    return hashlib.md5(name.encode('utf8')).digest()[0]\n\ndef _setup_questions(report):\n    '''\n    Initialize any necessary fields for the report's question tool.\n    \n    Args:\n        report (Report): The report object to store data and feedback in.\n    '''\n    if 'questions' not in report:\n        report['questions'] = {\n            'seed': 0\n        }\n\ndef set_seed(seed_value, report=None):\n    '''\n    Sets the seed that will be used in selecting questions.\n    \n    Args:\n        seed_value (int or str or iterable[int]): The value to use when\n            selecting questions, deterministically. If int, the same index\n            will be used for all questions. If an iterable of ints, each\n            one will serve as the index for the corresponding problem (throws\n            an exception if the iterable isn't long enough). If a string,\n            it will be hashed to a value (the hash is deterministic across\n            platforms) that will be modulo'd to be in the right range for the\n            pool. Presently, hashing generates values from [0, 256) so you\n            need to limit your questions to 256.\n        report (Report): The report object to store data and feedback in. If\n            left None, defaults to the global MAIN_REPORT.\n    '''\n    if report is None:\n        report = MAIN_REPORT\n    report['questions']['seed'] = seed_value\n", "src/lib/multiprocessing/__init__.py": "raise NotImplementedError(\"multiprocessing is not yet implemented in Skulpt\")\n", "src/lib/multiprocessing/dummy/__init__.py": "raise NotImplementedError(\"dummy is not yet implemented in Skulpt\")\n", "src/lib/urllib/__init__.js": "var $builtinmodule = function (name) {\n    var urllib = {};\n\n    return urllib;\n};\n", "src/lib/urllib/request/__init__.js": "var $builtinmodule = function (name) {\n    var request = {};\n\n\n    //~ Classes .................................................................\n\n    // Response class\n    //\n    // Response objects are returned by the request, get, post, etc.\n    // methods, allowing the user to access the response text, status\n    // code, and other information.\n\n    // ------------------------------------------------------------\n    var response = function ($gbl, $loc) {\n\n        // ------------------------------------------------------------\n        $loc.__init__ = new Sk.builtin.func(function (self, xhr) {\n            self.data$ = xhr.responseText;\n            self.lineList = self.data$.split(\"\\n\");\n            self.lineList = self.lineList.slice(0, -1);\n            for (var i = 0; i < self.lineList.length; i++) {\n                self.lineList[i] = self.lineList[i] + '\\n';\n            }\n            self.currentLine = 0;\n            self.pos$ = 0;\n        });\n\n\n        // ------------------------------------------------------------\n        $loc.__str__ = new Sk.builtin.func(function (self) {\n            return Sk.ffi.remapToPy('<Response>');\n        });\n\n\n        // ------------------------------------------------------------\n        $loc.__iter__ = new Sk.builtin.func(function (self) {\n            var allLines = self.lineList;\n\n            return Sk.builtin.makeGenerator(function () {\n                if (this.$index >= this.$lines.length) {\n                    return undefined;\n                }\n                return new Sk.builtin.str(this.$lines[this.$index++]);\n            }, {\n                $obj  : self,\n                $index: 0,\n                $lines: allLines\n            });\n        });\n\n\n        // ------------------------------------------------------------\n        $loc.read = new Sk.builtin.func(function (self, size) {\n            if (self.closed) {\n                throw new Sk.builtin.ValueError(\"I/O operation on closed file\");\n            }\n            var len = self.data$.length;\n            if (size === undefined) {\n                size = len;\n            }\n            var ret = new Sk.builtin.str(self.data$.substr(self.pos$, size));\n            self.pos$ += size;\n            if (self.pos$ >= len) {\n                self.pos$ = len;\n            }\n            return ret;\n        });\n\n\n        // ------------------------------------------------------------\n        $loc.readline = new Sk.builtin.func(function (self, size) {\n            var line = \"\";\n            if (self.currentLine < self.lineList.length) {\n                line = self.lineList[self.currentLine];\n                self.currentLine++;\n            }\n            return new Sk.builtin.str(line);\n        });\n\n\n        // ------------------------------------------------------------\n        $loc.readlines = new Sk.builtin.func(function (self, sizehint) {\n            var arr = [];\n            for (var i = self.currentLine; i < self.lineList.length; i++) {\n                arr.push(new Sk.builtin.str(self.lineList[i]));\n            }\n            return new Sk.builtin.list(arr);\n        });\n\n    };\n\n    request.Response =\n        Sk.misceval.buildClass(request, response, 'Response', []);\n\n\n    //~ Module functions ........................................................\n\n    // ------------------------------------------------------------\n    /**\n     * Constructs and sends a Request. Returns Response object.\n     *\n     * http://docs.python-requests.org/en/latest/api/#requests.request\n     *\n     * For now, this implementation doesn't actually construct a Request\n     * object; it just makes the request through jQuery.ajax and then\n     * constructs a Response.\n     */\n    request.urlopen = new Sk.builtin.func(function (url, data, timeout) {\n        var prom = new Promise(function(resolve, reject) {\n            var xmlhttp = new XMLHttpRequest();\n\n            xmlhttp.addEventListener(\"loadend\", function (e) {\n                resolve(Sk.misceval.callsim(request.Response, xmlhttp));\n            });\n\n            if (!data) {\n                xmlhttp.open(\"GET\", url.v);\n                xmlhttp.send(null);\n            } else {\n                xmlhttp.open(\"POST\", url.v);\n                xmlhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n                xmlhttp.setRequestHeader(\"Content-length\", data.v.length);\n                xmlhttp.send(data.v);\n            }\n        });\n\n        var susp = new Sk.misceval.Suspension();\n\n        susp.resume = function() {\n            return resolution;\n        };\n\n        susp.data = {\n            type: \"Sk.promise\",\n            promise: prom.then(function(value) {\n                resolution = value;\n                return value;\n            }, function(err) {\n                resolution = \"\";\n                return err;\n            })\n        };\n\n        return susp;\n    });\n\n\n    return request;\n};\n", "src/lib/matplotlib2/__init__.js": "var $builtinmodule = function(name)\n{\n  var matplotlib = {};\n\n  return matplotlib;\n};\n", "src/lib/matplotlib2/pyplot/__init__.js": "/**\n    Made by Michael Ebert for skulpt, see this modules at https://github.com/waywaaard/skulpt\n\n    matplotlib.pyplot inspired by https://github.com/rameshvs/jsplotlib, though heavily modified.\n\n  jsplotlib for supporting plot commands and kwargs for the matplotlib skulpt module\n  Supports:\n    - kwargs\n    - all color specs\n    - color cycle\n    - rc params\n    - ., o, x, s markers\n    - resize function for markers\n    - -, --, .- line styles\n    - various Line2D attributes\n    - auto scaling for axes\n**/\nvar jsplotlib = {\n    // empty object creation\n};\n\njsplotlib.rc = {\n    \"lines.linewidth\": 1.0,\n    \"lines.linestyle\": \"-\",\n    \"lines.color\": \"blue\",\n    \"lines.marker\": \"None\",\n    \"lines.markeredgewidth\": 0.5,\n    \"lines.markersize\": 6,\n    \"lines.dash_joinstyle\": \"miter\",\n    \"lines.dash_capstyle\": \"butt\",\n    \"lines.solid_jointyle\": \"miter\",\n    \"lines.solid_capstyle\": \"projecting\",\n    \"lines.antialiased\": true,\n    \"patch.linewidth\": 1.0,\n    \"patch.facecolor\": \"blue\",\n    \"patch.edgecolor\": \"black\",\n    \"patch.antialiased\": true,\n    \"text.color\": \"black\",\n    \"axes.hold\": true, // whether to clear the axes by default on\n    \"axes.facecolor\": \"white\", // axes background color\n    \"axes.edgecolor\": \"black\", // axes edge color\n    \"axes.grid\": false,\n    \"axes.titlesize\": \"large\",\n    \"axes.labelsize\": \"medium\",\n    \"axes.labelweigth\": \"normal\",\n    \"axes.labelcolor\": \"black\",\n    \"axes.axisbelow\": false,\n    \"axes.color_cycle\": [\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"]\n};\n\nvar chart_counter = 0; // for creating unique ids\n\njsplotlib.Bars = function(ydata, color) {\n    var that = {};\n    \n    // Initialize parameter defaults\n    that._y = ydata;\n    that._color = color || null;\n    \n    that.color = function(cs) {\n        if (cs)\n            this._color = jsplotlib.color_to_hex(cs);\n        return this;\n    };\n    \n    that.draw = function(parent_chart) {\n        // should be called in the pplot command\n        // each plot call adds a new set of bars to our existing plot\n        // object and draws them all, when show is called\n        // this._init_common();\n        var number_of_points = this._y.length; // implement need to move those from the original construct_graph class to lines\n        if (!this._linestyle && !this._marker) {\n            this._linestyle = jsplotlib.rc['lines.linestyle'];\n        }\n\n        /*\n        if (!this._marker && !this._linestyle) {\n          this._marker = jsplotlib.rc['lines.marker'];\n        }\n        */\n\n        if (!this._color) {\n            this._color = jsplotlib.color_to_hex(parent_chart.get_next_color());\n        }\n\n        // set defaults for all attributes\n        if (!this._markersize) {\n            this._markersize = jsplotlib.rc['lines.markersize'];\n        }\n\n        if (!this._markeredgecolor) {\n            this._markeredgecolor = 'k';\n        }\n\n        if (!this._linewidth) {\n            this._linewidth = jsplotlib.rc['lines.linewidth'];\n        }\n\n        if (!this._dash_capstyle) {\n            this._dash_capstyle = \"butt\";\n        }\n\n        if (!this._solid_capstyle) {\n            this._solid_capstyle = \"butt\";\n        }\n\n        if (!this._solid_joinstyle) {\n            this._solid_joinstyle = \"miter\";\n        }\n\n        if (!this._dash_joinstyle) {\n            this._dash_joinstyle = \"miter\";\n        }\n\n        // default markerfacecolor is linecolor\n        if (!this._markerfacecolor) {\n            this._markerfacecolor = jsplotlib.color_to_hex(this._color);\n        }\n\n        if (!this._markeredgewidth) {\n            this._markeredgewidth = 0.75;\n        }\n\n        if (!this._alpha) {\n            this._alpha = 1;\n        }\n\n        // local storage for drawing\n        var y = this._y;\n        \n        /*\n        var bins = parseInt(8);\n        tempScale = d3.scale.linear().domain([0, bins]).range(d3.extent(y));\n        tickArray = d3.range(1+bins).map(tempScale).map(function(e) {\n            return e;\n        });\n        var histMapper = d3.layout.histogram().bins(tickArray)(ys);\n        y.domain([0, d3.max(histMapper, function(d) { return d.y; })]);\n        */\n\n        // create array of point pairs with optional s value\n        // from [x1,x2], [y1, y2], [s1, s2]\n        // to [[x1,y1,s1],[x2,y2,s2]]\n        var xscale = parent_chart.get_xscale(); // should come from axis o.O\n        var yscale = parent_chart.get_yscale();\n\n        var xformat = parent_chart._xaxis._formatter || function(x) {\n            return x;\n        };\n\n        var yformat = parent_chart._yaxis._formatter || function(x) {\n            return x;\n        };\n\n        // this adds the bars to the chart\n        this._bars = parent_chart.chart.append(\"svg:g\").attr(\"id\", this._artist_id);\n        this._bars_containers = this._bars.selectAll(\"g.pplot_bars\").data(y).enter()\n            .append(\"g\").attr(\"class\", \"pplot_bars\");\n            \n        /*\n        bars.enter().append(\"rect\")\n            .attr(\"class\", \"bar\")\n            .attr(\"y\", y(0))\n            .style('fill', mainModel.settings.color().fill)\n            .style('outline', '1px solid '+mainModel.settings.color().stroke)\n            .attr(\"height\", height - y(0));\n        */\n\n        // set appropriate line style\n        this._bars = this._bars_containers.append(\"rect\")\n            .attr(\"x1\", function(d) {\n                return xscale(d[0][0]);\n            })\n            .attr(\"x2\", function(d) {\n                return xscale(d[1][0]);\n            })\n            .attr(\"y1\", function(d) {\n                return yscale(d[0][1]);\n            })\n            .attr(\"y2\", function(d) {\n                return yscale(d[1][1]);\n            })\n            .style(\"stroke\", jsplotlib.color_to_hex(this._color))\n            .style(\"stroke-linecap\", this._solid_capstyle)\n            .style(\"stroke-linejoin\", this._solid_joinstyle)\n            .style(\"stroke-opacity\", this._alpha)\n            .style(\"stroke-width\", this._linewidth);\n\n        return this;\n    };\n    \n    /**\n      Updates possible attributes provided as kwargs\n    **/\n    that.update = function(kwargs) {\n        // we assume key value pairs\n        if (kwargs && typeof kwargs === \"object\") {\n            for (var key in kwargs) {\n                if (kwargs.hasOwnProperty(key)) {\n                    var val = kwargs[key];\n\n                    switch (key) {\n                    }\n                }\n            }\n        }\n\n        return this;\n    };\n    \n    return that;\n}\n\njsplotlib._line_counter = 0;\n\n/** Line2D class for encapsulating all line relevant attributes and methods\n        Rebuilds partial matplotlib.Line2D functionality. Does not inherit from\n        abstract Artist class. Rather more a data representation.\n **/\njsplotlib.Line2D = function(xdata, ydata, linewidth, linestyle, color, marker,\n    markersize, markeredgewidth, markeredgecolor, markerfacecolor,\n    markerfacecoloralt, fillstyle, antialiased, dash_capstyle,\n    solid_capstyle, dash_joinstyle, solid_joinstyle, pickradius,\n    drawstyle, markevery, kwargs) {\n\n    // \"that\": completed Line2D object that is returned\n    var that = {}, x_values= [], y_values = [];\n    // Initialize parameter defaults\n    var skip = Math.max(1, ydata.length / 500);\n    for (var i = 0, len = ydata.length; i < len; i=i+skip) {\n        var index = Math.floor(i+Math.random()*skip);\n        if (xdata.length == ydata.length) {\n            x_values.push(xdata[index]);\n        }\n        y_values.push(ydata[index]);\n    } \n    that._x = x_values; //xdata;\n    that._y = y_values; //ydata;\n    that._linewidth = linewidth || null;\n    that._linestyle = linestyle || null;\n    that._color = color || null;\n    that._marker = marker || null;\n    that._markersize = markersize || null;\n    that._markeredgewidth = markeredgewidth || null;\n    that._markeredgecolor = markeredgecolor || null;\n    that._markerfacecolor = markerfacecolor || null;\n    that._markerfacecoloralt = markerfacecoloralt || 'none';\n    that._fillstyle = fillstyle || 'full';\n    that._antialiased = antialiased || null;\n    that._dash_capstyle = dash_capstyle || null;\n    that._solid_capstyle = solid_capstyle || null;\n    that._dash_joinstyle = dash_joinstyle || null;\n    that._solid_joinstyle = solid_joinstyle || null;\n    that._pickradius = pickradius || 5;\n    that._drawstyle = drawstyle || null;\n    that._markevery = markevery || null;\n    this._line_id = jsplotlib._line_counter;\n    jsplotlib._line_counter += 1;\n    //kwargs\n\n    // if only y provided, create Array from 1 to N\n    if (!that._x || that._x.length === 0) {\n        that._x = jsplotlib.linspace(1, that._y.length, that._y.length);\n    }\n\n    that.antialiased = function(a) {\n        if (a)\n            this._antialiased = a;\n        return this;\n    };\n\n    that.markerfacecoloralt = function(mfca) {\n        if (mfca)\n            this._markerfacecoloralt = mfca;\n        return this;\n    };\n\n    that.pickradius = function(pr) {\n        if (pr)\n            this._pickradius = pr;\n        return this;\n    };\n\n    that.drawstyle = function(ds) {\n        if (ds)\n            this._drawstyle = ds;\n        return this;\n    };\n\n    that.markevery = function(me) {\n        if (me)\n            this._markevery = me;\n        return this;\n    };\n\n    that.color = function(cs) {\n        if (cs)\n            this._color = jsplotlib.color_to_hex(cs);\n        return this;\n    };\n\n    that.alpha = function(a) {\n        if (a)\n            this._alpha = a;\n        return this;\n    };\n\n    /* supports butt, round, projecting*/\n    that.dash_capstyle = function(dcs) {\n        if (dcs)\n            this._dash_capstyle = dcs;\n        return this;\n    };\n\n    /* supports butt, round, projecting*/\n    that.solid_capstyle = function(scs) {\n        if (scs)\n            this._solid_capstyle = scs;\n        return this;\n    };\n\n    /* supports miter, round, bevel' */\n    that.solid_jointyle = function(sjs) {\n        if (sjs)\n            this._solid_joinstyle = sjs;\n        return this;\n    };\n\n    /* supports miter, round, bevel' */\n    that.dash_joinstyle = function(djs) {\n        if (djs)\n            this._dash_joinstyle = djs;\n        return this;\n    };\n\n    /* random float */\n    that.markersize = function(ms) {\n        if (ms)\n            this._markersize = ms;\n        return this;\n    };\n\n    that.marker = function(ms) {\n        if (ms)\n            this._marker = ms;\n        return this;\n    };\n\n    that.markerfacecolor = function(mfc) {\n        if (mfc)\n            this._markerfacecolor = jsplotlib.color_to_hex(mfc);\n        return this;\n    };\n\n    that.markeredgecolor = function(mec) {\n        if (mec)\n            this._markeredgecolor = jsplotlib.color_to_hex(mec);\n        return this;\n    };\n\n    that.markeredgewidth = function(mec) {\n        if (mec)\n            this._markeredgewidth = mec;\n        return this;\n    };\n\n    that.linestyle = function(ls) {\n        if (ls)\n            ls = ls.trim();\n        this._linestyle = ls;\n        return this;\n    };\n\n    that.linewidth = function(lw) {\n        if (lw)\n            this._linewidth = lw;\n        return this;\n    };\n\n    that.line_id = function(lid) {\n        this._line_id = lid;\n        return this;\n    };\n\n    that.xrange = function(min, max, N) {\n        this._x = jsplotlib.linspace(min, max, N);\n        return this;\n    };\n\n    that.yrange = function(min, max, N) {\n        this._y = jsplotlib.linspace(min, max, N);\n        return this;\n    };\n\n    /**\n      Updates possible attributes provided as kwargs\n    **/\n    that.update = function(kwargs) {\n        // we assume key value pairs\n        if (kwargs && typeof kwargs === \"object\") {\n            for (var key in kwargs) {\n                if (kwargs.hasOwnProperty(key)) {\n                    var val = kwargs[key];\n\n                    switch (key) {\n                        case 'linewidth':\n                            this.linewidth(val);\n                            break;\n                        case 'linestyle':\n                            this.linestyle(val);\n                            break;\n                        case 'color':\n                            val = jsplotlib.to_rgb(val);\n                            this.color(val);\n                            break;\n                        case 'marker':\n                            this.marker(val);\n                            break;\n                        case 'markersize':\n                            this.markersize(val);\n                            break;\n                        case 'markeredgewidth':\n                            this.markeredgewidth(val);\n                            break;\n                        case 'markeredgecolor':\n                            val = jsplotlib.to_rgb(val);\n                            this.markeredgecolor(val);\n                            break;\n                        case 'markerfacecolor':\n                            val = jsplotlib.to_rgb(val);\n                            this.markerfacecolor(val);\n                            break;\n                        case 'markerfacecoloralt':\n                            val = jsplotlib.to_rgb(val);\n                            this.markerfacecoloralt(val);\n                            break;\n                        case 'fillstyle':\n                            this.fillstyle(val);\n                            break;\n                        case 'antialiased':\n                            this.antialiased(val);\n                            break;\n                        case 'dash_capstyle':\n                            this.dash_capstyle(val);\n                            break;\n                        case 'solid_capstyle':\n                            this.solid_capstyle(val);\n                            break;\n                        case 'dash_joinstyle':\n                            this.dash_joinstyle(val);\n                            break;\n                        case 'solid_jointyle':\n                            this.solid_jointyle(val);\n                            break;\n                        case 'pickradius':\n                            this.pickradius(val);\n                            break;\n                        case 'drawstyle':\n                            this.drawstyle(val);\n                            break;\n                        case 'markevery':\n                            this.markevery(val);\n                            break;\n                    }\n                }\n            }\n        }\n\n        return this;\n    };\n\n    that.draw = function(parent_chart) {\n        // should be called in the pplot command\n        // each plot call adds a new line to our existing plot\n        // object and draws them all, when show is called\n        // this._init_common();\n        var number_of_points = this._y.length || this._x.length; // implement need to move those from the original construct_graph class to lines\n        if (!this._linestyle && !this._marker) {\n            this._linestyle = jsplotlib.rc['lines.linestyle'];\n        }\n\n        /*\n        if (!this._marker && !this._linestyle) {\n          this._marker = jsplotlib.rc['lines.marker'];\n        }\n        */\n\n        if (!this._color) {\n            this._color = jsplotlib.color_to_hex(parent_chart.get_next_color());\n        }\n\n        // set defaults for all attributes\n        if (!this._markersize) {\n            this._markersize = jsplotlib.rc['lines.markersize'];\n        }\n\n        if (!this._markeredgecolor) {\n            this._markeredgecolor = 'k';\n        }\n\n        if (!this._linewidth) {\n            this._linewidth = jsplotlib.rc['lines.linewidth'];\n        }\n\n        if (!this._dash_capstyle) {\n            this._dash_capstyle = \"butt\";\n        }\n\n        if (!this._solid_capstyle) {\n            this._solid_capstyle = \"butt\";\n        }\n\n        if (!this._solid_joinstyle) {\n            this._solid_joinstyle = \"miter\";\n        }\n\n        if (!this._dash_joinstyle) {\n            this._dash_joinstyle = \"miter\";\n        }\n\n        // default markerfacecolor is linecolor\n        if (!this._markerfacecolor) {\n            this._markerfacecolor = jsplotlib.color_to_hex(this._color);\n        }\n\n        if (!this._markeredgewidth) {\n            this._markeredgewidth = 0.75;\n        }\n\n        if (!this._alpha) {\n            this._alpha = 1;\n        }\n\n        // local storage for drawing\n        var x = this._x;\n        var y = this._y;\n\n        // create array of point pairs with optional s value\n        // from [x1,x2], [y1, y2], [s1, s2]\n        // to [[x1,y1,s1],[x2,y2,s2]]\n        var xys = d3.zip(x, y);\n        var pairs = d3.zip(xys.slice(0, -1), xys.slice(1));\n        var xscale = parent_chart.get_xscale(); // should come from axis o.O\n        var yscale = parent_chart.get_yscale();\n\n        var xformat = parent_chart._xaxis._formatter || function(x) {\n            return x;\n        };\n\n        var yformat = parent_chart._yaxis._formatter || function(x) {\n            return x;\n        };\n\n        // this adds the line to the chart\n        this._line = parent_chart.chart.append(\"svg:g\").attr(\"id\", this._line_id);\n        this._line_containers = this._line.selectAll(\"g.pplot_lines\").data(pairs).enter()\n            .append(\"g\").attr(\"class\", \"pplot_lines\");\n\n        // set appropriate line style\n        if (this._linestyle === \"-\") {\n            this._lines = this._line_containers.append(\"line\")\n                .attr(\"x1\", function(d) {\n                    return xscale(d[0][0]);\n                })\n                .attr(\"x2\", function(d) {\n                    return xscale(d[1][0]);\n                })\n                .attr(\"y1\", function(d) {\n                    return yscale(d[0][1]);\n                })\n                .attr(\"y2\", function(d) {\n                    return yscale(d[1][1]);\n                })\n                .style(\"stroke\", jsplotlib.color_to_hex(this._color))\n                .style(\"stroke-linecap\", this._solid_capstyle)\n                .style(\"stroke-linejoin\", this._solid_joinstyle)\n                .style(\"stroke-opacity\", this._alpha)\n                .style(\"stroke-width\", this._linewidth);\n        } else if (this._linestyle === \"--\") {\n            this._lines = this._line_containers.append(\"line\")\n                .attr(\"x1\", function(d) {\n                    return xscale(d[0][0]);\n                })\n                .attr(\"x2\", function(d) {\n                    return xscale(d[1][0]);\n                })\n                .attr(\"y1\", function(d) {\n                    return yscale(d[0][1]);\n                })\n                .attr(\"y2\", function(d) {\n                    return yscale(d[1][1]);\n                })\n                .style(\"stroke\", jsplotlib.color_to_hex(this._color))\n                .style(\"stroke-width\", this._linewidth)\n                .style(\"stroke-linecap\", this._dash_capstyle)\n                .style(\"stroke-linejoin\", this._dash_joinstyle)\n                .style(\"stroke-opacity\", this._alpha)\n                .style(\"stroke-dasharray\", \"5,5\");\n        } else if (this._linestyle === \":\") {\n            this._lines = this._line_containers.append(\"line\")\n                .attr(\"x1\", function(d) {\n                    return xscale(d[0][0]);\n                })\n                .attr(\"x2\", function(d) {\n                    return xscale(d[1][0]);\n                })\n                .attr(\"y1\", function(d) {\n                    return yscale(d[0][1]);\n                })\n                .attr(\"y2\", function(d) {\n                    return yscale(d[1][1]);\n                })\n                .style(\"stroke\", jsplotlib.color_to_hex(this._color))\n                .style(\"stroke-width\", this._linewidth)\n                .style(\"stroke-dasharray\", \"2,5\")\n                .style(\"stroke-linejoin\", this._dash_joinstyle)\n                .style(\"stroke-opacity\", this._alpha)\n                .style(\"stroke-linecap\", \"round\");\n        } else if (this._linestyle === \"-.\") {\n            this._lines = this._line_containers.append(\"line\")\n                .attr(\"x1\", function(d) {\n                    return xscale(d[0][0]);\n                })\n                .attr(\"x2\", function(d) {\n                    return xscale(d[1][0]);\n                })\n                .attr(\"y1\", function(d) {\n                    return yscale(d[0][1]);\n                })\n                .attr(\"y2\", function(d) {\n                    return yscale(d[1][1]);\n                })\n                .style(\"stroke\", jsplotlib.color_to_hex(this._color))\n                .style(\"stroke-width\", this._linewidth)\n                .style(\"stroke-linecap\", this._dash_capstyle)\n                .style(\"stroke-linejoin\", this._dash_joinstyle)\n                .style(\"stroke-opacity\", this._alpha)\n                .style(\"stroke-dasharray\", \"5, 5, 2, 5\");\n        }\n\n        // append points\n        this._points = parent_chart.chart.selectAll(\"g.pplot_points\" + this._line_id)\n            .data(xys).enter().append(\"g\")\n            .attr(\"x\", function(d) {\n                return d[0];\n            })\n            .attr(\"y\", function(d) {\n                return d[1];\n            })\n            //.attr(\"s\", function(d) {\n            //  return d[2];\n            //})\n            .attr(\"class\", \"pplot_points\" + this._line_id);\n\n        // init hover popups\n        /*\n        $(\"#\" + chart.attr(\"id\") + \" g.pplot_points\" + this._line_id).tipsy({\n          gravity: \"nw\",\n          html: true,\n          title: function() {\n            var d = this.__data__;\n            var output = \"(\" + xformat(d[0]) + \",\" + yformat(d[1]) + \")\";\n            return output;\n          }\n        }); */\n\n        // set appropriate marker styles\n        // http://matplotlib.org/api/markers_api.html\n        var marker_size = this._markersize; // store for nested call\n        switch (this._marker) {\n            case undefined:\n            case \" \":\n            case \"None\":\n            case \"\":\n                break;\n            case \".\":\n                this._markers = this._points.append(\"circle\").attr(\"cx\", function(d) {\n                    return xscale(d[0]);\n                }).attr(\"cy\", function(d) {\n                    return yscale(d[1]);\n                }).attr(\"r\", function(d) {\n                    return 1;\n                });\n                break;\n            case \"o\":\n                this._markers = this._points.append(\"circle\").attr(\"cx\", function(d) {\n                    return xscale(d[0]);\n                }).attr(\"cy\", function(d) {\n                    return yscale(d[1]);\n                }).attr(\"r\", function(d) {\n                    return marker_size;\n                });\n                break;\n            case \"x\":\n                this._points.append(\"line\").attr(\"x1\", function(d) {\n                    return xscale(d[0]) - marker_size;\n                }).attr(\"x2\", function(d) {\n                    return xscale(d[0]) + marker_size;\n                }).attr(\"y1\", function(d) {\n                    return yscale(d[1]) - marker_size;\n                }).attr(\"y2\", function(d) {\n                    return yscale(d[1]) + marker_size;\n                });\n                this._points.append(\"line\").attr(\"x1\", function(d) {\n                    return xscale(d[0]) + marker_size;\n                }).attr(\"x2\", function(d) {\n                    return xscale(d[0]) - marker_size;\n                }).attr(\"y1\", function(d) {\n                    return yscale(d[1]) - marker_size;\n                }).attr(\"y2\", function(d) {\n                    return yscale(d[1]) + marker_size;\n                });\n                this._markers = this._points.selectAll(\"line\");\n                break;\n            case 's':\n                this._points.append(\"rect\")\n                    .attr(\"x\", function(d) {\n                        return xscale(d[0]) - marker_size / 2;\n                    })\n                    .attr(\"y\", function(d) {\n                        return yscale(d[1]) - marker_size / 2;\n                    })\n                    .attr(\"width\", function(d) {\n                        return marker_size;\n                    })\n                    .attr(\"height\", function(d) {\n                        return marker_size;\n                    });\n                this._markers = this._points.selectAll(\"rect\");\n                break;\n        }\n\n        // resize function only supports 'o'\n        var resize_function = function(resize_amount) {\n            return function() {\n                var marker = d3.select(this);\n                if (marker.attr(\"r\")) {\n                    marker.attr(\"r\", marker.attr(\"r\") * resize_amount);\n                } else if (marker.attr(\"width\") && marker.attr(\"height\")) {\n                    // resizes square marker\n                    var old_marker_size = parseFloat(marker.attr(\"width\"));\n                    var new_marker_size = old_marker_size * resize_amount;\n                    var diff_marker_size = (new_marker_size - old_marker_size) / 2;\n\n                    var new_x = parseFloat(marker.attr(\"x\")) - diff_marker_size;\n                    var new_y = parseFloat(marker.attr(\"y\")) - diff_marker_size;\n                    marker.attr(\"width\", new_marker_size);\n                    marker.attr(\"height\", new_marker_size);\n                    marker.attr(\"x\", new_x);\n                    marker.attr(\"y\", new_y);\n                } else {\n                    return true;\n                }\n            };\n        };\n\n        // add marker attributes\n        if (this._markers) {\n            this._markers\n                .style(\"stroke\", jsplotlib.color_to_hex(this._markeredgecolor))\n                .style(\"stroke-width\", this._markeredgewidth)\n                .style(\"stroke-opacity\", this._alpha)\n                .style(\"fill\", jsplotlib.color_to_hex(this._markerfacecolor))\n                .on(\"mouseover\", resize_function(1.25))\n                .on(\"mouseout\", resize_function(0.8));\n        }\n\n        return this;\n    };\n\n    return that;\n};\n\njsplotlib.plot = function(chart) {\n    /*\n      list of responsibilites\n       - holds all lines, bars, etc. (\"artists\")\n       - updates axis\n       - construct axis\n       - knows color_cycle\n       - scatter? s() functions?\n    */\n\n    // store chart object and append own methods\n    var that = {\n        chart: chart\n    };\n\n    that.axes_colorcycle_position = 0;\n    that.artist_count = 0;\n    that._artists = []; // we support multiple artists\n\n    that.add_artist = function(artist) {\n        if (artist) {\n            this._artists.push(artist);\n            artist._artist_id = this.artist_count++;\n            this._update_limits();\n        }\n\n        return this;\n    };\n\n    // set graph attributes\n    that._chartheight = parseInt(chart.attr(\"height\"), 10);\n    that._chartwidth = parseInt(chart.attr(\"width\"));\n    that._title_string = \"\";\n    that._title_size = 0;\n    that._xaxis = jsplotlib.construct_axis(that, \"x\");\n    that._yaxis = jsplotlib.construct_axis(that, \"y\");\n    that._axes = [that._xaxis, that._yaxis];\n\n    // returns the next color in the cycle\n    that.get_next_color = function() {\n        var cs = jsplotlib.rc['axes.color_cycle'][this.axes_colorcycle_position];\n        this.axes_colorcycle_position = (this.axes_colorcycle_position + 1) %\n            jsplotlib.rc['axes.color_cycle'].length;\n        return cs;\n    };\n\n    // setter functions\n    that.xlabel = function(xl) {\n        this._xaxis.set_label(xl);\n        return this;\n    };\n\n    that.ylabel = function(yl) {\n        this._yaxis.set_label(yl);\n        return this;\n    };\n\n    that.xaxis_off = function() {\n        this._xaxis._turn_off();\n        return this;\n    };\n\n    that.yaxis_off = function() {\n        this._yaxis._turn_off();\n        return this;\n    };\n\n    that.xaxis_on = function() {\n        this._xaxis._turn_on();\n        return this;\n    };\n\n    that.yaxis_on = function() {\n        this._yaxis._turn_on();\n        return this;\n    };\n\n    that.axis_on = function() {\n        this.yaxis_on();\n        this.xaxis_on();\n        return this;\n    };\n\n    that.axis_off = function() {\n        this.yaxis_off();\n        this.xaxis_off();\n        return this;\n    };\n\n    that.title = function(title_string) {\n        this._title_string = title_string;\n        this._title_size = this._chartheight * 0.1;\n        this._title_transform_string = \"translate(\" + this._chartwidth / 2 + \",\" +\n            this._title_size / 2 + \")\";\n        return this;\n    };\n\n    // sets the ylimits based on a minmax array/tuple\n    that._ylimits = function(min_max_tuple) {\n        this._yaxis._set_data_range(min_max_tuple);\n        return this;\n    };\n\n    that._xlimits = function(min_max_tuple) {\n        this._xaxis._set_data_range(min_max_tuple);\n        return this;\n    };\n\n    that._update_limits = function() {\n        //TODO: rework for histogram/bar charts\n        var i;\n        var xs = []; // all x-values\n        var ys = []; // all y-values\n\n        // calculate limits\n        for (i = 0; i < this._artists.length; i++) {\n            xs = xs.concat(this._artists[i]._x);\n            ys = ys.concat(this._artists[i]._y);\n        }\n\n        this._xlimits([d3.min(xs), d3.max(xs)]);\n        this._ylimits([d3.min(ys), d3.max(ys)]);\n\n        return this;\n    };\n\n    that.yformat = function(formatter) {\n        this._yaxis._set_formatter(formatter);\n        return this;\n    };\n\n    that.xformat = function(formatter) {\n        this._xaxis._set_formatter(formatter);\n        return this;\n    };\n\n    that.get_yscale = function() {\n        return this._yaxis.get_scale();\n    };\n\n    that.get_xscale = function() {\n        return this._xaxis.get_scale();\n    };\n\n    // creates axes\n    that._init_common = function() {\n        for (var i = 0; i < 2; i++) {\n            this._axes[i]._init(this);\n        }\n        this._height = this._chartheight - this._xaxis._size;\n        this._width = this._chartwidth - this._yaxis._size;\n        return this;\n    };\n\n    // draw axes and append graph title\n    that._draw_axes = function() {\n        for (var i = 0; i < this._axes.length; i++) {\n            this._axes[i]._draw_axis(this);\n            this._axes[i]._draw_label(this);\n        }\n\n        var myselector = \"#\" + chart.attr(\"id\") + \" .axis line, #\" + chart.attr(\n            \"id\") + \" .axis path\";\n        $(myselector).css(\"fill\", \"none\").css(\"stroke\", \"#000\");\n        d3.svg.axis(chart);\n        if (this._title_string !== \"\") {\n            that.chart.append(\"svg:g\").attr(\"class\", \"graph_title\").attr(\n                \"transform\", this._title_transform_string).append(\"text\").append(\n                \"tspan\").attr(\"text-anchor\", \"middle\").attr(\"class\", \"graph_title\").attr(\n                \"writing-mode\", \"rl-tb\").text(this._title_string);\n        }\n        return this;\n    };\n\n    // resize function for the chart\n    var chart_id = that.chart.attr(\"id\");\n    that.resize_function = function(resize_amount, direction) {\n        return function() {\n            var node = this;\n            while (node.id !== chart_id) {\n                node.parentNode.appendChild(node);\n                node = node.parentNode;\n            }\n            var object = d3.select(this);\n            var x0 = parseInt(object.attr(\"x\") || \"0\", 10);\n            var width0 = parseInt(object.attr(\"width\"), 10);\n            var y0 = parseInt(object.attr(\"y\") || \"0\", 10);\n            var height0 = parseInt(object.attr(\"height\"), 10);\n            var newwidth, newheight, newx, newy;\n            if (direction === \"grow\") {\n                object.attr(\"x_orig\", x0).attr(\"y_orig\", y0).attr(\"width_orig\",\n                    width0).attr(\"height_orig\", height0);\n                newwidth = width0 * resize_amount;\n                newheight = height0 * resize_amount;\n                newx = x0 - (resize_amount - 1) * width0 / 2;\n                newy = y0 - (resize_amount - 1) * height0 / 2;\n            } else if (direction === \"shrink\") {\n                newwidth = object.attr(\"width_orig\");\n                newheight = object.attr(\"height_orig\");\n                newx = object.attr(\"x_orig\");\n                newy = object.attr(\"y_orig\");\n            }\n            object.attr(\"x\", newx).attr(\"y\", newy).attr(\"height\", newheight).attr(\n                \"width\", newwidth);\n        };\n    };\n    /**\n     Draws the artists. Artists are respnsible for their drawing. Here we just initialize\n     the axes and the scaling.\n    **/\n    that.draw = function() {\n        var i;\n\n        this._init_common(); //\n\n        // draw lines\n        for (i = 0; i < this._artists.length; i++) {\n            this._artists[i].draw(this);\n        }\n\n        this._draw_axes();\n    };\n\n    that.update = function(kwargs) {\n        var i;\n\n        // pass to lines\n        for (i = 0; i < this._artists.length; i++) {\n            this._artists[i].update(kwargs);\n        }\n\n        // update own kwargs\n        if (kwargs && typeof kwargs === \"object\") {\n            for (var key in kwargs) {\n                if (kwargs.hasOwnProperty(key)) {\n                    var val = kwargs[key];\n\n                    switch (key) {\n                        case 'title':\n                            this.title(val);\n                            break;\n                        case 'xlabel':\n                            this.xlabel(val);\n                            break;\n                        case 'ylabel':\n                            this.ylabel(val);\n                            break;\n                    }\n                }\n            }\n        }\n\n        return this;\n    };\n\n    return that;\n};\n\n\n\n/** List of all supported line styles **/\njsplotlib.Line2D.lineStyles = {\n    '-': '_draw_solid',\n    '--': '_draw_dashed',\n    '-.': '_draw_dash_dot',\n    ':': '_draw_dotted',\n    'None': '_draw_nothing',\n    ' ': '_draw_nothing',\n    '': '_draw_nothing',\n};\n\njsplotlib.Line2D.lineMarkers = {\n    '.': 'point',\n    ',': 'pixel',\n    'o': 'circle',\n    'v': 'triangle_down',\n    '^': 'triangle_up',\n    '<': 'triangle_left',\n    '>': 'triangle_right',\n    '1': 'tri_down',\n    '2': 'tri_up',\n    '3': 'tri_left',\n    '4': 'tri_right',\n    '8': 'octagon',\n    's': 'square',\n    'p': 'pentagon',\n    '*': 'star',\n    'h': 'hexagon1',\n    'H': 'hexagon2',\n    '+': 'plus',\n    'x': 'x',\n    'D': 'diamond',\n    'd': 'thin_diamond',\n    '|': 'vline',\n    '_': 'hline',\n    //TICKLEFT: 'tickleft',\n    //TICKRIGHT: 'tickright',\n    //TICKUP: 'tickup',\n    //TICKDOWN: 'tickdown',\n    //CARETLEFT: 'caretleft',\n    //CARETRIGHT: 'caretright',\n    //CARETUP: 'caretup',\n    //CARETDOWN: 'caretdown',\n    \"None\": 'nothing',\n    //Sk.builtin.none.none$: 'nothing',\n    ' ': 'nothing',\n    '': 'nothing'\n};\n\n/**\n Color short keys\n**/\njsplotlib.colors = {\n    'b': 'blue',\n    'g': 'green',\n    'r': 'red',\n    'c': 'cyan',\n    'm': 'magenta',\n    'y': 'yellow',\n    'k': 'black',\n    'w': 'white'\n};\n\n/**\n Mapping of all possible CSS colors, that are supported by matplotlib\n**/\njsplotlib.cnames = {\n    'aliceblue': '#F0F8FF',\n    'antiquewhite': '#FAEBD7',\n    'aqua': '#00FFFF',\n    'aquamarine': '#7FFFD4',\n    'azure': '#F0FFFF',\n    'beige': '#F5F5DC',\n    'bisque': '#FFE4C4',\n    'black': '#000000',\n    'blanchedalmond': '#FFEBCD',\n    'blue': '#0000FF',\n    'blueviolet': '#8A2BE2',\n    'brown': '#A52A2A',\n    'burlywood': '#DEB887',\n    'cadetblue': '#5F9EA0',\n    'chartreuse': '#7FFF00',\n    'chocolate': '#D2691E',\n    'coral': '#FF7F50',\n    'cornflowerblue': '#6495ED',\n    'cornsilk': '#FFF8DC',\n    'crimson': '#DC143C',\n    'cyan': '#00FFFF',\n    'darkblue': '#00008B',\n    'darkcyan': '#008B8B',\n    'darkgoldenrod': '#B8860B',\n    'darkgray': '#A9A9A9',\n    'darkgreen': '#006400',\n    'darkkhaki': '#BDB76B',\n    'darkmagenta': '#8B008B',\n    'darkolivegreen': '#556B2F',\n    'darkorange': '#FF8C00',\n    'darkorchid': '#9932CC',\n    'darkred': '#8B0000',\n    'darksage': '#598556',\n    'darksalmon': '#E9967A',\n    'darkseagreen': '#8FBC8F',\n    'darkslateblue': '#483D8B',\n    'darkslategray': '#2F4F4F',\n    'darkturquoise': '#00CED1',\n    'darkviolet': '#9400D3',\n    'deeppink': '#FF1493',\n    'deepskyblue': '#00BFFF',\n    'dimgray': '#696969',\n    'dodgerblue': '#1E90FF',\n    'firebrick': '#B22222',\n    'floralwhite': '#FFFAF0',\n    'forestgreen': '#228B22',\n    'fuchsia': '#FF00FF',\n    'gainsboro': '#DCDCDC',\n    'ghostwhite': '#F8F8FF',\n    'gold': '#FFD700',\n    'goldenrod': '#DAA520',\n    'gray': '#808080',\n    'green': '#008000',\n    'greenyellow': '#ADFF2F',\n    'honeydew': '#F0FFF0',\n    'hotpink': '#FF69B4',\n    'indianred': '#CD5C5C',\n    'indigo': '#4B0082',\n    'ivory': '#FFFFF0',\n    'khaki': '#F0E68C',\n    'lavender': '#E6E6FA',\n    'lavenderblush': '#FFF0F5',\n    'lawngreen': '#7CFC00',\n    'lemonchiffon': '#FFFACD',\n    'lightblue': '#ADD8E6',\n    'lightcoral': '#F08080',\n    'lightcyan': '#E0FFFF',\n    'lightgoldenrodyellow': '#FAFAD2',\n    'lightgreen': '#90EE90',\n    'lightgray': '#D3D3D3',\n    'lightpink': '#FFB6C1',\n    'lightsage': '#BCECAC',\n    'lightsalmon': '#FFA07A',\n    'lightseagreen': '#20B2AA',\n    'lightskyblue': '#87CEFA',\n    'lightslategray': '#778899',\n    'lightsteelblue': '#B0C4DE',\n    'lightyellow': '#FFFFE0',\n    'lime': '#00FF00',\n    'limegreen': '#32CD32',\n    'linen': '#FAF0E6',\n    'magenta': '#FF00FF',\n    'maroon': '#800000',\n    'mediumaquamarine': '#66CDAA',\n    'mediumblue': '#0000CD',\n    'mediumorchid': '#BA55D3',\n    'mediumpurple': '#9370DB',\n    'mediumseagreen': '#3CB371',\n    'mediumslateblue': '#7B68EE',\n    'mediumspringgreen': '#00FA9A',\n    'mediumturquoise': '#48D1CC',\n    'mediumvioletred': '#C71585',\n    'midnightblue': '#191970',\n    'mintcream': '#F5FFFA',\n    'mistyrose': '#FFE4E1',\n    'moccasin': '#FFE4B5',\n    'navajowhite': '#FFDEAD',\n    'navy': '#000080',\n    'oldlace': '#FDF5E6',\n    'olive': '#808000',\n    'olivedrab': '#6B8E23',\n    'orange': '#FFA500',\n    'orangered': '#FF4500',\n    'orchid': '#DA70D6',\n    'palegoldenrod': '#EEE8AA',\n    'palegreen': '#98FB98',\n    'paleturquoise': '#AFEEEE',\n    'palevioletred': '#DB7093',\n    'papayawhip': '#FFEFD5',\n    'peachpuff': '#FFDAB9',\n    'peru': '#CD853F',\n    'pink': '#FFC0CB',\n    'plum': '#DDA0DD',\n    'powderblue': '#B0E0E6',\n    'purple': '#800080',\n    'red': '#FF0000',\n    'rosybrown': '#BC8F8F',\n    'royalblue': '#4169E1',\n    'saddlebrown': '#8B4513',\n    'salmon': '#FA8072',\n    'sage': '#87AE73',\n    'sandybrown': '#FAA460',\n    'seagreen': '#2E8B57',\n    'seashell': '#FFF5EE',\n    'sienna': '#A0522D',\n    'silver': '#C0C0C0',\n    'skyblue': '#87CEEB',\n    'slateblue': '#6A5ACD',\n    'slategray': '#708090',\n    'snow': '#FFFAFA',\n    'springgreen': '#00FF7F',\n    'steelblue': '#4682B4',\n    'tan': '#D2B48C',\n    'teal': '#008080',\n    'thistle': '#D8BFD8',\n    'tomato': '#FF6347',\n    'turquoise': '#40E0D0',\n    'violet': '#EE82EE',\n    'wheat': '#F5DEB3',\n    'white': '#FFFFFF',\n    'whitesmoke': '#F5F5F5',\n    'yellow': '#FFFF00',\n    'yellowgreen': '#9ACD32'\n};\n\njsplotlib.color_to_hex = function(color) {\n    // is color a shortcut?\n    if (jsplotlib.colors[color])\n        color = jsplotlib.colors[color];\n\n    // is inside cnames array?\n    if (jsplotlib.cnames[color])\n        return jsplotlib.cnames[color];\n\n    // check if it is already a hex value\n    if (typeof color == \"string\") {\n        var match = color.match(/^#(?:[0-9a-fA-F]{3}){1,2}$/);\n        if (match && match.length === 1)\n            return match[0];\n    }\n\n    // add rgb colors here\n    if (Array.isArray(color) && color.length === 3) {\n        return jsplotlib.rgb2hex(color);\n    }\n\n    // back to default\n    return jsplotlib.cnames[jsplotlib.rc['lines.color']];\n};\n\njsplotlib.get_color = function(cs) {\n    return jsplotlib.colors[cs] ? jsplotlib.colors[cs] : jsplotlib.colors.b;\n};\n\n/**\n Creates the d3 svg element at the specified dom element with given width and height\n**/\njsplotlib.make_chart = function(width, height, console, insert_mode,\n    attributes) {\n    chart_counter++;\n    var DEFAULT_PADDING = 30;\n    console = console || document.body;\n    width = width - 2 * DEFAULT_PADDING || 500;\n    height = height - 2 * DEFAULT_PADDING || 200;\n    attributes = attributes || {};\n\n    // create id, if not given\n    if (!('id' in attributes)) {\n        attributes.id = 'chart' + chart_counter;\n    }\n\n    var chart = d3.select(console.console).append('div').append('svg');\n    /*\n    if (!insert_mode) {\n        chart = d3.select(insert_container).append('svg');\n    } else {\n        chart = d3.select(insert_container).insert('svg', insert_mode);\n    }\n    */\n\n    // set css classes\n    $(chart[0]).parent().hide();\n    chart.attr('class', 'chart');\n    chart.attr('width', width);\n    chart.attr('height', height);\n    chart.attr('chart_count', chart_counter);\n    // set additional given attributes\n    for (var attribute in attributes) {\n        if (attributes.hasOwnProperty(attribute)) {\n            chart.attr(attribute, attributes[attribute]);\n        }\n    }\n\n    $('.chart#' + attributes.id).css('padding-left', DEFAULT_PADDING + 'px');\n    return chart;\n};\n\n/**\n Creates x or y axis and auto scales them\n**/\njsplotlib.construct_axis = function() {\n    var axis_count = 0;\n    return function(parent_graph, x_or_y) {\n        var that = {};\n        that._id = \"axis\" + axis_count++;\n        that._will_draw_label = false;\n        that._will_draw_axis = true;\n        that._x_or_y = x_or_y;\n        that._size = 0;\n        that._label_offset = 0;\n        that._label_string = \"\";\n        if (x_or_y === \"x\") {\n            that._axis_proportion = 0.12;\n            that._label_proportion = 0.12;\n        } else if (x_or_y === \"y\") {\n            that._axis_proportion = 0.07;\n            that._label_proportion = 0.05;\n        } else {\n            throw \"Invalid axis type (must be x or y): \" + this._x_or_y;\n        }\n        that._proportion = that._axis_proportion;\n        that.n_ticks = 4;\n        that.set_n_ticks = function(n) {\n            this.n_ticks = n;\n        };\n        that.set_label = function(label_string) {\n            this._label_string = label_string;\n            this._will_draw_label = true;\n            this._proportion = this._axis_proportion + this._label_proportion;\n            return this;\n        };\n        that._turn_off = function() {\n            this._will_draw_axis = false;\n            return this;\n        };\n        that._turn_on = function() {\n            this._will_draw_axis = true;\n            return this;\n        };\n        that.set_bar_limits = function(minmaxplus) {\n            var min = minmaxplus[0];\n            var oldmax = minmaxplus[1];\n            var plus = minmaxplus[2];\n            var newmax;\n            if (oldmax instanceof Date) {\n                newmax = new Date(oldmax.getTime() + plus);\n            } else {\n                newmax = oldmax + plus;\n            }\n            this._set_data_range([min, newmax]);\n        };\n\n        that._set_data_range = function(minmax) {\n            this._min = minmax[0];\n            this._max = minmax[1];\n            if (this._min instanceof Date || this._max instanceof Date) {\n                this._scale = d3.time.scale();\n                this._min = new Date(this._min);\n                this._max = new Date(this._max);\n            } else {\n                this._scale = d3.scale.linear();\n            }\n            this._domain = [this._min, this._max*1.1];\n            return this;\n        };\n        that._set_formatter = function(formatter) {\n            this._formatter = formatter;\n            return this;\n        };\n        that.get_scale = function() {\n            if (this._x_or_y === \"x\") {\n                this._range = [parent_graph._yaxis._size, parent_graph._chartwidth];\n            } else if (this._x_or_y === \"y\") {\n                this._range = [parent_graph._height, parent_graph._title_size];\n            }\n            this._scale\n                .domain(this._domain)\n                .range(this._range);\n            return this._scale;\n        };\n        that._init = function(chart) {\n            var dimension;\n            if (this._will_draw_axis) {\n                var proportion_increase = 0;\n                if (this._x_or_y === \"x\") {\n                    dimension = parent_graph._chartheight;\n                } else if (this._x_or_y === \"y\") {\n                    // Handle digits on the y-axis!\n                    proportion_increase += .015*this._max.toLocaleString().length;\n                    dimension = parent_graph._chartwidth;\n                } else {\n                    throw \"Invalid axis type (must be x or y): \" + this._x_or_y;\n                }\n                this._size = dimension * (this._proportion+proportion_increase);\n                this._label_offset = this._size * this._label_proportion;\n            } else {\n                this._size = 0;\n            }\n            return this;\n        };\n        that._compute_transform_string = function() {\n            var offset_h, offset_v;\n            var offset_label_h, offset_label_v;\n            var label_rotation = \"\";\n            if (this._x_or_y === \"x\") {\n                offset_h = 0;\n                offset_v = parent_graph._height;\n                offset_label_h = parent_graph._yaxis._size + parent_graph._chartwidth /\n                    4;\n                offset_label_v = parent_graph._height + this._size - this._label_offset;\n                this._writing_mode = \"lr-tb\";\n                this._orientation = \"bottom\";\n            } else if (this._x_or_y === \"y\") {\n                offset_h = this._size;\n                offset_v = 0;\n                offset_label_h = this._label_offset;\n                offset_label_v = parent_graph._chartheight / 2;\n                label_rotation = \"rotate(180)\";\n                this._writing_mode = \"tb-rl\";\n                this._orientation = \"left\";\n            } else {\n                throw \"Invalid axis type (must be x or y): \" + this._x_or_y;\n            }\n            this._transform_string = \"translate(\" + offset_h + \",\" + offset_v +\n                \")scale(1,1)\";\n            this._label_transform_string = \"translate(\" + offset_label_h + \",\" +\n                offset_label_v + \")\" + label_rotation;\n        };\n        that._draw_axis = function() {\n            if (this._will_draw_axis) {\n                this._formatter = this._formatter || this.get_scale().tickFormat(this\n                    .n_ticks);\n                this._compute_transform_string();\n                this._axis = d3.svg.axis().scale(this.get_scale()).ticks(this.n_ticks)\n                    .orient(this._orientation).tickSubdivide(0).tickFormat(this._formatter);\n                parent_graph.chart.append(\"svg:g\").attr(\"id\", this._id).attr(\"class\",\n                    this._x_or_y + \" axis\").attr(\"transform\", this._transform_string).call(\n                    this._axis);\n            }\n        };\n        that._draw_label = function() {\n            this._compute_transform_string();\n            if (this._will_draw_axis && this._will_draw_label) {\n                parent_graph.chart.append(\"svg:g\").attr(\"class\", this._x_or_y +\n                        \" axis_label\").attr(\"transform\", this._label_transform_string).append(\n                        \"text\").append(\"tspan\").attr(\"text-anchor\", \"middle\").attr(\"class\",\n                        this._x_or_y + \" axis_label\").attr(\"writing-mode\", this._writing_mode)\n                    .text(this._label_string);\n            }\n        };\n        return that;\n    };\n}();\n\njsplotlib.parse_marker = function(style) {\n    if (!style) return \"x\";\n    switch (style) {\n        case '.':\n            return \".\";\n        case ',':\n            return \"x\";\n        case 'o':\n            return \"o\";\n        case 'v':\n            return \"x\";\n        case '^':\n            return \"x\";\n        case '<':\n            return \"x\";\n        case '>':\n            return \"x\";\n        case '1':\n            return \"x\";\n        case '2':\n            return \"x\";\n        case '3':\n            return \"x\";\n        case '4':\n            return \"x\";\n        case 's':\n            return \"s\";\n        case 'p':\n            return \"x\";\n        case '*':\n            return \"x\";\n        case 'h':\n            return \"x\";\n        case 'H':\n            return \"x\";\n        case '+':\n            return \"x\";\n        case 'x':\n            return \"x\";\n        case 'D':\n            return \"x\";\n        case 'd':\n            return \"x\";\n        case '|':\n            return \"x\";\n        case '_':\n            return \"x\";\n        default:\n            return \"\";\n    }\n};\n\n/**\nProcess a MATLAB style color/line style format string.  Return a\n(*linestyle*, *color*) tuple as a result of the processing.  Default\nvalues are ('-', 'b').  Example format strings include:\n\n* 'ko': black circles\n* '.b': blue dots\n* 'r--': red dashed lines\n\n.. seealso::\n\n    :func:`~matplotlib.Line2D.lineStyles` and\n    :func:`~matplotlib.pyplot.colors`\n        for all possible styles and color format string.\n**/\njsplotlib._process_plot_format = function(fmt) {\n    var linestyle = null;\n    var marker = null;\n    var color = null;\n\n    // Is fmt just a colorspec\n    try {\n        color = jsplotlib.to_rgb(fmt);\n        if (color) {\n            return {\n                'linestyle': linestyle,\n                'marker': marker,\n                'color': color\n            };\n        }\n    } catch (e) {}\n\n    // handle the multi char special cases and strip them for the string\n    if (fmt.search(/--/) >= 0) {\n        linestyle = '--';\n        fmt = fmt.replace(/--/, '');\n    }\n    if (fmt.search(/-\\./) >= 0) {\n        linestyle = '-.';\n        fmt = fmt.replace(/-\\./, '');\n    }\n    if (fmt.search(/ /) >= 0) {\n        linestyle = '';\n        fmt = fmt.replace(/ /, '');\n    }\n\n    var i;\n    for (i = 0; i < fmt.length; i++) {\n        var c = fmt.charAt(i);\n        if (jsplotlib.Line2D.lineStyles[c]) {\n            if (linestyle) {\n                throw new Sk.builtin.ValueError('Illegal format string \"' + fmt +\n                    '\"; two linestyle symbols');\n            }\n            linestyle = c;\n        } else if (jsplotlib.Line2D.lineMarkers[c]) {\n            if (marker) {\n                throw new Sk.builtin.ValueError('Illegal format string \"' + fmt +\n                    '\"; two marker symbols');\n            }\n            marker = c;\n        } else if (jsplotlib.colors[c]) {\n            if (color) {\n                throw new Sk.builtin.ValueError('Illegal format string \"' + fmt +\n                    '\"; two color symbols');\n            }\n            color = c;\n        } else {\n            throw new Sk.builtin.ValueError('Unrecognized character ' + c +\n                ' in format string');\n        }\n    }\n\n    if (!linestyle && !marker) {\n        // use defaults --> rcParams['lines.linestyle']\n        linestyle = '-';\n    }\n    if (!linestyle) {\n        linestyle = ' ';\n    }\n    if (!marker) {\n        marker = '';\n    }\n\n    return {\n        'linestyle': linestyle,\n        'marker': marker,\n        'color': color\n    };\n};\n\n/**\n https://github.com/matplotlib/matplotlib/blob/master/lib/matplotlib/colors.py\n http://matplotlib.org/api/colors_api.html\n\n  Returns an *RGB* tuple of three floats from 0-1.\n\n  *arg* can be an *RGB* or *RGBA* sequence or a string in any of\n  several forms:\n\n      1) a letter from the set 'rgbcmykw'\n      2) a hex color string, like '#00FFFF'\n      3) a standard name, like 'aqua'\n      4) a string representation of a float, like '0.4',\n         indicating gray on a 0-1 scale\n\n  if *arg* is *RGBA*, the *A* will simply be discarded.\n**/\njsplotlib.to_rgb = function(fmt) {\n    if (!fmt) return null;\n\n    var color = null;\n\n    if (typeof fmt == \"string\") {\n        fmt_lower = fmt.toLowerCase();\n\n        if (jsplotlib.colors[fmt_lower])\n            return jsplotlib.hex2color(jsplotlib.cnames[jsplotlib.colors[fmt_lower]]);\n\n        // is inside cnames array?\n        if (jsplotlib.cnames[fmt_lower])\n            return jsplotlib.hex2color(jsplotlib.cnames[fmt_lower]);\n\n        if (fmt_lower.indexOf('#') === 0) {\n            return jsplotlib.hex2color(fmt_lower);\n        }\n\n        // is it simple grey shade?\n        var fl = parseFloat(fmt_lower);\n        if (isNaN(fl)) {\n            throw new Sk.builtin.ValueError('cannot convert argument to rgb sequence');\n        }\n\n        if (fl < 0 || fl > 1) {\n            throw new Sk.builtin.ValueError('gray (string) must be in range 0-1');\n        }\n\n        return [fl, fl, fl];\n    }\n\n    // check if its a color tuple [r,g,b, [a]] with values from [0-1]\n    if (Array.isArray(fmt)) {\n        if (fmt.length > 4 || fmt.length < 3)\n            throw new Sk.builtin.ValueError('sequence length is ' + fmt.length +\n                '; must be 3 or 4');\n\n        color = fmt.slice(0, 3);\n        var i;\n\n        for (i = 0; i < 3; i++) {\n            var fl_rgb = parseFloat(fmt);\n\n            if (fl_rgb < 0 || fl_rgb > 1)\n                throw new Sk.builtin.ValueError(\n                    'number in rbg sequence outside 0-1 range');\n        }\n    }\n\n    return color;\n};\n\n/**\n  Take a hex string *s* and return the corresponding rgb 3-tuple\n  Example: #efefef -> (0.93725, 0.93725, 0.93725)\n**/\njsplotlib.hex2color = function(s) {\n    if (!s || typeof s != \"string\") {\n        throw new Sk.builtin.TypeError(\"hex2color requires a string argument\");\n    }\n    // check if it is a hex value\n    var i;\n    var s_copy = s;\n    var hex_tuple = [];\n    for (i = 0; i < 3; i++) {\n        var match = s_copy.match(/(?:[0-9a-fA-F]){1,2}$/);\n        if (match && match.length === 1) {\n            hex_tuple.push(match[0]);\n            s_copy = s_copy.substring(0, match.index);\n        }\n    }\n    //var match = s.match(/^#(?:[0-9a-fA-F]{3}){1,2}$/);\n    if (hex_tuple.length === 3) {\n        // yeah positiv --> convert into right color spec\n        var color = [];\n        color[0] = parseInt(hex_tuple[0], 16) / 255.0;\n        color[1] = parseInt(hex_tuple[1], 16) / 255.0;\n        color[2] = parseInt(hex_tuple[2], 16) / 255.0;\n\n        return color.reverse();\n    } else {\n        throw new Sk.builtin.ValueError('invalid hex color string \"' + s + '\"');\n    }\n};\n\n/**\n  Expects and rgb tuple with values [0,1]\n**/\njsplotlib.rgb2hex = function(rgb) {\n    if (!rgb) return null;\n\n    if (rgb.length && rgb.length >= 3) {\n        var i;\n        // some hacky code to rebuild string format :(\n        var hex_str = '#';\n        for (i = 0; i < 3; i++) {\n            var val = Math.round(rgb[i] * 255).toString(16);\n            hex_str += val.length == 2 ? val : '0' + val;\n        }\n\n        return hex_str;\n    }\n};\n\njsplotlib.linspace = function(min, max, N) {\n    var newscale = d3.scale.linear().domain([1, N]).range([min, max]);\n    var data = [];\n    for (var i = 1; i <= N; i++) {\n        var output = newscale(i);\n        if (min instanceof Date) {\n            output = new Date(output);\n        }\n        data.push(output);\n    }\n    return data;\n};\n\njsplotlib.range = function(N) {\n    var l = [];\n    for (var i = 0; i < N; i++) {\n        l.push(i);\n    }\n    return l;\n};\n\njsplotlib.ones = function(N) {\n    var l = [];\n    for (var i = 0; i < N; i++) {\n        l.push(1);\n    }\n    return l;\n};\n\n// Skulpt translation\nvar $builtinmodule = function(name) {\n    var mod = {};\n    var chart;\n    var plot; // TODO, we should support multiple lines here\n    var canvas;\n\n    // import numpy\n    var CLASS_NDARRAY = \"numpy.ndarray\"; // maybe make identifier accessible in numpy module\n    var np = Sk.importModule(\"numpy\");\n    var ndarray_f = np['$d'].array.func_code;\n    var getitem_f = np['$d'][CLASS_NDARRAY]['__getitem__'].func_code;\n    var ndarray = Sk.misceval.callsim(np['$d'].array.func_code, new Sk.builtin.list([1, 2, 3, 4]));\n\n    var create_chart = function() {\n        /* test if Canvas is available should be moved to create_chart function */\n        if (Sk.console === undefined) {\n            throw new Sk.builtin.NameError(\n                \"Can not resolve drawing area. Sk.console is undefined!\");\n        }\n\n        if (!chart) {\n            //$(Sk.matplotlibCanvas).empty();\n            var width = Sk.console.height * 2;\n            var height = Sk.console.height * 1.25;\n            chart = jsplotlib.make_chart(width, height, Sk.console, false);\n        }\n    };\n\n    mod.values = Array();\n    // Main plotting function\n    var plot_f = function(kwa) {\n        // http://matplotlib.org/api/pyplot_api.html\n        // http://matplotlib.org/api/artist_api.html#matplotlib.lines.Line2D\n        //debugger;\n        Sk.builtin.pyCheckArgs(\"plotk\", arguments, 1, Infinity, true, false);\n        args = Array.prototype.slice.call(arguments, 1);\n        mod.values.push(args);\n        kwargs = new Sk.builtins.dict(kwa); // is pretty useless for handling kwargs\n        kwargs = Sk.ffi.remapToJs(kwargs); // create a proper dict\n\n        // try parsing plot args\n        // possible xdata, ydata, stylestring\n        // or x1, y1, stylestring1, x2, y2, stylestring2\n        // or ydata, stylestring\n        /*\n            plot(x, y)        # plot x and y using default line style and color\n            plot(x, y, 'bo')  # plot x and y using blue circle markers\n            plot(y)           # plot y using x as index array 0..N-1\n            plot(y, 'r+')     # ditto, but with red plusses\n        */\n\n        // variable definitions for args\n        var xdata = [];\n        var ydata = [];\n        var stylestring = []; // we support only one at the moment\n        var i = 0;\n        var lines = 0;\n        var xdata_not_ydata_flag = true;\n        var slice = new Sk.builtin.slice(0, undefined, 1); // getting complete first dimension of ndarray\n\n        for (i = 0; i < args.length; i++) {\n            if (args[i] instanceof Sk.builtin.list || Sk.abstr.typeName(args[i]) === CLASS_NDARRAY) {\n                // special treatment for ndarrays, though we allow basic lists too\n                var _unpacked;\n                if (Sk.abstr.typeName(args[i]) === CLASS_NDARRAY) {\n                    // we get the first dimension, no 2-dim data\n                    _unpacked = Sk.ffi.unwrapn(args[i]);\n                    var first_dim_size = 0;\n                    if (_unpacked && _unpacked.shape && _unpacked.shape[0]) {\n                        first_dim_size = _unpacked.shape[0];\n                    } else {\n                        throw new Sk.builtin.ValueError('args contain \"' + CLASS_NDARRAY + '\" without elements or malformed shape.');\n                    }\n                    _unpacked = _unpacked.buffer.slice(0, first_dim_size); // buffer array of first dimension\n                    _unpacked = _unpacked.map(function(x) {\n                        return Sk.ffi.remapToJs(x);\n                    })\n                } else {\n                    _unpacked = Sk.ffi.remapToJs(args[i]);\n                }\n\n                // unwraps x and y, but no 2-dim-data\n                if (xdata_not_ydata_flag) {\n                    xdata.push(_unpacked);\n                    xdata_not_ydata_flag = false;\n                } else {\n                    ydata.push(_unpacked);\n                    xdata_not_ydata_flag = true;\n                }\n            } else if (Sk.builtin.checkString(args[i])) {\n                stylestring.push(Sk.ffi.remapToJs(args[i]));\n            } else {\n                throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(args[i]) +\n                    \"' is not supported for *args[\" + i + \"].\");\n            }\n        }\n\n        /* handle special cases\n            only supplied y\n            only supplied 1 array and stylestring\n        */\n        if ((args.length === 1) || (args.length === 2 && (xdata.length === 1 &&\n                ydata.length === 0))) {\n            // only y supplied\n            xdata.forEach(function(element) {\n                ydata.push(element);\n            });\n            xdata[0] = [];\n        }\n        \n        \n        if (Sk.skip_drawing !== true) {\n\n            // empty canvas from previous plots\n            create_chart();\n            // create new plot instance, should be replaced with Line2D and then added to the plot\n            if (!plot) {\n                plot = jsplotlib.plot(chart);\n            }\n\n            // create line objects\n            var line;\n\n            if (xdata.length === 1 && ydata.length === 1 && stylestring.length === 0) {\n                // handle case for plot(x, y)\n                // Where the x and y are integers, not lists\n                line = new jsplotlib.Line2D(xdata[0], ydata[0]);\n                plot.add_artist(line);\n            } else if (xdata.length === ydata.length && xdata.length === stylestring.length) {\n                for (i = 0; i < xdata.length; i++) {\n                    line = new jsplotlib.Line2D(xdata[i], ydata[i]);\n                    var ftm_tuple = jsplotlib._process_plot_format(stylestring[i]);\n                    line.update({\n                        'linestyle': ftm_tuple.linestyle,\n                        'marker': jsplotlib.parse_marker(ftm_tuple.marker),\n                        'color': ftm_tuple.color\n                    });\n                    plot.add_artist(line);\n                }\n            } else {\n                throw new Sk.builtin.ValueError('Cannot parse given combination of \"*args\"!');\n            }\n\n            // set kwargs that apply for all lines\n            plot.update(kwargs);\n        } else {\n            if (!plot) {\n                plot = {\"_artists\":[]};\n            }\n            var line;\n            if (xdata.length === 1 && ydata.length === 1 && stylestring.length === 0) {\n                plot._artists.push([xdata[0], ydata[0]]);\n            } else if (xdata.length === ydata.length && xdata.length === stylestring.length) {\n                for (i = 0; i < xdata.length; i++) {\n                    plot._artists.push([xdata[i], ydata[i]]);\n                }\n            } else {\n                throw new Sk.builtin.ValueError('Cannot parse given combination of \"*args\"!');\n            }\n            \n        }\n\n        // result\n        var result = [];\n\n        return new Sk.builtins.tuple(result);\n    };\n    plot_f.co_kwargs = true;\n    mod.plot = new Sk.builtin.func(plot_f);\n\n    var show_f = function() {\n        // call drawing routine\n        if (Sk.skip_drawing !== true) {\n            if (plot && plot.draw) {\n                plot.draw();\n            } else {\n                throw new Sk.builtin.ValueError(\n                    \"Can not call show without any plot created.\");\n            }\n            if (Sk.console.png_mode) {\n                var lines = plot._artists.map(function(elem) { return [elem._x, elem._y] })\n                var xml = new XMLSerializer().serializeToString(chart[0][0]);\n                var data = \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(xml)));\n                var img  = document.createElement(\"img\");\n                img.setAttribute('src', data);\n                img.style.display = 'block';\n                img.onload = function() {\n                    img.onload = null;\n                    //TODO: Make this capture a class descendant. Cross the D3/Jquery barrier!\n                    var canvas = document.createElement('canvas');\n                    canvas.width = Sk.console.height * 2;\n                    canvas.height = Sk.console.height * 1.25;\n                    var ctx = canvas.getContext('2d');\n                    ctx.drawImage(img, 0, 0);\n                    var canvasUrl = canvas.toDataURL(\"image/png\");\n                    img.setAttribute('src', canvasUrl);\n                    chart[0][0].parentNode.replaceChild(img, chart[0][0])\n                    Sk.console.printHtml(img, lines);\n                }\n                img.onerror = function() {\n                    \n                }\n            } else {\n                Sk.console.printHtml(chart, lines);\n            }\n        } else {\n            var lines = plot._artists;\n            Sk.console.printHtml(chart, lines);\n        }\n    };\n    mod.show = new Sk.builtin.func(show_f);\n\n    var title_f = function(label, fontdict, loc) {\n        Sk.builtin.pyCheckArgs(\"title\", arguments, 1, 3);\n\n        if (!Sk.builtin.checkString(label)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(label) +\n                \"' is not supported for title.\");\n        }\n\n        var label_unwrap = Sk.ffi.remapToJs(label);\n\n        if (Sk.skip_drawing !== true) {\n            create_chart();\n            // create new plot instance, should be replaced with Line2D and then added to the plot\n            if (!plot) {\n                plot = jsplotlib.plot(chart);\n            }\n\n            if (plot && plot.title) {\n                plot.title(label_unwrap);\n            }\n        }\n\n        return new Sk.builtin.str(label_unwrap);\n    };\n\n    title_f.co_varnames = ['label', 'fontdict', 'loc', ];\n    title_f.$defaults = [null, Sk.builtin.none.none$, Sk.builtin.none.none$,\n        Sk.builtin.none.none$\n    ];\n    mod.title = new Sk.builtin.func(title_f);\n\n    var axis_f = function(label, fontdict, loc) {\n        Sk.builtin.pyCheckArgs(\"axis\", arguments, 0, 3);\n\n        // when called without any arguments it should return the current axis limits\n\n        if (plot && plot._axes) {\n            console.log(plot._axes);\n        }\n\n        // >>> axis(v)\n        // sets the min and max of the x and y axes, with\n        // ``v = [xmin, xmax, ymin, ymax]``.::\n\n        //The xmin, xmax, ymin, ymax tuple is returned\n        var res;\n\n        return Sk.ffi.remapToPy([]);\n    };\n\n    axis_f.co_varnames = ['label', 'fontdict', 'loc', ];\n    axis_f.$defaults = [null, Sk.builtin.none.none$, Sk.builtin.none.none$,\n        Sk.builtin.none.none$\n    ];\n    mod.axis = new Sk.builtin.func(axis_f);\n\n    var xlabel_f = function(s, fontdict, loc) {\n        Sk.builtin.pyCheckArgs(\"xlabel\", arguments, 1, 3);\n\n        if (!Sk.builtin.checkString(s)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(s) +\n                \"' is not supported for s.\");\n        }\n\n        if (Sk.skip_drawing !== true) {\n            create_chart();\n            // create new plot instance, should be replaced with Line2D and then added to the plot\n            if (!plot) {\n                plot = jsplotlib.plot(chart);\n            }\n\n            if (plot && plot.xlabel) {\n                plot.xlabel(Sk.ffi.remapToJs(s));\n            }\n        }\n    };\n\n    xlabel_f.co_varnames = ['s', 'fontdict', 'loc', ];\n    xlabel_f.$defaults = [null, Sk.builtin.none.none$, Sk.builtin.none.none$,\n        Sk.builtin.none.none$\n    ];\n    mod.xlabel = new Sk.builtin.func(xlabel_f);\n\n    var ylabel_f = function(s, fontdict, loc) {\n        Sk.builtin.pyCheckArgs(\"ylabel\", arguments, 1, 3);\n\n        if (!Sk.builtin.checkString(s)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(s) +\n                \"' is not supported for s.\");\n        }\n\n        if (Sk.skip_drawing !== true) {\n            create_chart();\n            // create new plot instance, should be replaced with Line2D and then added to the plot\n            if (!plot) {\n                plot = jsplotlib.plot(chart);\n            }\n\n            if (plot && plot.ylabel) {\n                plot.ylabel(Sk.ffi.remapToJs(s));\n            }\n        }\n    };\n\n    ylabel_f.co_varnames = ['s', 'fontdict', 'loc', ];\n    ylabel_f.$defaults = [null, Sk.builtin.none.none$, Sk.builtin.none.none$,\n        Sk.builtin.none.none$\n    ];\n    mod.ylabel = new Sk.builtin.func(ylabel_f);\n\n    // Clear the current figure\n    var clf_f = function() {\n        // clear all\n        chart = null;\n        plot = null;\n\n        /*if (Sk.matplotlibCanvas !== undefined) {\n            $(Sk.matplotlibCanvas).empty();\n        }*/\n    };\n\n    mod.clf = new Sk.builtin.func(clf_f);\n\n    /* list of not implemented methods */\n    mod.findobj = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"findobj is not yet implemented\");\n    });\n    mod.switch_backend = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"switch_backend is not yet implemented\");\n    });\n    mod.isinteractive = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"isinteractive is not yet implemented\");\n    });\n    mod.ioff = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"ioff is not yet implemented\");\n    });\n    mod.ion = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"ion is not yet implemented\");\n    });\n    mod.pause = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"pause is not yet implemented\");\n    });\n    mod.rc = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"rc is not yet implemented\");\n    });\n    mod.rc_context = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"rc_context is not yet implemented\");\n    });\n    mod.rcdefaults = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"rcdefaults is not yet implemented\");\n    });\n    mod.gci = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"gci is not yet implemented\");\n    });\n    mod.sci = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"sci is not yet implemented\");\n    });\n    mod.xkcd = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"xkcd is not yet implemented\");\n    });\n    mod.figure = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"figure is not yet implemented\");\n    });\n    mod.gcf = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"gcf is not yet implemented\");\n    });\n    mod.get_fignums = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"get_fignums is not yet implemented\");\n    });\n    mod.get_figlabels = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"get_figlabels is not yet implemented\");\n    });\n    mod.get_current_fig_manager = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"get_current_fig_manager is not yet implemented\");\n    });\n    mod.connect = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"connect is not yet implemented\");\n    });\n    mod.disconnect = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"disconnect is not yet implemented\");\n    });\n    mod.close = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"close is not yet implemented\");\n    });\n    mod.savefig = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"savefig is not yet implemented\");\n    });\n    mod.ginput = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"ginput is not yet implemented\");\n    });\n    mod.waitforbuttonpress = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"waitforbuttonpress is not yet implemented\");\n    });\n    mod.figtext = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"figtext is not yet implemented\");\n    });\n    mod.suptitle = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"suptitle is not yet implemented\");\n    });\n    mod.figimage = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"figimage is not yet implemented\");\n    });\n    mod.figlegend = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"figlegend is not yet implemented\");\n    });\n    mod.hold = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"hold is not yet implemented\");\n    });\n    mod.ishold = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"ishold is not yet implemented\");\n    });\n    mod.over = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"over is not yet implemented\");\n    });\n    mod.delaxes = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"delaxes is not yet implemented\");\n    });\n    mod.sca = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"sca is not yet implemented\");\n    });\n    mod.gca = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"gca is not yet implemented\");\n    });\n    mod.subplot = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"subplot is not yet implemented\");\n    });\n    mod.subplots = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"subplots is not yet implemented\");\n    });\n    mod.subplot2grid = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"subplot2grid is not yet implemented\");\n    });\n    mod.twinx = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"twinx is not yet implemented\");\n    });\n    mod.twiny = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"twiny is not yet implemented\");\n    });\n    mod.subplots_adjust = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"subplots_adjust is not yet implemented\");\n    });\n    mod.subplot_tool = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"subplot_tool is not yet implemented\");\n    });\n    mod.tight_layout = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"tight_layout is not yet implemented\");\n    });\n    mod.box = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"box is not yet implemented\");\n    });\n    mod.xlim = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"xlim is not yet implemented\");\n    });\n    mod.ylim = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"ylim is not yet implemented\");\n    });\n    mod.xscale = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"xscale is not yet implemented\");\n    });\n    mod.yscale = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"yscale is not yet implemented\");\n    });\n    mod.xticks = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"xticks is not yet implemented\");\n    });\n    mod.yticks = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"yticks is not yet implemented\");\n    });\n    mod.minorticks_on = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"minorticks_on is not yet implemented\");\n    });\n    mod.minorticks_off = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"minorticks_off is not yet implemented\");\n    });\n    mod.rgrids = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"rgrids is not yet implemented\");\n    });\n    mod.thetagrids = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"thetagrids is not yet implemented\");\n    });\n    mod.plotting = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"plotting is not yet implemented\");\n    });\n    mod.get_plot_commands = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"get_plot_commands is not yet implemented\");\n    });\n    mod.colors = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"colors is not yet implemented\");\n    });\n    mod.colormaps = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"colormaps is not yet implemented\");\n    });\n    mod._setup_pyplot_info_docstrings = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"_setup_pyplot_info_docstrings is not yet implemented\");\n    });\n    mod.colorbar = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"colorbar is not yet implemented\");\n    });\n    mod.clim = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"clim is not yet implemented\");\n    });\n    mod.set_cmap = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"set_cmap is not yet implemented\");\n    });\n    mod.imread = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"imread is not yet implemented\");\n    });\n    mod.imsave = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"imsave is not yet implemented\");\n    });\n    mod.matshow = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"matshow is not yet implemented\");\n    });\n    mod.polar = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"polar is not yet implemented\");\n    });\n    mod.plotfile = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"plotfile is not yet implemented\");\n    });\n    mod._autogen_docstring = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"_autogen_docstring is not yet implemented\");\n    });\n    mod.acorr = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"acorr is not yet implemented\");\n    });\n    mod.arrow = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"arrow is not yet implemented\");\n    });\n    mod.axhline = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"axhline is not yet implemented\");\n    });\n    mod.axhspan = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"axhspan is not yet implemented\");\n    });\n    mod.axvline = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"axvline is not yet implemented\");\n    });\n    mod.axvspan = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"axvspan is not yet implemented\");\n    });\n    mod.bar = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"bar is not yet implemented\");\n    });\n    mod.barh = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"barh is not yet implemented\");\n    });\n    mod.broken_barh = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"broken_barh is not yet implemented\");\n    });\n    mod.boxplot = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"boxplot is not yet implemented\");\n    });\n    mod.cohere = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"cohere is not yet implemented\");\n    });\n    mod.clabel = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"clabel is not yet implemented\");\n    });\n    mod.contour = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"contour is not yet implemented\");\n    });\n    mod.contourf = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"contourf is not yet implemented\");\n    });\n    mod.csd = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"csd is not yet implemented\");\n    });\n    mod.errorbar = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"errorbar is not yet implemented\");\n    });\n    mod.eventplot = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"eventplot is not yet implemented\");\n    });\n    mod.fill = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"fill is not yet implemented\");\n    });\n    mod.fill_between = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"fill_between is not yet implemented\");\n    });\n    mod.fill_betweenx = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"fill_betweenx is not yet implemented\");\n    });\n    mod.hexbin = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"hexbin is not yet implemented\");\n    });\n    \n    var hist_f = function(kwa) {\n        // Check kwarg argument\n        Sk.builtin.pyCheckArgs(\"histk\", arguments, 1, Infinity, true, false);\n        args = Array.prototype.slice.call(arguments, 1);\n        mod.values.push(args);\n        kwargs = new Sk.builtins.dict(kwa); // is pretty useless for handling kwargs\n        kwargs = Sk.ffi.remapToJs(kwargs); // create a proper dict\n        \n        // process arguments into a list\n        var ydata = [];\n        var stylestring = []; // we support only one at the moment\n        \n        if (args[0] instanceof Sk.builtin.list) {\n            ydata.push(Sk.ffi.remapToJs(args[0]));\n        } else {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(args[0]) +\n                    \"' is not supported for *args[\" + 0 + \"].\");\n        }\n        \n        if (args[1]) {\n            if (Sk.builtin.checkString(args[1])) {\n                stylestring.push(Sk.ffi.remapToJs(args[1]));\n            } else {\n                throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(args[1]) +\n                    \"' is not supported for *args[\" + 1 + \"].\");\n            }\n        } else {\n            stylestring.push('');\n        }\n        \n        if (Sk.skip_drawing !== true) {\n\n            // empty canvas from previous plots\n            create_chart();\n            // create new plot instance, should be replaced with Line2D and then added to the plot\n            if (!plot) {\n                plot = jsplotlib.plot(chart);\n            }\n\n            // create line objects\n            var bar;\n\n            for (i = 0; i < ydata.length; i++) {\n                bars = new jsplotlib.Bars(ydata[i]);\n                var ftm_tuple = jsplotlib._process_plot_format(stylestring[i]);\n                bars.update({\n                    'linestyle': ftm_tuple.linestyle,\n                    'marker': jsplotlib.parse_marker(ftm_tuple.marker),\n                    'color': ftm_tuple.color\n                });\n                plot.add_artist(bars);\n            }\n\n            // set kwargs that apply for all lines\n            plot.update(kwargs);\n        } else {\n            if (!plot) {\n                plot = {\"_artists\":[]};\n            }\n            for (i = 0; i < ydata.length; i++) {\n                plot._artists.push([ydata[i]]);\n            }\n            \n        }\n\n        // result\n        var result = [];\n\n        return new Sk.builtins.tuple(result);\n    }\n    hist_f.co_kwargs = true;\n    mod.hist = new Sk.builtin.func(hist_f);\n    mod.hist2d = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"hist2d is not yet implemented\");\n    });\n    mod.hlines = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"hlines is not yet implemented\");\n    });\n    mod.loglog = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"loglog is not yet implemented\");\n    });\n    mod.magnitude_spectrum = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"magnitude_spectrum is not yet implemented\");\n    });\n    mod.pcolor = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"pcolor is not yet implemented\");\n    });\n    mod.pcolormesh = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"pcolormesh is not yet implemented\");\n    });\n    mod.phase_spectrum = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"phase_spectrum is not yet implemented\");\n    });\n    mod.pie = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"pie is not yet implemented\");\n    });\n    mod.plot_date = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"plot_date is not yet implemented\");\n    });\n    mod.psd = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"psd is not yet implemented\");\n    });\n    mod.quiver = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"quiver is not yet implemented\");\n    });\n    mod.quiverkey = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"quiverkey is not yet implemented\");\n    });\n    var scatter_f = function(kwa) {\n        Sk.builtin.pyCheckArgs(\"scatter\", arguments, 1, Infinity, true, false);\n        args = Array.prototype.slice.call(arguments, 1);\n        mod.values.push(args);\n        kwargs = new Sk.builtins.dict(kwa); // is pretty useless for handling kwargs\n        kwargs = Sk.ffi.remapToJs(kwargs); // create a proper dict\n\n        // try parsing plot args\n        // possible xdata, ydata, stylestring\n        /*\n            plot(x, y, 'bo')  # plot x and y using blue circle markers\n        */\n\n        // variable definitions for args\n        var xdata = [];\n        var ydata = [];\n        var stylestring = []; // we support only one at the moment\n        var i = 0;\n        var lines = 0;\n\n        if (args[0] instanceof Sk.builtin.list) {\n            xdata.push(Sk.ffi.remapToJs(args[0]));\n        } else {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(args[0]) +\n                \"' is not supported for *args[\" + 0 + \"].\");\n        }\n        if (args[1] instanceof Sk.builtin.list) {\n            ydata.push(Sk.ffi.remapToJs(args[1]));\n        } else {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(args[1]) +\n                \"' is not supported for *args[\" + 1 + \"].\");\n        }\n        if (args[2] != undefined) {\n            if (Sk.builtin.checkString(args[2])) {\n                stylestring.push(Sk.ffi.remapToJs(args[2]));\n            } else {\n                throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(args[2]) +\n                    \"' is not supported for *args[\" + 2 + \"].\");\n            }\n        } else {\n            stylestring.push('o');\n        }\n        \n        if (Sk.skip_drawing !== true) {\n\n            // empty canvas from previous plots\n            create_chart();\n            // create new plot instance, should be replaced with Line2D and then added to the plot\n            if (!plot) {\n                plot = jsplotlib.plot(chart);\n            }\n\n            // create line objects\n            var line;\n            \n            for (i = 0; i < xdata.length; i++) {\n                line = new jsplotlib.Line2D(xdata[i], ydata[i]);\n                var ftm_tuple = jsplotlib._process_plot_format(stylestring[i]);\n                line.update({\n                    'linestyle': ftm_tuple.linestyle,\n                    'marker': jsplotlib.parse_marker(ftm_tuple.marker),\n                    'color': ftm_tuple.color\n                });\n                plot.add_artist(line);\n            }\n\n            // set kwargs that apply for all lines\n            plot.update(kwargs);\n        } else {\n            if (!plot) {\n                plot = {\"_artists\":[]};\n            }\n            for (i = 0; i < xdata.length; i++) {\n                plot._artists.push([xdata[i], ydata[i]]);\n            }\n        }\n\n        // result\n        var result = [];\n\n        return new Sk.builtins.tuple(result);\n    };\n    scatter_f.co_kwargs = true;\n    mod.scatter = new Sk.builtin.func(scatter_f);\n    mod.semilogx = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"semilogx is not yet implemented\");\n    });\n    mod.semilogy = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"semilogy is not yet implemented\");\n    });\n    mod.specgram = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"specgram is not yet implemented\");\n    });\n    mod.stackplot = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"stackplot is not yet implemented\");\n    });\n    mod.stem = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"stem is not yet implemented\");\n    });\n    mod.step = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"step is not yet implemented\");\n    });\n    mod.streamplot = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"streamplot is not yet implemented\");\n    });\n    mod.tricontour = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"tricontour is not yet implemented\");\n    });\n    mod.tricontourf = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"tricontourf is not yet implemented\");\n    });\n    mod.tripcolor = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"tripcolor is not yet implemented\");\n    });\n    mod.triplot = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"triplot is not yet implemented\");\n    });\n    mod.vlines = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"vlines is not yet implemented\");\n    });\n    mod.xcorr = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"xcorr is not yet implemented\");\n    });\n    mod.barbs = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"barbs is not yet implemented\");\n    });\n    mod.cla = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"cla is not yet implemented\");\n    });\n    mod.grid = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"grid is not yet implemented\");\n    });\n    mod.legend = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"legend is not yet implemented\");\n    });\n    mod.table = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"table is not yet implemented\");\n    });\n    mod.text = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"text is not yet implemented\");\n    });\n    mod.annotate = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"annotate is not yet implemented\");\n    });\n    mod.ticklabel_format = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"ticklabel_format is not yet implemented\");\n    });\n    mod.locator_params = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"locator_params is not yet implemented\");\n    });\n    mod.tick_params = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"tick_params is not yet implemented\");\n    });\n    mod.margins = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"margins is not yet implemented\");\n    });\n    mod.autoscale = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"autoscale is not yet implemented\");\n    });\n    mod.autumn = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"autumn is not yet implemented\");\n    });\n    mod.cool = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"cool is not yet implemented\");\n    });\n    mod.copper = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"copper is not yet implemented\");\n    });\n    mod.flag = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"flag is not yet implemented\");\n    });\n    mod.gray = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"gray is not yet implemented\");\n    });\n    mod.hot = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"hot is not yet implemented\");\n    });\n    mod.hsv = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"hsv is not yet implemented\");\n    });\n    mod.jet = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\"jet is not yet implemented\");\n    });\n    mod.pink = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"pink is not yet implemented\");\n    });\n    mod.prism = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"prism is not yet implemented\");\n    });\n    mod.spring = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"spring is not yet implemented\");\n    });\n    mod.summer = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"summer is not yet implemented\");\n    });\n    mod.winter = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"winter is not yet implemented\");\n    });\n    mod.spectral = new Sk.builtin.func(function() {\n        throw new Sk.builtin.NotImplementedError(\n            \"spectral is not yet implemented\");\n    });\n\n    return mod;\n};\n", "src/lib/cs1014/__init__.py": "", "src/lib/cs1014/input_mistakes.py": "from pedal.mistakes.feedback_mod import *\nfrom pedal.cait.cait_api import *\n\n\ndef unnecessary_cast(needed_casts):\n    \"\"\"\n\n    Args:\n        needed_casts: List of casts that are necessary to this problem\n\n    Returns:\n\n    \"\"\"\n    message = \"Converting to {} is unnecessary in this problem\"\n    code = \"ex_cast\"\n    tldr = \"Unnecessary Conversion\"\n\n    known_casts = [\"float\", \"int\", \"str\"]\n    matches = find_matches(\"_cast_(___)\")\n    for match in matches:\n        user_cast = match[\"_cast_\"].id\n        if user_cast not in needed_casts and user_cast in known_casts:\n            return explain_r(message.format(user_cast), code, tldr)\n    return False\n\n", "src/lib/cs1014/dictionaries.py": "from pedal.mistakes.feedback_mod import *\nfrom pedal.cait.cait_api import *\nfrom pedal.mistakes.instructor_append import app_assign\n\n\n# dict_acc_group\ndef dict_acc_group(all_keys, unused_keys, used_keys):\n    print_dict_key(all_keys)\n    var_instead_of_key(all_keys)\n    parens_in_dict(all_keys)\n    missing_key(used_keys)\n    str_list(all_keys)\n    dict_parens_brack()\n    comma_dict_acc()\n    var_key(all_keys)\n    miss_dict_acc()\n    comp_in_dict_acc()\n    key_comp(all_keys)\n    col_dict()\n    wrong_keys(unused_keys)\n\n\n# dict_list_group\ndef dict_list_group(all_keys):\n    list_str_dict(all_keys)\n    list_var_dict_acc()\n    list_str_as_list_var(all_keys)\n    fetch_acc_dict(all_keys)\n    list_as_dict()\n    iter_as_key(all_keys)\n    iter_prop_dict_acc()\n\n    append_and_sum()\n\n    dict_out_of_loop(all_keys)\n    dict_access_not_in_loop()\n    no_dict_in_loop()\n    app_assign()\n\n\n# dict_decision\ndef dict_decision_group(all_keys, c_value, num_slices):\n    func_filter(all_keys)\n    filt_key(c_value, num_slices)\n    compare_key(c_value)\n    str_equality()\n    fetch_acc_dict([c_value])\n\n\n# dict_plot\ndef dict_plot_group():\n    show_args()\n    dict_plot()\n\n\n# dict_chain\ndef dict_chain_group(key_sets):\n    for key_set in key_sets:\n        key_order(key_set)\n        key_order_unchained(key_set)\n\n\n# dict_hard_codes\ndef dict_hard_codes_group(print_vals, list_vals):\n    hard_coding(print_vals)\n    hard_coded_list(list_vals)\n\n\n# dict_hard_codes\ndef hard_coding(val_list):\n    message = (\"Please show code that makes the computer extract \"\n               \"the value from the dictionary.\")\n    code = \"hard_code\"\n    tldr = \"Printing raw value\"\n    # Pattern 1 possibility\n    matches = find_matches(\"print(__exp__)\")\n    for match in matches:\n        __exp__ = match[\"__exp__\"]\n        value = __exp__.value\n        if value in val_list:\n            return explain_r(message, code, tldr)\n\n    # Pattern 2 possibility\n    matches = find_matches(\"__exp__\\n\"\n                           \"print(_var_)\")\n    for match in matches:\n        __exp__ = match[\"__exp__\"]\n        _var_ = match[\"_var_\"]\n        submatches = __exp__.find_matches(\"{} = __exp2__\".format(_var_.id))\n        for submatch in submatches:\n            __exp2__ = submatch[\"__exp2__\"]\n            value = __exp2__.value\n            if value in val_list:\n                return explain_r(message, code, tldr)\n    return False\n\n\n# dict_acc_group\ndef print_dict_key(keys):\n    message = ('You\\'ve printed the dictionary key <code>\"{}\"</code> instead of using an extracted value and '\n               'printing it. Use the Dictionary access syntax to print the value associated with a key')\n    code = \"dict_k_print\"\n    tldr = \"Printing key, not value\"\n    matches = find_matches(\"print(__str__)\")\n    matches += find_matches(\"print([__str__])\")\n\n    for match in matches:\n        __str__ = match[\"__str__\"]\n        if __str__.is_ast(\"Str\") and __str__.value in keys:\n            return explain_r(message.format(__str__.value), code, tldr)\n    return False\n\n\n# dict_acc_group\ndef var_instead_of_key(keys):\n    message = (\"It looks like you are trying to use (<code>{}</code>) as a dictionary key. \"\n               \"Use the dictionary access syntax to get values from a dictionary\")\n    code = \"var_as_k\"\n    tldr = \"Using Variable instead of key\"\n    matches = find_matches(\"_var_\")\n    matches += find_matches(\"[_var_]\")\n    for match in matches:\n        _var_ = match[\"_var_\"]\n        if _var_.id in keys:\n            submatch = find_match(\"_dict_['{}']\".format(_var_.id))\n            if submatch is None:\n                return explain_r(message.format(_var_.id), code, tldr)\n    return False\n\n\n# dict_acc_group\ndef parens_in_dict(keys):\n    message = ('It seems like you are having trouble with dictionary syntax. The dictionary key <code>\"{}\"'\n               \"</code>should use brackets.\")\n    code = \"par_dict\"\n    tldr = \"Not Using Dictionary Brackets\"\n    matches = find_matches(\"_var_(__str__)\")\n    for match in matches:\n        __str__ = match['__str__']\n        if __str__.is_ast(\"Str\") and __str__.value in keys:\n            return explain_r(message.format(__str__.value), code, tldr)\n    return False\n\n\n# dict_list_group\ndef list_as_dict():\n    message = (\"A list of Dictionaries like <code>{}</code> is not itself a dictionary. \"\n               \"To access key-value pairs of the dictionaries in the list, \"\n               \"you need to access each dictionary in the list one at a time.\")\n    code = \"list_dict\"\n    tldr = \"List is not a dictionary\"\n    matches = find_matches(\"_list_[__exp__]\")\n    for match in matches:\n        _list_ = match['_list_']\n        if _list_.was_type(\"ListType\") and str(_list_.get_data_state().type.subtype) == \"DictType\":\n            return explain_r(message.format(_list_.id), code, tldr)\n    return False\n\n\n# dict_list_group\ndef dict_out_of_loop(keys):\n    message = (\"Remember that a list of dictionaries, like <code>{}</code>, \"\n               \"is still a list of individual items. Each dictionary needs to be accessed with \"\n               \"the appropriate key-value pair one at a time.\")\n    code = \"dict_out_loop\"\n    tldr = \"Dictionary Access Outside of Loop\"\n    matches = find_matches(\"__exp__\\n\"\n                           \"for ___ in _var_:\\n\"\n                           \"    pass\")\n    matches += find_matches(\"for ___ in _var_:\\n\"\n                            \"    pass\\n\"\n                            \"__exp__\\n\")\n    for match in matches:\n        __exp__ = match['__exp__']\n        _var_ = match['_var_']\n        submatches = __exp__.find_matches(\"{var}[__str__]\".format(var=_var_.id))\n        for submatch in submatches:\n            __str__ = submatch['__str__']\n            if __str__.is_ast(\"Str\") and __str__.value in keys:\n                return explain_r(message.format(_var_.id), code, tldr)\n    return False\n\n\n# dict_acc_group\ndef wrong_keys(unused_keys):\n    message = 'This problem does not require the key <code>\"{}\"</code>.\\n'\n    code = \"unused_key\"\n    tldr = \"Unnecessary Key Usage\"\n\n    matches = find_matches(\"_var_[__str__]\")\n    for match in matches:\n        __str__ = match[\"__str__\"]\n        if __str__.is_ast(\"Str\") and __str__.value in unused_keys:\n            return explain_r(message.format(__str__.value), code, tldr)\n    return False\n\n\n# dict_list_group\ndef dict_access_not_in_loop():\n    message = (\"You haven't used the dictionary access syntax in a for loop. \"\n               \"Remember that a list of dictionaries is still a list of individual items. \"\n               \"Each dictionary needs to be accessed with the appropriate key-value pair one at a time.\")\n    code = \"dict_acc_loop\"\n    tldr = \"Dictionary access not in loop\"\n\n    matches = find_matches(\"for ___ in ___:\\n\"\n                           \"    __exp__\")\n    for match in matches:\n        submatches = match[\"__exp__\"].find_matches(\"_var_[__str__]\")\n        if submatches:\n            return False\n    return explain_r(message, code, tldr)\n\n\ndef hard_coded_list(val_list):\n    message = (\"In later abstractions, it's not possible to view the values of a specific key in a list.\"\n               \"You should use a dictionary key-value pair to access values in the list of dictionaries.\")\n    code = \"hard_list\"\n    tldr = \"Don't use raw list\"\n    matches = find_matches(\"[__exp__]\")\n    for match in matches:\n        __exp__ = match['__exp__'].parent\n        if __exp__.ast_name == \"List\":\n            try:\n                vals = sum([x.value for x in __exp__.elts])\n                if sum(val_list) == vals:\n                    return explain_r(message, code, tldr)\n            except TypeError:\n                pass  # This should be the only error\n    return False\n\n\n# dict_list_group\ndef iter_as_key(keys):\n    message = (\"It looks like you are using the iteration variable <code>{}\"\n               \"</code> to access a value of a specific key in a dictionary. \"\n               \"To access a key-value from a list of dictionaries, use <code>\")\n    code = \"iter_key\"\n    tldr = \"Iteration variable is not key\"\n    matches = find_matches(\"for _var_ in ___:\\n\"\n                           \"    pass\")\n    for match in matches:\n        _var_ = match['_var_']\n        submatches = find_matches(\"_var2_[__str__]\")\n        missing = True\n        for submatch in submatches:\n            __str__ = submatch[\"__str__\"]\n            if __str__.is_ast(\"Str\") and __str__.value == _var_.id:\n                missing = False\n                break\n        if missing and _var_.id in keys:\n            return explain_r(message.format(_var_.id), code, tldr)\n    return False\n\n\n# dict_list_group\ndef list_str_as_list_var(keys):\n    message = (\"The list variable in an iteration can only take lists. \"\n               \"To grab individual values in a list of dictionaries, \"\n               \"you need to use the appropriate key for each dictionary.\")\n    code = \"list_var_dict\"\n    tldr = \"List variable cannot filter\"\n    matches = find_matches(\"for ___ in [__str__]:\\n\"\n                           \"    pass\")\n    for match in matches:\n        __str__ = match[\"__str__\"]\n        if __str__.is_ast(\"Str\") and __str__.value in keys:\n            return explain_r(message, code, tldr)\n    return False\n\n\n# dict_list_group\ndef append_and_sum():\n    message = (\"It looks like you're trying to build a list and \"\n               \"then calculate a value. While this will get you a \"\n               \"correct answer, you can calculate the value directly instead of first building a list.\")\n    code = \"app_sum\"\n    tldr = \"Unnecessary append and sum\"\n    matches = find_match(\"for ___ in ___:\\n\"\n                         \"    _var_.append()\\n\"\n                         \"for ___ in _var_:\\n\"\n                         \"    ___ = ___ + ___\")\n    if matches:\n        return explain_r(message, code, tldr)\n    return False\n\n\n# dict_list_group\ndef iter_prop_dict_acc():\n    message = (\"Improper usage of iteration variable.\"\n               \"The for statement gives the iteration variable a value, \"\n               \"in this case, a dictionary. That dictionary can only be accessed in the body of the iteration.\")\n    code = \"iter_dict_acc\"\n    tldr = \"Iteration variable only initializes\"\n    match = find_match(\"for _var_[__str__] in ___:\\n\"\n                       \"    pass\")\n    if match:\n        return explain_r(message, code, tldr)\n    return False\n\n\n# dict_list_group\ndef list_str_dict(keys):\n    message = (\"When using dictionaries with iteration, the list cannot just be a key \"\n               'value like <code>\"{}\"</code>, it must be the list of dictionaries.')\n    code = \"list_str\"\n    tldr = \"List variable is string\"\n    matches = find_matches(\"for ___ in __str__:\\n\"\n                           \"    pass\")\n    for match in matches:\n        __str__ = match['__str__']\n        if __str__.is_ast(\"Str\") and __str__.value in keys:\n            return explain_r(message.format(__str__.value), code, tldr)\n    return False\n\n\n# dict_acc_group\ndef missing_key(keys):\n    message = \"You seem to be missing the following dictionary keys:<ul>{}</ul>\"\n    code = \"miss_key\"\n    tldr = \"Missing necessary keys\"\n    key_list = \"\"\n    for key in keys:\n        matches = find_matches(\"\\\"{}\\\"\".format(key))\n        if not matches:\n            key_list += '<li><code>\"' + key + '\"</code></li>'\n    if key_list != \"\":\n        return explain_r(message.format(key_list), code, tldr)\n    return False\n\n\ndef blank_key(keys):\n    message = \"You seem to be missing the following dictionary keys:<ul>{}</ul>\"\n    code = \"blank_key\"\n    tldr = \"Missing Key\"\n    key_list = \"\"\n\n    for key in keys:\n        if not find_match(\"_var_['{}']\".format(key)):\n            key_list += '<li><code>\"' + key + '\"</code></li>'\n\n    if key_list != \"\":\n        return explain_r(message.format(key_list), code, tldr)\n\n\n# dict_acc_group\ndef dict_parens_brack():\n    message = (\"It looks like you are trying to dictionary access <code>{}</code>. \"\n               \"The dictionary access syntax does not require parenthesis.\")\n    code = \"dict_parbrack\"\n    tldr = \"Improper dictionary access\"\n    matches = find_matches(\"_var_([__str1__][__str2__])\")\n    matches += find_matches(\"_var_([__str1__])\")\n    for match in matches:\n        _var_ = match['_var_']\n        __str1__ = match[\"__str1__\"]\n        __str2__ = __str1__\n        try:\n            __str2__ = match[\"__str2__\"]\n        except KeyError:\n            pass\n        if __str1__.is_ast(\"Str\") and __str2__.is_ast(\"Str\") and data_state(_var_.id):\n            return explain_r(message.format(_var_.id), code, tldr)\n    return False\n\n\n# dict_acc_group\ndef comma_dict_acc():\n    message = (\"It looks like you are trying to dictionary access <code>{}</code>. \"\n               \"Unlike with initializing dictionaries, keys don't need to be separated with commas \"\n               \"when accessing dictionary contents.\")\n    code = \"comma_dict\"\n    tldr = \"Improper dictionary access\"\n    matches = find_matches(\"__exp__,[__str2__]\")\n    for match in matches:\n        submatch = match['__exp__'].find_match(\"_dict_[__str1__]\")\n        if submatch:\n            return explain_r(message.format(submatch['_dict_'].id), code, tldr)\n    return False\n\n\n# dict_list_group\ndef no_dict_in_loop():\n    message = \"When working with a list of dictionaries, you need to use a dictionary access in your iteration.\"\n    code = \"no_dict_loop\"\n    tldr = \"Missing dictionary access loop\"\n\n    matches = find_matches(\"for _item_ in _list_:\\n\"\n                           \"    __expr__\")\n    for match in matches:\n        submatches = match['__expr__'].find_matches(\"_item_[__str__]\")\n        for submatch in submatches:\n            if submatch[\"__str__\"].is_ast(\"Str\"):\n                return False\n    return explain_r(message, code, tldr)\n\n\n# dict_decision\ndef func_filter(keys):\n    message = \"Please do not modify the function call to retrieve the data.\"\n    code = \"func_filt\"\n    tldr = \"Attempting to filter using fetch\"\n    matches = find_matches(\"_var_._func_(__str__)\")\n    for match in matches:\n        __str__ = match[\"__str__\"]\n        if __str__.value in keys:  # TODO: Relies on .value returning id for Name nodes\n            return explain_r(message, code, tldr)\n    return False\n\n\n# dict_acc_group\ndef str_list(keys):\n    message = ('If you are trying to use a string such as <code>\"{}\"</code> as a dictionary key, '\n               'it needs to be prefaced with a dictionary')\n    code = \"str_list\"\n    tldr = \"String list used instead of Dictionary\"\n\n    for key in keys:\n        if find_match(\"['{}']\".format(key)):\n            return explain_r(message.format(key), code, tldr)\n    return False\n\n\n# dict_list_group\ndef list_var_dict_acc():\n    message = (\"The for statement only specifies a list target, in this case, a list of dictionaries. \"\n               \"It does not operate on the entire list. Keys should be used on the individual dictionaries of the list.\")\n    code = \"l_var_dacc\"\n    tldr = \"List variable cannot be dictionary accessed\"\n\n    matches = find_matches(\"for ___ in _var_[__str__]:\\n\"\n                           \"    pass\")\n    if matches:\n        return explain_r(message, code, tldr)\n    return False\n\n\n# dict_acc_group\ndef key_comp(keys):\n    message = ('The strings <code>\"{}\"</code> and <code>\"{}\"</code> are keys. '\n               'Dictionary keys do not need to be compared to anything as they '\n               'are not filtering data. Dictionary keys are only used to access existing data.')\n    code = \"key_comp\"\n    tldr = \"Comparing Keys\"\n\n    matches = find_matches(\"for _var_ in ___:\\n\"\n                           \"    if _var_[__str1__] == __str2__:\\n\"\n                           \"        pass\")\n    for match in matches:\n        __str1__ = match[\"__str1__\"]\n        __str2__ = match[\"__str2__\"]\n        if __str1__.is_ast(\"Str\") and __str1__.value in keys and __str2__.is_ast(\"Str\") and __str2__.value in keys:\n            return explain_r(message.format(__str1__.value, __str2__.value), code, tldr)\n    return False\n\n\n# dict_acc_group\ndef col_dict():\n    message = \"When using multiple keys, each key should have it's own set of brackets.\"\n    code = \"col_dict\"\n    tldr = \"Improper Dictionary Access\"\n\n    matches = find_matches(\"_var_[__str1__: __str2__]\")\n    if matches:\n        return explain_r(message, code, tldr)\n    return False\n\n\n# dict_acc_group\ndef var_key(keys):\n    message = (\"It looks like you are trying to use <code>{}</code> as a key. Dictionary keys are string values. \"\n               \"Variable names don't have a meaning to a computer.\")\n    code = \"var_key\"\n    tldr = \"Variables are not keys\"\n\n    matches = find_matches(\"_var_[_key_]\")\n    for match in matches:\n        _key_ = match['_key_']\n        if _key_.id in keys:\n            return explain_r(message.format(_key_.id), code, tldr)\n    return False\n\n\n# dict_plot\ndef key_order(keys):\n    message = \"It looks like you aren't using the correct keys, or the correct key order. Double check your data map.\"\n    code = \"key_order_c\"\n    tldr = \"Wrong key order\"\n\n    construct = None\n    find_chain = \"_var_\"\n    for a_slice in range(len(keys)):\n        find_chain += \"[__str{}__]\".format(a_slice)\n    if find_match(find_chain):\n        construct = \"_var_\"\n        for key in keys:\n            construct += \"['{}']\".format(key)\n\n    if construct:\n        matches = find_matches(construct)\n        if not matches:\n            return explain_r(message, code, tldr)\n    return False\n\n\n# dict_plot\ndef key_order_unchained(keys):\n    message = \"It looks like you aren't using the correct keys, or the correct key order. Double check your data map.\"\n    code = \"key_order_u\"\n    tldr = \"Wrong key order\"\n\n    construct = None\n    find_chain = \"\"\n    for a_slice in range(len(keys)):\n        find_chain += \"_var{a2}_ = _var{a1}_[__str{a1}__]\\n\".format(a2=a_slice+1, a1=a_slice)\n    if find_match(find_chain):\n        construct = \"\"\n        count = 0\n        for key in keys:\n            construct += \"_var{a2}_ = _var{a1}_['{key}']\\n\".format(a2=count+1, a1=count, key=key)\n            count += 1\n\n    if construct:\n        matches = find_matches(construct)\n        if not matches:\n            return explain_r(message, code, tldr)\n    return False\n\n\n# dict_decision\ndef filt_key(c_value, num_slices):\n    message = ('It looks like you\\'re using <code>\"{c_value}\"</code> as a dictionary key to filter data. '\n               \"Dictionary keys don't filter data, they only access data that's already there. \"\n               \"You should be comparing data retrieved from the dictionary to <code>'{c_value}'</code>\")\n    code = \"filt_key\"\n    tldr = \"Attempting filter as Key\"\n\n    construct = \"_var_\"\n    for a_slice in range(num_slices):\n        construct += \"[__str{}__]\".format(a_slice)\n        matches = find_matches(construct)\n        for match in matches:\n            for num in range(a_slice + 1):\n                value = match[\"__str{}__\".format(num)]\n                if value.is_ast(\"Str\") and value.value == c_value:\n                    return explain_r(message.format(c_value=value), code, tldr)\n    return False\n\n\n# dict_acc_group\ndef miss_dict_acc():\n    message = (\"You are missing something that looks like a dictionary access. \"\n               \"In this unit, you should be using dictionary access\")\n    code = \"miss_acc\"\n    tldr = \"Missing Dictionary Access\"\n\n    if not find_matches(\"_var_[__str1__]\"):\n        return explain_r(message, code, tldr)\n    return False\n\n\n# dict_decision\ndef compare_key(c_value):\n    message = ('In this problem, <code>\"{}\"</code> is not a key, '\n               'but something you should compare against.'.format(c_value))\n    code = \"comp_key\"\n    tldr = \"Using filter value as key\"\n\n    matches = find_matches(\"__exp0__ == __exp1__\")\n    for match in matches:\n        for num in range(2):\n            __exp__ = match[\"__exp{}__\".format(num)]\n            submatches = __exp__.find_matches(\"[__str__]\")\n            for submatch in submatches:\n                __str__ = submatch[\"__str__\"]\n                if __str__.is_ast(\"Str\") and __str__.value == c_value:\n                    return explain_r(message, code, tldr)\n    return False\n\n\n# dict_decision\ndef str_equality():\n    message = ('You are comparing two different string values, \"{}\" and \"{}\". While dictionary keys are strings, '\n               \"they are only interpreted by the computer as keys when used with the dictionary access syntax\")\n    code = \"str_eq\"\n    tldr = \"Comparing equality of raw strings\"\n\n    matches = find_matches(\"__str1__ == __str2__\")\n    for match in matches:\n        __str1__ = match[\"__str1__\"]\n        __str2__ = match[\"__str2__\"]\n        if __str1__.is_ast(\"Str\") and __str2__.is_ast(\"Str\"):\n            return explain_r(message.format(__str1__.value, __str2__.value), code, tldr)\n    return False\n\n\n# dict_list_group and dict_decision_group\ndef fetch_acc_dict(values):\n    message = (\"The code to fetch the list of dictionaries, <code>{}.{}</code>, cannot be used to select data. \"\n               \"Selection of data should be done with an if statement\")\n    code = \"fetch_acc\"\n    tldr = \"Malformed Dictionary List Fetch\"\n\n    matches = find_matches(\"_var_._func_[__str__]\")\n    for match in matches:\n        _var_ = match[\"_var_\"].id\n        _func_ = match[\"_func_\"].id\n        __str__ = match[\"__str__\"]\n        if __str__.is_ast(\"Str\") and __str__.value in values:\n            return explain_r(message.format(_var_, _func_), code, tldr)\n    return False\n\n\n# dict_plot\ndef show_args():\n    # TODO: Add this to plotting mistakes?\n    message = (\"The <code>plt.show</code> function only tells the computer to display the plot. \"\n               \"If you want to modify the plot, use other available plotting functions.\")\n    code = \"show_args\"\n    tldr = \"Show takes no arguments\"\n\n    matches = find_matches(\"plt.show(__exp__)\")\n    if matches:\n        return explain_r(message, code, tldr)\n    return False\n\n\n# dict_plot\ndef dict_plot():\n    message = (\"The list <code>{}</code> is a list of dictionaries. <code>plt.plot</code> only accepts a list\"\n               \" of numbers. You need to extract the numbers from the list of dictionaries first.\")\n    code = \"dict_plot\"\n    tldr = \"Plotting list of Dictionaries\"\n\n    matches = find_matches(\"plt._func_(_var_)\")\n    for match in matches:\n        _var_ = match[\"_var_\"]\n        var_type = str(_var_.get_data_state().type)\n        if var_type == \"ListType\" and str(_var_.get_data_state().type.subtype) == \"DictType\":\n            return explain_r(message.format(_var_.id), code, tldr)\n    return False\n\n\n# dict_acc_group\ndef comp_in_dict_acc():\n    message = (\"You are using a boolean expression in a dictionary access. Remember that the dictionary \"\n               \"access takes a key and provides a value. The comparison should be made with the value, not the key.\")\n    code = \"comp_acc\"\n    tldr = \"Comparison in key access\"\n\n    matches = find_matches(\"_var_[__exp__][__exp2__ == __exp3__]\")\n    if matches:\n        return explain_r(message, code, tldr)\n    return False\n", "src/lib/cs1014/tests/test_dictionary.py": "import sys\nimport os\n\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))\n\nfrom tests.mistake_test_template import *\nfrom cs1014.dictionaries import *\nfrom cs1014.input_mistakes import *\nfrom pedal.mistakes.iteration_context import all_labels_present\n\n\nclass DictionaryMistakeTest(MistakeTest):\n    def setUp(self):\n        self._dict_str = (\"[{'City': 'Birmingham',  'Precipitation':  0.0, 'Temperature': 46},\"\n                          \"{'City': 'Fairbanks' ,  'Precipitation': 1.37, 'Temperature': 57},\"\n                          \"{'City': 'Miami',       'Precipitation': 1.86, 'Temperature': 80},\"\n                          \"{'City': 'Los Angeles', 'Precipitation':  0.5, 'Temperature': 73},\"\n                          \"{'City': 'Denver',      'Precipitation':  0.0, 'Temperature': 49},\"\n                          \"{'City': 'Chicago',     'Precipitation': 0.23, 'Temperature': 40}]\")\n\n    def test_hard_coding(self):\n        constants = [99.23, \"99.23\"]\n        self.to_source('book = {\"number_of_pages\":285, \"price\":99.23, \"discount\":0.1}\\n'\n                       'print (\"99.23\")')\n        ret = hard_coding(constants)\n        self.assertTrue(ret, \"Expected feedback message, got {} instead\".format(ret))\n\n        self.to_source('book = {\"number_of_pages\":285, \"price\":99.23, \"discount\":0.1}\\n'\n                       'price = \"99.23\"\\n'\n                       'print (price)')\n        ret = hard_coding(constants)\n        self.assertTrue(ret, \"Expected feedback message, got {} instead\".format(ret))\n\n        self.to_source('book = {\"number_of_pages\":285, \"price\":99.23, \"discount\":0.1}\\n'\n                       'print (book[\"price\"])')\n        ret = hard_coding(constants)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_print_dict_key(self):\n        # TODO: Check output string\n        key_list = ['price', 'number_of_pages', 'discount']\n        self.to_source('book = {\"number_of_pages\":285, \"price\":99.23, \"discount\":0.1}\\n'\n                       'how_much= book[\"price\"]\\n'\n                       'print(\"price\")')\n        ret = print_dict_key(key_list)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('book = {\"number_of_pages\":285, \"price\":99.23, \"discount\":0.1}\\n'\n                       'how_much= book[\"price\"]\\n'\n                       'print([\"price\"])')\n        ret = print_dict_key(key_list)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('book = {\"number_of_pages\":285, \"price\":99.23, \"discount\":0.1}\\n'\n                       'print (book[\"price\"])')\n        ret = print_dict_key(key_list)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_var_instead_of_key(self):\n        # TODO: Check output string\n        key_list = ['price', 'number_of_pages', 'discount']\n\n        self.to_source('book = {\"number_of_pages\":285, \"price\":99.23, \"discount\":0.1}\\n'\n                       'print (price)')\n        ret = var_instead_of_key(key_list)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('book = {\"number_of_pages\":285, \"price\":99.23, \"discount\":0.1}\\n'\n                       'print (book[\"price\"])')\n        ret = var_instead_of_key(key_list)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_parens_in_dict(self):\n        # TODO: Check output string\n        key_list = ['price', 'number_of_pages', 'discount']\n\n        self.to_source('book = {\"number_of_pages\":285, \"price\":99.23, \"discount\":0.1}\\n'\n                       'print (book(\"price\"))')\n        ret = parens_in_dict(key_list)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('book = {\"number_of_pages\":285, \"price\":99.23, \"discount\":0.1}\\n'\n                       'print (book[\"price\"])')\n        ret = parens_in_dict(key_list)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_list_as_dict(self):\n        # TODO: Check output string\n        self.to_source(\"total = 0\\n\"\n                       \"weather_reports = {}\\n\"\n                       \"for precipitation in weather_reports:\\n\"\n                       \"    total = total + weather_reports['Precipitation']\\n\"\n                       \"print (total)\".format(self._dict_str))\n        ret = list_as_dict()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source(\"total = 0\\n\"\n                       \"weather_reports = {}\\n\"\n                       \"for precipitation in weather_reports:\\n\"\n                       \"    total = total + precipitation['Precipitation']\\n\"\n                       \"print (total)\\n\".format(self._dict_str))\n        ret = list_as_dict()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_dict_out_of_loop(self):\n        # TODO: Check output string\n        keys = ['Precipitation']\n        self.to_source('rain = weather_reports[\"Precipitation\"]\\n'\n                       'total = 0\\n'\n                       'for report in weather_reports:\\n'\n                       '    total = total + rain\\n'\n                       'print(total)\\n')\n        ret = dict_out_of_loop(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('weather_reports = {}\\n'\n                       'total = 0\\n'\n                       'for report in weather_reports:\\n'\n                       '    total = total + report[\"Precipitation\"]\\n'\n                       'print(total)\\n'.format(self._dict_str))\n        ret = dict_out_of_loop(keys)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n        self.to_source('import matplotlib.pyplot as plt\\n'\n                       'import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'BB_min = []\\n'\n                       'BB_max = []\\n'\n                       'for weather in weather_reports: \\n'\n                       '    if (\"Blacksburg\" in weather[\"Station\"][\"City\"]): \\n'\n                       '        BB_min.append(weather[\"Data\"][\"Temperature\"][\"Min Temp\"])\\n'\n                       '        \\n'\n                       'for weather in weather_reports: \\n'\n                       '    if (\"Blacksburg\" in weather[\"Station\"][\"City\"]):\\n'\n                       '        BB_max.append(weather[\"Data\"][\"Temperature\"][\"Max Temp\"])\\n'\n                       'plt.scatter(BB_min,BB_max)\\n'\n                       'plt.xlabel(\"Trend\")\\n'\n                       'plt.ylabel(\"Temperatures\")\\n'\n                       'plt.title(\"Relationship between Minimum and Maximum Temperatures in Blacksburg\")\\n'\n                       'plt.show()\\n')\n        all_labels_1 = all_labels_present()\n        ret = dict_out_of_loop(keys)\n        self.assertFalse(all_labels_1, \"false negative\")\n        all_labels_2 = all_labels_present()\n        self.assertFalse(ret, \"...\")\n        self.assertTrue(all_labels_1 == all_labels_2, \"Side effects aren't undoing themselves\")\n\n    def test_wrong_keys(self):\n        # TODO: Check output string\n        keys = ['Date', \"Temperature\", \"Wind\", \"Min Temp\", \"Max Temp\", \"Avg Temp\", \"Direction\", \"Speed\", \"Month\", \"Year\",\n                \"Week of\", \"Full\", \"State\", \"Code\", \"City\", \"Location\"]\n        self.to_source(\"total = 0\\n\"\n                       \"for reports in weather_reports:\\n\"\n                       \"    total = total + reports['Temperature']\\n\"\n                       \"print(total)\\n\")\n        ret = wrong_keys(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source(\"total = 0\\n\"\n                       \"for reports in weather_reports:\\n\"\n                       \"    total = total + reports['Precipitation']\\n\"\n                       \"print(total)\\n\")\n        ret = wrong_keys(keys)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_dict_access_not_in_loop(self):\n        self.to_source('weatherPrecipitation = weather_reports[\"Precipitation\"]\\n'\n                       'for report in weather_reports:\\n'\n                       '    total_precipitation = weatherPrecipitation + total_precipitation\\n'\n                       'print(total_precipitation)\\n')\n        ret = dict_access_not_in_loop()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('for weather_report in weather_reports:\\n'\n                       '    total = total + precipitations[Precipitation]\\n'\n                       'print(total)\\n')\n        ret = dict_access_not_in_loop()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n        self.to_source('for weather_report in weather_reports:\\n'\n                       '    total = total + precipitations[\"Precipitation\"]\\n'\n                       'print(total)\\n')\n        ret = dict_access_not_in_loop()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n        self.to_source('for weather in weather_reports:\\n'\n                       '    if (\"San Diego\" in weather[\"Station\"][\"City\"]):\\n'\n                       '        sandiego_list.append(weather[\"Data\"][\"Temperature\"][\"Avg Temp\"])\\n'\n                       'for weather in weather_reports:\\n'\n                       '    if (\"Blacksburg\" in weather[\"Station\"][\"City\"]):\\n'\n                       '        blacksburg_list.append(weather[\"Data\"][\"Temperature\"][\"Avg Temp\"])\\n'\n                       'for temp in sandiego_list:\\n'\n                       '    sandiego_temp = sandiego_temp + 1\\n'\n                       '    sandiego_number = sandiego_number + temp\\n'\n                       'sandiego_average = sandiego_number / sandiego_temp\\n'\n                       'for temp in blacksburg_list:\\n'\n                       '    blacksburg_temp = blacksburg_temp + 1\\n'\n                       '    blacksburg_number = blacksburg_number + temp\\n'\n                       'blacksburg_average = blacksburg_number / blacksburg_temp\\n'\n                       'plt.scatter(BB_min,BB_max)\\n'\n                       'plt.xlabel(\"Trend\")\\n'\n                       'plt.ylabel(\"Temperatures\")\\n'\n                       'plt.title(\"Relationship between Minimum and Maximum Temperatures in Blacksburg\")\\n'\n                       'plt.show()\\n')\n        ret = dict_access_not_in_loop()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n        ret2 = all_labels_present()\n        self.assertFalse(ret2, \"Expected False, got message instead\")\n\n    def test_hard_coded_list(self):\n        val_list = [0.0, 1.37, 1.86, 0.5, 0.0, 0.23]\n        self.to_source('total_rain = 0\\n'\n                       'weather_reports = [0.0,1.37,1.86,0.5,0.0,0.23]\\n'\n                       'for rain in weather_reports:\\n'\n                       '    total_rain = rain + total_rain\\n'\n                       'print(total_rain)\\n')\n        ret = hard_coded_list(val_list)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('total_rain = 0\\n'\n                       'weather_reports = {}\\n'\n                       'for rain in weather_reports:\\n'\n                       '    total_rain = rain + total_rain\\n'\n                       'print(total_rain)\\n'.format(self._dict_str))\n        ret = hard_coded_list(val_list)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_iter_as_key(self):\n        # TODO: Check output string\n        keys = ['Data', 'Date', \"Station\", \"Temperature\", \"Precipitation\", \"Wind\", \"Min Temp\", \"Max Temp\", \"Avg Temp\",\n                \"Direction\", \"Speed\", \"Month\", \"Year\", \"Week of\", \"Full\", \"State\", \"Code\", \"City\", \"Location\"]\n        self.to_source('total_precipitation = 0\\n'\n                       'for Precipitation in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + \"Precipitation\"\\n'\n                       'print(total_precipitation)\\n')\n        ret = iter_as_key(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for Precipitation in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + Precipitation[\"Precipitation\"]\\n'\n                       'print(total_precipitation)\\n')\n        ret = iter_as_key(keys)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for precip in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + precip\\n'\n                       'print(total_precipitation)\\n')\n        ret = iter_as_key(keys)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_dict_acc_as_lis_var(self):\n        keys = ['Data', 'Date', \"Station\", \"Temperature\", \"Precipitation\", \"Wind\", \"Min Temp\", \"Max Temp\", \"Avg Temp\",\n                \"Direction\", \"Speed\", \"Month\", \"Year\", \"Week of\", \"Full\", \"State\", \"Code\", \"City\", \"Location\"]\n        self.to_source('precipitation_total=0\\n'\n                       'precipitation_list=[]\\n'\n                       'for precipitation in [\"Precipitation\"]:\\n'\n                       '    precipitation_list.append(\"Precipitation\")\\n'\n                       'for precipitation in precipitation_list:\\n'\n                       '    precipitation_total=precipitation_total + precipitation\\n'\n                       'print(precipitation_total)\\n')\n        ret = list_str_as_list_var(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for precip in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + precip\\n'\n                       'print(total_precipitation)\\n')\n        ret = list_str_as_list_var(keys)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_append_and_sum(self):\n        self.to_source('precipitation_total=0\\n'\n                       'precipitation_list=[]\\n'\n                       'for precipitation in weather_reports[\"Precipitation\"]:\\n'\n                       '    precipitation_list.append(\"Precipitation\")\\n'\n                       'for precipitation in precipitation_list:\\n'\n                       '    precipitation_total= precipitation_total + 1\\n'\n                       'print(precipitation_total)\\n')\n        ret = append_and_sum()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for precip in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + precip\\n'\n                       'print(total_precipitation)\\n')\n        ret = append_and_sum()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_iter_prop_dict_acc(self):\n        self.to_source('for weather_reports[\"Precipitation\"] in weather_reports:\\n'\n                       '    total = weather_reports[Precipitation] + total\\n'\n                       'print(total)\\n')\n        ret = iter_prop_dict_acc()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for precip in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + precip\\n'\n                       'print(total_precipitation)\\n')\n        ret = iter_prop_dict_acc()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_list_str_dict(self):\n        # TODO: Check output string\n        keys = ['Data', 'Date', \"Station\", \"Temperature\", \"Precipitation\", \"Wind\", \"Min Temp\", \"Max Temp\", \"Avg Temp\",\n                \"Direction\", \"Speed\", \"Month\", \"Year\", \"Week of\", \"Full\", \"State\", \"Code\", \"City\", \"Location\"]\n        self.to_source('total=0\\n'\n                       'number=0\\n'\n                       'for precipitation1 in \"Precipitation\":\\n'\n                       '    total= total+ precipitation1[\"Precipitation\"]\\n'\n                       '    number= number + 1\\n'\n                       'average= total/ total\\n'\n                       'print(average)\\n')\n        ret = list_str_dict(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for precip in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + precip\\n'\n                       'print(total_precipitation)\\n')\n        ret = list_str_dict(keys)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_missing_key(self):\n        # TODO: Check output string\n        keys = [\"Precipitation\", \"Data\"]\n        self.to_source('total=0\\n'\n                       'number=0\\n'\n                       'for precipitation1 in \"Precipitation\":\\n'\n                       '    total= total+ precipitation1[\"Precipitation\"]\\n'\n                       '    number= number + 1\\n'\n                       'average= total/ total\\n'\n                       'print(average)\\n')\n        ret = missing_key(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for precip in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + precip[\"Data\"][\"Precipitation\"]\\n'\n                       'print(total_precipitation)\\n')\n        ret = missing_key(keys)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_blank_key(self):\n        keys = [\"distance\", \"time\"]\n        self.to_source('distance_in_kilometers = trip_data[\"____\"]/1000\\n'\n                       'trip_data = {\"distance\":123000.0, \"time\":14000.0}\\n'\n                       'print(average_speed_in_mph) \\n'\n                       'average_speed_in_mph = ____ / time_in_hours\\n'\n                       'time_in_hours = trip_data[\"____\"]/____\\n'\n                       '____ = distance_in_kilometers / 1.6\\n')\n        ret = blank_key(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('trip_data = {\"distance\":123000.0, \"time\":14000.0}\\n'\n                       'distance_in_kilometers = trip_data[\"distance\"]/1000\\n'\n                       'distance_in_miles = distance_in_kilometers / 1.6\\n'\n                       'time_in_hours = trip_data[\"time\"]/3600\\n'\n                       'average_speed_in_mph = distance_in_miles / time_in_hours\\n'\n                       'print(average_speed_in_mph) \\n')\n        ret = blank_key(keys)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_dict_parens_brack(self):\n        # TODO: Check output string\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for rain in weather_reports:\\n'\n                       '    sum = sum + weather_reports([\"Data\"][\"Precipitation\"])\\n'\n                       'print(sum)\\n')\n        ret = dict_parens_brack()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('book = {\"number_of_pages\":285, \"price\":99.23, \"discount\":0.1}\\n'\n                       'print([\"price\"])')\n        ret = dict_parens_brack()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for precip in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + precip[\"Data\"][\"Precipitation\"]\\n'\n                       'print(total_precipitation)\\n')\n        ret = dict_parens_brack()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_comma_dict_acc(self):\n        # TODO: Check output string\n        self.to_source(\"import weather\\n\"\n                       \"weather_reports = weather.get_weather()\\n\"\n                       \"total = 0\\n\"\n                       \"for report in weather_reports:\\n\"\n                       \"    total = total + report['Data'],['Precipitation']\\n\"\n                       \"print(total)\\n\")\n        ret = comma_dict_acc()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for precip in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + precip[\"Data\"][\"Precipitation\"]\\n'\n                       'print(total_precipitation)\\n')\n        ret = comma_dict_acc()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_no_dict_in_loop(self):\n        # TODO: Check output values\n        self.to_source(\"import weather\\n\"\n                       \"weather_reports = weather.get_weather()\\n\"\n                       \"total = 0\\n\"\n                       \"for precip in weather_reports:\\n\"\n                       \"    total = total + precip\\n\"\n                       \"print(total)\\n\")\n        ret = no_dict_in_loop()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for precip in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + precip[\"Data\"][\"Precipitation\"]\\n'\n                       'print(total_precipitation)\\n')\n        ret = no_dict_in_loop()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def func_filter(self):\n        keys = ['Data', 'Date', \"Station\", \"Temperature\", \"Precipitation\", \"Wind\", \"Min Temp\", \"Max Temp\", \"Avg Temp\",\n                \"Direction\", \"Speed\", \"Month\", \"Year\", \"Week of\", \"Full\", \"State\", \"Code\", \"City\", \"Location\"]\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'total_precipitation = 0\\n'\n                       'for report in weather_reports:\\n'\n                       '    total_pecipitation = total_precipitation + weather.get_weather(\"Data\")\\n'\n                       'print(total_precipitation)\\n')\n        ret = func_filter(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'precipitation_total=0\\n'\n                       'weather_reports = weather.get_weather(\"Precipitation\")\\n'\n                       'for report in weather_reports:\\n'\n                       '    precipitation_total = precipitation_total + 1\\n')\n        ret = func_filter(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for precip in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + precip[\"Data\"][\"Precipitation\"]\\n'\n                       'print(total_precipitation)\\n')\n        ret = func_filter()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_str_list(self):\n        # TODO: check output values\n        keys = ['Data', 'Date', \"Station\", \"Temperature\", \"Precipitation\", \"Wind\", \"Min Temp\", \"Max Temp\", \"Avg Temp\",\n                \"Direction\", \"Speed\", \"Month\", \"Year\", \"Week of\", \"Full\", \"State\", \"Code\", \"City\", \"Location\"]\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'totalPrecip = 0\\n'\n                       'for weather in weather_reports:\\n'\n                       '    totalPrecip = totalPrecip + [\"Precipitation\"]\\n'\n                       'print(totalPrecip)\\n')\n        ret = str_list(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for precip in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + precip[\"Data\"][\"Precipitation\"]\\n'\n                       'print(total_precipitation)\\n')\n        ret = str_list(keys)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_list_var_dict_acc(self):\n        # TODO: Check output values\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'pt = 0\\n'\n                       'for precipitation in weather_reports[\"Precipitation\"]:\\n'\n                       '    pt = pt + precipiation\\n'\n                       'print(pt)\\n')\n        ret = list_var_dict_acc()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('total_precipitation = 0\\n'\n                       'for precip in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + precip[\"Data\"][\"Precipitation\"]\\n'\n                       'print(total_precipitation)\\n')\n        ret = list_var_dict_acc()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_key_comp(self):\n        # TODO: Check output values\n        keys = ['Data', 'Date', \"Station\", \"Temperature\", \"Precipitation\", \"Wind\", \"Min Temp\", \"Max Temp\", \"Avg Temp\",\n                \"Direction\", \"Speed\", \"Month\", \"Year\", \"Week of\", \"Full\", \"State\", \"Code\", \"City\", \"Location\"]\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather_instance in weather_reports:\\n'\n                       '    if weather_instance[\"Data\"] == \"Precipitation\":\\n'\n                       '        sum = sum + weather_instance[\"Data\"]\\n'\n                       'print(sum)\\n')\n        ret = key_comp(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather_instance in weather_reports:\\n'\n                       '    if weather_instance[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum = sum + weather_instance[\"Data\"][\"Precipitation\"]\\n'\n                       'print(sum)\\n')\n        ret = key_comp(keys)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_col_dict(self):\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'precipitation = 0\\n'\n                       'for weather in weather_reports:\\n'\n                       '    preciptation = precipitaion + weather[\"Data\":\"Precipitation\"]\\n'\n                       'print(precipitation)\\n')\n        ret = col_dict()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather_instance in weather_reports:\\n'\n                       '    if weather_instance[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum = sum + weather_instance[\"Data\"][\"Precipitation\"]\\n'\n                       'print(sum)\\n')\n        ret = col_dict()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_var_key(self):\n        # TODO: Check output value\n        keys = ['Data', 'Date', \"Station\", \"Temperature\", \"Precipitation\", \"Wind\", \"Min Temp\", \"Max Temp\", \"Avg Temp\",\n                \"Direction\", \"Speed\", \"Month\", \"Year\", \"Week of\", \"Full\", \"State\", \"Code\", \"City\", \"Location\"]\n        self.to_source(\"import weather\\n\"\n                       \"weather_reports = weather.get_weather()\\n\"\n                       \"sum = 0\\n\"\n                       \"for rain in weather_reports:\\n\"\n                       \"    if rain[Station][City] == Chicago:\\n\"\n                       \"        sum = sum + rain[Data][Precipitation]\\n\"\n                       \"print(sum)\\n\")\n        ret = var_key(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather_instance in weather_reports:\\n'\n                       '    if weather_instance[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum = sum + weather_instance[\"Data\"][\"Precipitation\"]\\n'\n                       'print(sum)\\n')\n        ret = var_key(keys)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_key_order(self):\n        keys1 = [\"Station\", \"City\"]\n        keys2 = [\"Data\", \"Precipitation\"]\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather in weather_reports:\\n'\n                       '    if weather[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum = sum + weather_instance[\"Chicago\"][\"Precipitation\"]\\n'\n                       'print(sum)\\n')\n        ret = key_order(keys1)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n        ret = key_order(keys2)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather_instance in weather_reports:\\n'\n                       '    if weather_instance[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum = sum + weather_instance[\"Data\"][\"Precipitation\"]\\n'\n                       'print(sum)\\n')\n        ret = key_order(keys1)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n        ret = key_order(keys2)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather_instance in weather_reports:\\n'\n                       '    station = weather_instance[\"Station\"]\\n'\n                       '    city = station[\"City\"]\\n'\n                       '    if city == \"Chicago\":\\n'\n                       '        data = weather_instance[\"Data\"]\\n'\n                       '        precipitation = data[\"Precipitation\"]\\n'\n                       '        sum = sum + precipitation\\n'\n                       'print(sum)\\n')\n        ret = key_order(keys1)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n        ret = key_order(keys2)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_key_order_unchained(self):\n        keys1 = [\"Station\", \"City\"]\n        keys2 = [\"Data\", \"Precipitation\"]\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather_instance in weather_reports:\\n'\n                       '    station = weather_instance[\"City\"]\\n'\n                       '    city = station[\"Station\"]\\n'\n                       '    if city == \"Chicago\":\\n'\n                       '        data = weather_instance[\"Precipitation\"]\\n'\n                       '        precipitation = data[\"Data\"]\\n'\n                       '        sum = sum + precipitation\\n'\n                       'print(sum)\\n')\n        ret = key_order_unchained(keys1)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n        ret = key_order_unchained(keys2)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather_instance in weather_reports:\\n'\n                       '    station = weather_instance[\"Station\"]\\n'\n                       '    city = station[\"City\"]\\n'\n                       '    if city == \"Chicago\":\\n'\n                       '        data = weather_instance[\"Data\"]\\n'\n                       '        precipitation = data[\"Precipitation\"]\\n'\n                       '        sum = sum + precipitation\\n'\n                       'print(sum)\\n')\n        ret = key_order_unchained(keys1)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n        ret = key_order_unchained(keys2)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather_instance in weather_reports:\\n'\n                       '    if weather_instance[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum = sum + weather_instance[\"Data\"][\"Precipitation\"]\\n'\n                       'print(sum)\\n')\n        ret = key_order_unchained(keys1)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n        ret = key_order_unchained(keys2)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_filt_key(self):\n        # TODO: Check output values\n        c_value = \"Chicago\"\n        num_slices = 3\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'total_precipitation_Chicago = 0\\n'\n                       'total_precipitation_Chicago\\n'\n                       'for report in weather_reports:\\n'\n                       '    total_precipitation = total_precipitation + report[\"Data\"][\"Precipitation\"][\"Chicago\"]\\n'\n                       'print (total_precipitation)\\n')\n        ret = filt_key(c_value, num_slices)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'total_precipitation_Chicago = 0\\n'\n                       'for report in weather_reports:\\n'\n                       '    precip = report[\"Data\"][\"Precipitation\"]\\n'\n                       '    chicago_precip = precip[\"Chicago\"]\\n'\n                       '    total_precipitation = total_precipitation + chicago_recip\\n'\n                       'print (total_precipitation)\\n')\n        ret = filt_key(c_value, num_slices)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather_instance in weather_reports:\\n'\n                       '    if weather_instance[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum = sum + weather_instance[\"Data\"][\"Precipitation\"]\\n'\n                       'print(sum)\\n')\n        ret = filt_key(c_value, num_slices)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_miss_dict_acc(self):\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather_instance in weather_reports:\\n'\n                       '    if City == \"Chicago\":\\n'\n                       '        sum = sum + \"Precipitation\"\\n'\n                       'print(sum)\\n')\n        ret = miss_dict_acc()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'total_precipitation_Chicago = 0\\n'\n                       'total_precipitation_Chicago\\n'\n                       'for report in weather_reports:\\n'\n                       '    precip = report[\"Data\"][\"Precipitation\"]\\n'\n                       '    chicago_precip = precip[\"Chicago\"]\\n'\n                       '    total_precipitation = total_precipitation + chicago_recip\\n'\n                       'print (total_precipitation)\\n')\n        ret = miss_dict_acc()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_compare_key(self):\n        c_value = \"Chicago\"\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather_instance in weather_reports:\\n'\n                       '    if weather_instance[\"Station\"][\"City\"] == [\"Chicago\"]:\\n'\n                       '        sum = sum + weather_instance[\"Data\"][\"Precipitation\"]\\n'\n                       'print(sum)\\n')\n        ret = compare_key(c_value)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'total_precipitation_Chicago = 0\\n'\n                       'total_precipitation_Chicago\\n'\n                       'for report in weather_reports:\\n'\n                       '    precip = report[\"Data\"][\"Precipitation\"]\\n'\n                       '    chicago_precip = precip[\"Chicago\"]\\n'\n                       '    total_precipitation = total_precipitation + chicago_recip\\n'\n                       'print (total_precipitation)\\n')\n        ret = compare_key(c_value)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_str_equality(self):\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = 0\\n'\n                       'for weather in weather_reports:\\n'\n                       '    if(\"City\" == \"Chichago\"):\\n'\n                       '        sum = sum + weather[\"Data\"][\"Precipitation\"]\\n'\n                       'print(sum)\\n')\n        ret = str_equality()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'total_precipitation = 0\\n'\n                       'for report in weather_reports:\\n'\n                       '    if report[\"Station\"][\"City\" == \"Chicago\"]:\\n'\n                       '        total_precipitation = total_precipitation + report[\"Data\"][\"Precipitation\"]\\n'\n                       'print(total_precipitation)\\n')\n        ret = str_equality()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'total_precipitation_Chicago = 0\\n'\n                       'total_precipitation_Chicago\\n'\n                       'for report in weather_reports:\\n'\n                       '    precip = report[\"Data\"][\"Precipitation\"]\\n'\n                       '    chicago_precip = precip[\"Chicago\"]\\n'\n                       '    total_precipitation = total_precipitation + chicago_recip\\n'\n                       'print (total_precipitation)\\n')\n        ret = str_equality()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_unnecessary_cast(self):\n        cast_list = [\"float\"]\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'total_precipitation_Chicago = 0\\n'\n                       'total_precipitation_Chicago\\n'\n                       'for report in weather_reports:\\n'\n                       '    precip = report[\"Data\"][\"Precipitation\"]\\n'\n                       '    chicago_precip = int(precip[\"Chicago\"])\\n'\n                       '    total_precipitation = total_precipitation + chicago_recip\\n'\n                       'print (total_precipitation)\\n')\n        ret = unnecessary_cast(cast_list)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'total_precipitation_Chicago = 0\\n'\n                       'total_precipitation_Chicago\\n'\n                       'for report in weather_reports:\\n'\n                       '    precip = report[\"Data\"][\"Precipitation\"]\\n'\n                       '    chicago_precip = precip[\"Chicago\"]\\n'\n                       '    total_precipitation = total_precipitation + chicago_recip\\n'\n                       'print (total_precipitation)\\n')\n        ret = unnecessary_cast(cast_list)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_fetch_acc_dict(self):\n        keys = [\"Data\", \"Precipitation\", \"Station\", \"Chicago\"]\n        self.to_source('import weather\\n'\n                       'precipitation = 0\\n'\n                       'weather_reports = weather.get_weather(\"Chicago\")\\n'\n                       'where = weather.get_weather[\"Chicago\"]\\n'\n                       'for weather in weather_reports:\\n'\n                       '    precipitation = precipitation + weather[\"Data\"][\"Precipitation\"]\\n'\n                       'print(precipitation)\\n')\n        ret = fetch_acc_dict(keys)\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'total_precipitation_Chicago = 0\\n'\n                       'total_precipitation_Chicago\\n'\n                       'for report in weather_reports:\\n'\n                       '    precip = report[\"Data\"][\"Precipitation\"]\\n'\n                       '    chicago_precip = precip[\"Chicago\"]\\n'\n                       '    total_precipitation = total_precipitation + chicago_recip\\n'\n                       'print (total_precipitation)\\n')\n        ret = fetch_acc_dict(keys)\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_app_assign(self):\n        self.to_source('import weather\\n'\n                       'import matplotlib.pyplot as plt\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = []\\n'\n                       'for rain in weather_reports:\\n'\n                       '    if rain[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum = sum.append(rain[\"Data\"][\"Precipitation\"])\\n'\n                       'plt.plot(sum)\\n'\n                       'plt.xlabel(\"Years\")\\n'\n                       'plt.ylabel(\"Precipitation\")\\n'\n                       'plt.title(\"Chicago Rain\")\\n'\n                       'plt.show(sum)\\n')\n        ret = app_assign()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'total_precipitation_Chicago = 0\\n'\n                       'total_precipitation_Chicago\\n'\n                       'for report in weather_reports:\\n'\n                       '    precip = report[\"Data\"][\"Precipitation\"]\\n'\n                       '    chicago_precip = precip[\"Chicago\"]\\n'\n                       '    total_precipitation = total_precipitation + chicago_recip\\n'\n                       'print (total_precipitation)\\n')\n        ret = app_assign()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_show_args(self):\n        self.to_source('import weather\\n'\n                       'import matplotlib.pyplot as plt\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = []\\n'\n                       'for rain in weather_reports:\\n'\n                       '    if rain[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum.append(rain[\"Data\"][\"Precipitation\"])\\n'\n                       'plt.plot(sum)\\n'\n                       'plt.xlabel(\"Years\")\\n'\n                       'plt.ylabel(\"Precipitation\")\\n'\n                       'plt.title(\"Chicago Rain\")\\n'\n                       'plt.show(sum)\\n')\n        ret = show_args()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'import matplotlib.pyplot as plt\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = []\\n'\n                       'for rain in weather_reports:\\n'\n                       '    if rain[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum.append(rain[\"Data\"][\"Precipitation\"])\\n'\n                       'plt.plot(sum)\\n'\n                       'plt.xlabel(\"Years\")\\n'\n                       'plt.ylabel(\"Precipitation\")\\n'\n                       'plt.title(\"Chicago Rain\")\\n'\n                       'plt.show()\\n')\n        ret = show_args()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_dict_plot(self):\n        self.to_source('import weather\\n'\n                       'import matplotlib.pyplot as plt\\n'\n                       'weather_reports = {}\\n'\n                       'sum = []\\n'\n                       'for rain in weather_reports:\\n'\n                       '    if rain[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum.append(rain[\"Data\"][\"Precipitation\"])\\n'\n                       'plt.plot(weather_reports)\\n'\n                       'plt.xlabel(\"Years\")\\n'\n                       'plt.ylabel(\"Precipitation\")\\n'\n                       'plt.title(\"Chicago Rain\")\\n'\n                       'plt.show()\\n'.format(self._dict_str))\n        ret = dict_plot()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'import matplotlib.pyplot as plt\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'cityWeather = input(\"Choose a city: \")\\n'\n                       'cityPrecip = []\\n'\n                       '# add other input and variable initializations here\\n'\n                       '# Put here the code to create the list of data to be plotted.\\n'\n                       'for weather in weather_reports:\\n'\n                       '    if weather[\"Station\"][\"City\"] == cityWeather:\\n'\n                       '        cityPrecip.append(weather[\"Data\"][\"Precipitation\"])\\n'\n                       '# Put here the code to display a properly labelled line plot of the list of data.\\n'\n                       'plt.plot(cityPrecip)\\n'\n                       'plt.title(cityWeather)\\n'\n                       'plt.xlabel(\"Trend\")\\n'\n                       'plt.ylabel(\"Amount of Precipitation\")\\n'\n                       'plt.show()\\n')\n        ret = dict_plot()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'import matplotlib.pyplot as plt\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = []\\n'\n                       'for rain in weather_reports:\\n'\n                       '    if rain[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum.append(rain[\"Data\"][\"Precipitation\"])\\n'\n                       'plt.plot(sum)\\n'\n                       'plt.xlabel(\"Years\")\\n'\n                       'plt.ylabel(\"Precipitation\")\\n'\n                       'plt.title(\"Chicago Rain\")\\n'\n                       'plt.show()\\n')\n        ret = dict_plot()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_comp_in_dict_acc(self):\n        self.to_source('import weather\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'total_precipitation_Chicago = 0\\n'\n                       'for report in weather_reports:\\n'\n                       '    if report[\"Station\"][\"City\" == \"Chicago\"]:\\n'\n                       '        total_precipitation_Chicago = total_precipitation_Chicago + '\n                       'report[\"Data\"][\"Precipitation\"]\\n'\n                       'print(total_precipitation_Chicago)\\n')\n        ret = comp_in_dict_acc()\n        self.assertTrue(ret, \"Didn't give message, returned {} instead\".format(ret))\n\n        self.to_source('import weather\\n'\n                       'import matplotlib.pyplot as plt\\n'\n                       'weather_reports = weather.get_weather()\\n'\n                       'sum = []\\n'\n                       'for rain in weather_reports:\\n'\n                       '    if rain[\"Station\"][\"City\"] == \"Chicago\":\\n'\n                       '        sum.append(rain[\"Data\"][\"Precipitation\"])\\n'\n                       'plt.plot(sum)\\n'\n                       'plt.xlabel(\"Years\")\\n'\n                       'plt.ylabel(\"Precipitation\")\\n'\n                       'plt.title(\"Chicago Rain\")\\n'\n                       'plt.show()\\n')\n        ret = dict_plot()\n        self.assertFalse(ret, \"Expected False, got {} instead\".format(ret))\n\n    def test_general_testing(self):\n        self.to_source('print(\"fun\")')\n        matches = find_matches(\"_var_\")\n        var = matches[0][\"_var_\"]\n        self.assertTrue(var.ast_name == \"Name\", \"is: {}\".format(var.ast_name))\n", "src/lib/cs1014/tests/__init__.py": "", "src/lib/webgl/primitives.js": "// most of this file is from 'tdl'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n\n\n    /**\n     * AttribBuffer manages a TypedArray as an array of vectors.\n     *\n     * @param {number} numComponents Number of components per\n     *     vector.\n     * @param {number|!Array.<number>} numElements Number of vectors or the data.\n     * @param {string} opt_type The type of the TypedArray to\n     *     create. Default = 'Float32Array'.\n     * @param {!Array.<number>} opt_data The data for the array.\n     */\n    var AttribBuffer = function(\n            numComponents, numElements, opt_type) {\n        opt_type = opt_type || 'Float32Array';\n        var type = window[opt_type];\n        if (numElements.length) {\n            this.buffer = new type(numElements);\n            numElements = this.buffer.length / numComponents;\n            this.cursor = numElements;\n        } else {\n            this.buffer = new type(numComponents * numElements);\n            this.cursor = 0;\n        }\n        this.numComponents = numComponents;\n        this.numElements = numElements;\n        this.type = opt_type;\n    };\n\n    AttribBuffer.prototype.stride = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.offset = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.getElement = function(index) {\n        var offset = index * this.numComponents;\n        var value = [];\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            value.push(this.buffer[offset + ii]);\n        }\n        return value;\n    };\n\n    AttribBuffer.prototype.setElement = function(index, value) {\n        var offset = index * this.numComponents;\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            this.buffer[offset + ii] = value[ii];\n        }\n    };\n\n    AttribBuffer.prototype.clone = function() {\n        var copy = new AttribBuffer(\n                this.numComponents, this.numElements, this.type);\n        copy.pushArray(this);\n        return copy;\n    }\n\n    AttribBuffer.prototype.push = function(value) {\n        this.setElement(this.cursor++, value);\n    };\n\n    AttribBuffer.prototype.pushArray = function(array) {\n        //  this.buffer.set(array, this.cursor * this.numComponents);\n        //  this.cursor += array.numElements;\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            this.push(array.getElement(ii));\n        }\n    };\n\n    AttribBuffer.prototype.pushArrayWithOffset =\n    function(array, offset) {\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            var elem = array.getElement(ii);\n            for (var jj = 0; jj < offset.length; ++jj) {\n                elem[jj] += offset[jj];\n            }\n            this.push(elem);\n        }\n    };\n\n    /**\n    * Computes the extents\n    * @param {!AttribBuffer} positions The positions\n    * @return {!{min: !tdl.math.Vector3, max:!tdl.math.Vector3}}\n    *     The min and max extents.\n    */\n    AttribBuffer.prototype.computeExtents = function() {\n        var numElements = this.numElements;\n        var numComponents = this.numComponents;\n        var minExtent = this.getElement(0);\n        var maxExtent = this.getElement(0);\n        for (var ii = 1; ii < numElements; ++ii) {\n            var element = this.getElement(ii);\n            for (var jj = 0; jj < numComponents; ++jj) {\n                minExtent[jj] = Math.min(minExtent[jj], element[jj]);\n                maxExtent[jj] = Math.max(maxExtent[jj], element[jj]);\n            }\n        }\n        return {min: minExtent, max: maxExtent};\n    };\n\n\n    /**\n     * Creates the vertices and indices for a cube. The\n     * cube will be created around the origin. (-size / 2, size / 2)\n     *\n     * @param {number} size Width, height and depth of the cube.\n     * @return {!Object.<string, !tdl.primitives.AttribBuffer>} The\n     *         created plane vertices.\n     */\n    mod.createCube = new Sk.builtin.func(function(size)\n            {\n                var CUBE_FACE_INDICES_ = [\n                    [3, 7, 5, 1],\n                    [0, 4, 6, 2],\n                    [6, 7, 3, 2],\n                    [0, 1, 5, 4],\n                    [5, 7, 6, 4],\n                    [2, 3, 1, 0]\n                ];\n\n                var k = size / 2;\n\n                var cornerVertices = [\n                        [-k, -k, -k],\n                        [+k, -k, -k],\n                        [-k, +k, -k],\n                        [+k, +k, -k],\n                        [-k, -k, +k],\n                        [+k, -k, +k],\n                        [-k, +k, +k],\n                        [+k, +k, +k]\n                    ];\n\n                var faceNormals = [\n                        [+1, +0, +0],\n                        [-1, +0, +0],\n                        [+0, +1, +0],\n                        [+0, -1, +0],\n                        [+0, +0, +1],\n                        [+0, +0, -1]\n                    ];\n\n                var uvCoords = [\n                        [0, 0],\n                        [1, 0],\n                        [1, 1],\n                        [0, 1]\n                    ];\n\n                var numVertices = 6 * 4;\n                var positions = new AttribBuffer(3, numVertices);\n                var normals = new AttribBuffer(3, numVertices);\n                var texCoords = new AttribBuffer(2, numVertices);\n                var indices = new AttribBuffer(3, 6 * 2, 'Uint16Array');\n\n                for (var f = 0; f < 6; ++f) {\n                    var faceIndices = CUBE_FACE_INDICES_[f];\n                    for (var v = 0; v < 4; ++v) {\n                        var position = cornerVertices[faceIndices[v]];\n                        var normal = faceNormals[f];\n                        var uv = uvCoords[v];\n\n                        // Each face needs all four vertices because the normals and texture\n                        // coordinates are not all the same.\n                        positions.push(position);\n                        normals.push(normal);\n                        texCoords.push(uv);\n\n                    }\n                    // Two triangles make a square face.\n                    var offset = 4 * f;\n                    indices.push([offset + 0, offset + 1, offset + 2]);\n                    indices.push([offset + 0, offset + 2, offset + 3]);\n                }\n\n                return {\n                        position: positions,\n                        normal: normals,\n                        texCoord: texCoords,\n                        indices: indices\n                };\n            });\n\n    return mod;\n};\n", "src/lib/webgl/__init__.js": "var $builtinmodule = function(name)\n{\n  var mod = {};\n\n  var makeFailHTML = function(msg) {\n    return '' +\n      '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\n      '<td align=\"center\">' +\n      '<div style=\"display: table-cell; vertical-align: middle;\">' +\n      '<div style=\"\">' + msg + '</div>' +\n      '</div>' +\n      '</td></tr></table>';\n  };\n\n  var GET_A_WEBGL_BROWSER = '' +\n    'This page requires a browser that supports WebGL.<br/>' +\n    '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\n\n  var NEED_HARDWARE = '' +\n    \"It doesn't appear your computer can support WebGL.<br/>\" +\n    '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\n  \n  var create3DContext = function(canvas) {\n    var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\n    var gl = null;\n    for (var ii = 0; ii < names.length; ++ii) {\n      try {\n        gl = canvas.getContext(names[ii]);\n      }\n      catch(e) {\n      }\n      if (gl) {\n          break;\n      }\n    }\n    if (gl) {\n      // Disallow selection by default. This keeps the cursor from changing to an\n      // I-beam when the user clicks and drags. It's easier on the eyes.\n      function returnFalse() {\n        return false;\n      }\n\n      canvas.onselectstart = returnFalse;\n      canvas.onmousedown = returnFalse;\n    }\n    return gl;\n  };\n\n  var setupWebGL = function(canvasContainerId, opt_canvas) {\n    var container = document.getElementById(canvasContainerId);\n    var context;\n    if (!opt_canvas) {\n      opt_canvas = container.getElementsByTagName(\"canvas\")[0];\n    }\n    if (!opt_canvas) {\n        // this browser doesn't support the canvas tag at all. Not even 2d.\n      container.innerHTML = makeFailHTML(GET_A_WEBGL_BROWSER);\n      return;\n    }\n\n    var gl = create3DContext(opt_canvas);\n    if (!gl) {\n      // TODO(gman): fix to official way to detect that it's the user's machine, not the browser.\n      var browserStrings = navigator.userAgent.match(/(\\w+\\/.*? )/g);\n      var browsers = {};\n      try {\n        for (var b = 0; b < browserStrings.length; ++b) {\n          var parts = browserStrings[b].match(/(\\w+)/g);\n          var bb = [];\n          for (var ii = 1; ii < parts.length; ++ii) {\n            bb.push(parseInt(parts[ii]));\n          }\n          browsers[parts[0]] = bb;\n        }\n      }\n      catch (e) {\n      }\n      if (browsers.Chrome &&\n           (browsers.Chrome[0] > 7 ||\n                 (browsers.Chrome[0] == 7 && browsers.Chrome[1] > 0) ||\n                 (browsers.Chrome[0] == 7 && browsers.Chrome[1] == 0 && browsers.Chrome[2] >= 521))) {\n        container.innerHTML = makeFailHTML(NEED_HARDWARE);\n      }\n      else {\n        container.innerHTML = makeFailHTML(GET_A_WEBGL_BROWSER);\n      }\n    }\n    return gl;\n  };\n\n  /**\n   * The Context encapsulates the underlying WebGL native JavaScript API.\n   */\n  mod.Context = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(\n      function(self, canvasid) {\n        var canvas = document.getElementById(canvasid.v);\n        var gl = setupWebGL(canvasid.v, canvas)\n        if (!gl) {\n          throw new Error(\"Your browser does not appear to support WebGL.\");\n        }\n\n        self.gl = gl;\n\n        // Copy symbolic constants and functions from native WebGL, encapsulating where necessary.       \n        for (var k in gl.__proto__) {\n          if (typeof gl.__proto__[k] === 'number') {\n            Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str(k), gl.__proto__[k]);\n          }\n          else if (typeof gl.__proto__[k] === \"function\") {\n            switch(k) {\n              case 'bufferData': {\n              }\n              break;\n              case 'clearColor': {\n              }\n              break;\n              case 'drawArrays': {\n              }\n              break;\n              case 'getAttribLocation': {\n              }\n              break;\n              case 'getUniformLocation': {\n              }\n              break;\n              case 'shaderSource': {\n              }\n              break;\n              case 'uniformMatrix4fv': {\n              }\n              break;\n              case 'vertexAttribPointer': {\n              }\n              break;\n              case 'viewport': {\n              }\n              break;\n              default: {\n                (function(key) {\n                  Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str(k), new Sk.builtin.func(function() {\n                    var f = gl.__proto__[key];\n                    return f.apply(gl, arguments);\n                  }));\n                 }(k));\n              }\n            }\n          }\n        }\n\n        gl.clearColor(100.0/255.0, 149.0/255.0, 237.0/255.0, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      }\n    );\n\n    $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n    $loc.bufferData = new Sk.builtin.func(\n      function(self, target, data, usage) {\n        self.gl.bufferData(target, data.v, usage);\n      }\n    );\n\n    $loc.clearColor = new Sk.builtin.func(\n      function(self, red, green, blue, alpha) {\n        self.gl.clearColor(Sk.builtin.asnum$(red), Sk.builtin.asnum$(green), Sk.builtin.asnum$(blue), Sk.builtin.asnum$(alpha));\n      }\n    );\n\n    $loc.getAttribLocation = new Sk.builtin.func(\n      function(self, program, name) {\n        return self.gl.getAttribLocation(program, name.v);\n      }\n    );\n\n    $loc.getUniformLocation = new Sk.builtin.func(\n      function(self, program, name) {\n        return self.gl.getUniformLocation(program, name.v);\n      }\n    );\n\n    $loc.shaderSource = new Sk.builtin.func(\n      function(self, shader, src) {\n        self.gl.shaderSource(shader, src.v);\n      }\n    );\n\n    $loc.drawArrays = new Sk.builtin.func(\n      function(self, mode, first, count) {\n        self.gl.drawArrays(Sk.builtin.asnum$(mode), Sk.builtin.asnum$(first), Sk.builtin.asnum$(count));\n      }\n    );\n\n    $loc.vertexAttribPointer = new Sk.builtin.func(\n      function(self, index, size, type, normalized, stride, dunno) {\n        self.gl.vertexAttribPointer(index, Sk.builtin.asnum$(size), Sk.builtin.asnum$(type), normalized, Sk.builtin.asnum$(stride), Sk.builtin.asnum$(dunno));\n      }\n    );\n\n    $loc.viewport = new Sk.builtin.func(\n      function(self, x, y, width, height) {\n        self.gl.viewport(Sk.builtin.asnum$(x), Sk.builtin.asnum$(y), Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));\n      }\n    );\n\n    $loc.uniformMatrix4fv = new Sk.builtin.func(\n      function(self, location, transpose, values) {\n//        console.log(\"location  \" + (typeof location));\n//        console.log(\"transpose \" + (typeof transpose));\n//        console.log(\"values.v  \" + (typeof values.v));\n        self.gl.uniformMatrix4fv(Sk.builtin.asnum$(location), transpose, values.v);\n      }\n    );\n\n    $loc.setDrawFunc = new Sk.builtin.func(function(self, func) {\n      var startTime = (new Date()).getTime();\n      var intervalId = setInterval(\n        function() {\n          Sk.misceval.callsim(func, self, (new Date()).getTime() - startTime);\n        }, 1000.0 / 60.0); // 60 fps\n    });\n\n  }, 'Context', []);\n\n  mod.Float32Array = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, data) {\n      if (typeof data === \"number\") {\n        self.v = new Float32Array(data);\n      }\n      else {\n        self.v = new Float32Array(Sk.ffi.remapToJs(data));\n      }\n    });\n\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var copy = [];\n      for (var i = 0; i < self.v.length; ++i) {\n        copy.push(self.v[i]);\n      }\n      return new Sk.builtin.str(\"[\" + copy.join(', ') + \"]\");\n     });\n  }, 'Float32Array', []);\n\n  /**\n   * A 4x4 (mutable) matrix suitable for OpenGL.\n   *\n   * Mutability is chosen for performance.\n   * The inderlying implementation is Float32Array.\n   * The indexing of the elements is\n   * 0 4  8 12\n   * 1 5  9 13\n   * 2 6 10 14\n   * 3 7 11 15\n   */\n  mod.Matrix4x4 = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, data) {\n      self.v = new Float32Array(Sk.ffi.remapToJs(data));\n    });\n\n    $loc.identity = new Sk.builtin.func(\n      function(self) {\n\n        var m = self.v;\n\n        m[0]  = 1;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = 1;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = 1;\n        m[11] = 0;\n\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n      }\n    );\n\n    $loc.perspective = new Sk.builtin.func(\n      function(self, fov, aspect, near, far) {\n        \n        var t = Math.tan(Math.PI * 0.5 - 0.5 * (Sk.builtin.asnum$(fov) * Math.PI / 180));\n        var a = Sk.builtin.asnum$(aspect)\n        var n = Sk.builtin.asnum$(near)\n        var f = Sk.builtin.asnum$(far)\n        var k = 1.0 / (n - f);\n\n        var m = self.v;\n\n        m[0]  = t / a;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = t;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = (n + f) * k;\n        m[11] = -1;\n\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = n * f * k * 2;\n        m[15] = 0;\n      }\n    );\n\n    $loc.translate = new Sk.builtin.func(\n      function(self, translation) {\n\n        var m = self.v;\n        var t = Sk.ffi.remapToJs(translation);\n\n        m[0]  = 1;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = 1;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = 1;\n        m[11] = 0;\n\n        m[12] = t[0];\n        m[13] = t[1];\n        m[14] = t[2];\n        m[15] = 1;\n      }\n    );\n\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var copy = [];\n      for (var i = 0; i < self.v.length; ++i) {\n        copy.push(self.v[i]);\n      }\n      return new Sk.builtin.str(\"[\" + copy.join(', ') + \"]\");\n     });\n  }, 'Matrix4x4', []);\n\n  return mod;\n};", "src/lib/webgl/models.js": "// most of this file is from/based on 'tdl'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var Buffer = function(array, opt_target) {\n        var target = opt_target || gl.ARRAY_BUFFER;\n        var buf = gl.createBuffer();\n        this.target = target;\n        this.buf = buf;\n        this.set(array);\n        this.numComponents_ = array.numComponents;\n        this.numElements_ = array.numElements;\n        this.totalComponents_ = this.numComponents_ * this.numElements_;\n        if (array.buffer instanceof Float32Array) {\n            this.type_ = gl.FLOAT;\n        } else if (array.buffer instanceof Uint8Array) {\n            this.type_ = gl.UNSIGNED_BYTE;\n        } else if (array.buffer instanceof Int8Array) {\n            this.type_ = gl._BYTE;\n        } else if (array.buffer instanceof Uint16Array) {\n            this.type_ = gl.UNSIGNED_SHORT;\n        } else if (array.buffer instanceof Int16Array) {\n            this.type_ = gl.SHORT;\n        } else {\n            throw(\"unhandled type:\" + (typeof array.buffer));\n        }\n    };\n\n    Buffer.prototype.set = function(array) {\n        gl.bindBuffer(this.target, this.buf);\n        gl.bufferData(this.target, array.buffer, gl.STATIC_DRAW);\n    }\n\n    Buffer.prototype.type = function() {\n        return this.type_;\n    };\n\n    Buffer.prototype.numComponents = function() {\n        return this.numComponents_;\n    };\n\n    Buffer.prototype.numElements = function() {\n        return this.numElements_;\n    };\n\n    Buffer.prototype.totalComponents = function() {\n        return this.totalComponents_;\n    };\n\n    Buffer.prototype.buffer = function() {\n        return this.buf;\n    };\n\n    Buffer.prototype.stride = function() {\n        return 0;\n    };\n\n    Buffer.prototype.offset = function() {\n        return 0;\n    };\n\n\n\n    mod.Model = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, shader, arrays, textures)\n                    {\n                        self.buffers = {};\n                        var setBuffer = function(name, array)\n                        {\n                            var target = (name == 'indices') ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n                            b = self.buffers[name];\n                            if (!b)\n                                b = new Buffer(array, target);\n                            else\n                                b.set(array);\n                            self.buffers[name] = b;\n                        };\n                        for (name in arrays)\n                            setBuffer(name, arrays[name]);\n\n                        var textureUnits = {};\n                        var unit = 0;\n                        for (var texture in textures)\n                        {\n                            textureUnits[texture] = unit++;\n                        }\n\n                        self.mode = gl.TRIANGLES;\n                        self.textures = textures.v;\n                        self.textureUnits = textureUnits;\n                        self.shader = shader;\n                    });\n\n                /**\n                * Sets up the shared parts of drawing this model. Uses the\n                * program, binds the buffers, sets the textures.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.drawPrep = new Sk.builtin.func(function(self, uniforms)\n                    {\n                        var shader = self.shader;\n                        var buffers = self.buffers;\n                        var textures = self.textures;\n\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n\n                        Sk.misceval.callsim(shader.use, shader);\n\n                        for (var buffer in buffers) {\n                            var b = buffers[buffer];\n                            if (buffer == 'indices') {\n                                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b.buffer());\n                            } else {\n                                var attrib = shader.attrib[buffer];\n                                if (attrib) {\n                                    attrib(b);\n                                }\n                            }\n                        }\n\n                        for (var texture in textures) {\n                            var unit = self.textureUnits[texture];\n                            shader.setUniform$impl(shader, textuer, unit);\n                            textures[texture].bindToUnit(unit);\n                        }\n\n                        for (var uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n                    });\n\n                /**\n                * Draws this model.\n                *\n                * After calling tdl.models.Model.drawPrep you can call this\n                * function multiple times to draw this model.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.draw = new Sk.builtin.func(function(self, uniforms, opt_textures)\n                    {\n                        var shader = self.shader;\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n                        for (uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n\n                        if (opt_textures) {\n                            for (var texture in opt_textures) {\n                                var unit = self.textureUnits[texture];\n                                shader.setUniform$impl(shader, texture, unit);\n                                opt_textures[texture].bindToUnit(unit);\n                            }\n                        }\n\n                        var buffers = self.buffers;\n                        gl.drawElements(self.mode, buffers.indices.totalComponents(), gl.UNSIGNED_SHORT, 0);\n                    });\n            },\n            'Model', []);\n\n    return mod;\n};\n", "src/lib/webgl/math.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // todo; should probably put this in a math package\n    mod.Mat44 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                        self.stack = [];\n                    });\n\n                $loc.push = new Sk.builtin.func(function(self)\n                    {\n                        self.stack.push(self.elements.slice(0));\n                    });\n\n                $loc.pop = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = self.stack.pop();\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0, 0.0,\n                                         0.0, 0.0, 1.0, 0.0,\n                                         0.0, 0.0, 0.0, 1.0];\n                    });\n\n                $loc.transform3 = new Sk.builtin.func(function(self, v)\n                    {\n                        var e = self.elements;\n                        return Sk.misceval.callsim(mod.Vec3,\n                            e[0] * v.x + e[4] * v.y + e[8] * v.z,\n                            e[1] * v.x + e[5] * v.y + e[9] * v.z,\n                            e[2] * v.x + e[6] * v.y + e[10] * v.z);\n                    });\n\n                $loc.scale = new Sk.builtin.func(function(self, sx, sy, sz)\n                        {\n                            self.elements[0*4+0] *= sx;\n                            self.elements[0*4+1] *= sx;\n                            self.elements[0*4+2] *= sx;\n                            self.elements[0*4+3] *= sx;\n\n                            self.elements[1*4+0] *= sy;\n                            self.elements[1*4+1] *= sy;\n                            self.elements[1*4+2] *= sy;\n                            self.elements[1*4+3] *= sy;\n\n                            self.elements[2*4+0] *= sz;\n                            self.elements[2*4+1] *= sz;\n                            self.elements[2*4+2] *= sz;\n                            self.elements[2*4+3] *= sz;\n\n                            return self;\n                        });\n\n                $loc.translate = new Sk.builtin.func(function(self, tx, ty, tz)\n                        {\n                            self.elements[3*4+0] += self.elements[0*4+0] * tx + self.elements[1*4+0] * ty + self.elements[2*4+0] * tz;\n                            self.elements[3*4+1] += self.elements[0*4+1] * tx + self.elements[1*4+1] * ty + self.elements[2*4+1] * tz;\n                            self.elements[3*4+2] += self.elements[0*4+2] * tx + self.elements[1*4+2] * ty + self.elements[2*4+2] * tz;\n                            self.elements[3*4+3] += self.elements[0*4+3] * tx + self.elements[1*4+3] * ty + self.elements[2*4+3] * tz;\n                            return self;\n                        });\n\n                $loc.rotate = new Sk.builtin.func(function(self, angle, x, y, z)\n                        {\n                            var mag = Math.sqrt(x*x + y*y + z*z);\n                            var sinAngle = Math.sin(angle * Math.PI / 180.0);\n                            var cosAngle = Math.cos(angle * Math.PI / 180.0);\n\n                            if (mag > 0)\n                            {\n                                var xx, yy, zz, xy, yz, zx, xs, ys, zs;\n                                var oneMinusCos;\n                                var rotMat;\n\n                                x /= mag;\n                                y /= mag;\n                                z /= mag;\n\n                                xx = x * x;\n                                yy = y * y;\n                                zz = z * z;\n                                xy = x * y;\n                                yz = y * z;\n                                zx = z * x;\n                                xs = x * sinAngle;\n                                ys = y * sinAngle;\n                                zs = z * sinAngle;\n                                oneMinusCos = 1.0 - cosAngle;\n\n                                rotMat = Sk.misceval.callsim(mod.Mat44);\n\n                                rotMat.elements[0*4+0] = (oneMinusCos * xx) + cosAngle;\n                                rotMat.elements[0*4+1] = (oneMinusCos * xy) - zs;\n                                rotMat.elements[0*4+2] = (oneMinusCos * zx) + ys;\n                                rotMat.elements[0*4+3] = 0.0;\n\n                                rotMat.elements[1*4+0] = (oneMinusCos * xy) + zs;\n                                rotMat.elements[1*4+1] = (oneMinusCos * yy) + cosAngle;\n                                rotMat.elements[1*4+2] = (oneMinusCos * yz) - xs;\n                                rotMat.elements[1*4+3] = 0.0;\n\n                                rotMat.elements[2*4+0] = (oneMinusCos * zx) - ys;\n                                rotMat.elements[2*4+1] = (oneMinusCos * yz) + xs;\n                                rotMat.elements[2*4+2] = (oneMinusCos * zz) + cosAngle;\n                                rotMat.elements[2*4+3] = 0.0;\n\n                                rotMat.elements[3*4+0] = 0.0;\n                                rotMat.elements[3*4+1] = 0.0;\n                                rotMat.elements[3*4+2] = 0.0;\n                                rotMat.elements[3*4+3] = 1.0;\n\n                                rotMat = rotMat.multiply(self);\n                                self.elements = rotMat.elements;\n                            }\n                            return self;\n                        });\n\n                $loc.multiply = new Sk.builtin.func(function(self, right)\n                        {\n                            var tmp = Sk.misceval.callsim(mod.Mat44);\n\n                            for (var i = 0; i < 4; i++)\n                            {\n                                tmp.elements[i*4+0] =\n                                (self.elements[i*4+0] * right.elements[0*4+0]) +\n                                (self.elements[i*4+1] * right.elements[1*4+0]) +\n                                (self.elements[i*4+2] * right.elements[2*4+0]) +\n                                (self.elements[i*4+3] * right.elements[3*4+0]) ;\n\n                                tmp.elements[i*4+1] =\n                                (self.elements[i*4+0] * right.elements[0*4+1]) +\n                                (self.elements[i*4+1] * right.elements[1*4+1]) +\n                                (self.elements[i*4+2] * right.elements[2*4+1]) +\n                                (self.elements[i*4+3] * right.elements[3*4+1]) ;\n\n                                tmp.elements[i*4+2] =\n                                (self.elements[i*4+0] * right.elements[0*4+2]) +\n                                (self.elements[i*4+1] * right.elements[1*4+2]) +\n                                (self.elements[i*4+2] * right.elements[2*4+2]) +\n                                (self.elements[i*4+3] * right.elements[3*4+2]) ;\n\n                                tmp.elements[i*4+3] =\n                                (self.elements[i*4+0] * right.elements[0*4+3]) +\n                                (self.elements[i*4+1] * right.elements[1*4+3]) +\n                                (self.elements[i*4+2] * right.elements[2*4+3]) +\n                                (self.elements[i*4+3] * right.elements[3*4+3]) ;\n                            }\n\n                            self.elements = tmp.elements;\n                            return self;\n                        });\n\n                /* Following gluLookAt implementation is adapted from\n                 * the Mesa 3D Graphics library. http://www.mesa3d.org\n                 */\n                // todo; rewrite this with proper vec/mat ops\n                $loc.lookAt = new Sk.builtin.func(function(self, eyeX, eyeY, eyeZ,\n                                                                 centerX, centerY, centerZ,\n                                                                 upX, upY, upZ)\n                        {\n                            /* Z vector */\n                            var z = [\n                                eyeX - centerX,\n                                eyeY - centerY,\n                                eyeZ - centerZ\n                            ];\n                            var mag = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);\n                            if (mag)\n                            {\n                                z[0] /= mag;\n                                z[1] /= mag;\n                                z[2] /= mag;\n                            }\n\n                            /* Y vector */\n                            var y = [ upX, upY, upZ ];\n\n                            /* X vector = Y cross Z */\n                            var x = [];\n                            x[0] = y[1] * z[2] - y[2] * z[1];\n                            x[1] = -y[0] * z[2] + y[2] * z[0];\n                            x[2] = y[0] * z[1] - y[1] * z[0];\n\n                            /* Recompute Y = Z cross X */\n                            y[0] = z[1] * x[2] - z[2] * x[1];\n                            y[1] = -z[0] * x[2] + z[2] * x[0];\n                            y[2] = z[0] * x[1] - z[1] * x[0];\n\n                            /* mpichler, 19950515 */\n                            /* cross product gives area of parallelogram, which is < 1.0 for\n                            * non-perpendicular unit-length vectors; so normalize x, y here\n                            */\n\n                            mag = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n                            if (mag) {\n                                x[0] /= mag;\n                                x[1] /= mag;\n                                x[2] /= mag;\n                            }\n\n                            mag = Math.sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]);\n                            if (mag) {\n                                y[0] /= mag;\n                                y[1] /= mag;\n                                y[2] /= mag;\n                            }\n\n                            var lookAt = Sk.misceval.callsim(mod.Mat44);\n                            lookAt.elements[0 * 4 + 0] = x[0];\n                            lookAt.elements[1 * 4 + 0] = x[1];\n                            lookAt.elements[2 * 4 + 0] = x[2];\n                            lookAt.elements[3 * 4 + 0] = 0.;\n                            lookAt.elements[0 * 4 + 1] = y[0];\n                            lookAt.elements[1 * 4 + 1] = y[1];\n                            lookAt.elements[2 * 4 + 1] = y[2];\n                            lookAt.elements[3 * 4 + 1] = 0.;\n                            lookAt.elements[0 * 4 + 2] = z[0];\n                            lookAt.elements[1 * 4 + 2] = z[1];\n                            lookAt.elements[2 * 4 + 2] = z[2];\n                            lookAt.elements[3 * 4 + 2] = 0.;\n                            lookAt.elements[0 * 4 + 3] = 0.;\n                            lookAt.elements[1 * 4 + 3] = 0.;\n                            lookAt.elements[2 * 4 + 3] = 0.;\n                            lookAt.elements[3 * 4 + 3] = 1.;\n\n                            // log(lookAt.elements);\n\n                            lookAt = lookAt.multiply(self);\n                            self.elements = lookAt.elements;\n                            self.translate(-eyeX, -eyeY, -eyeZ);\n\n                            // log(this.elements);\n\n                            return self;\n                        });\n            },\n            'Mat44', []);\n\n    // todo; should probably put this in a math package\n    mod.Mat33 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0,\n                                         0.0, 0.0, 1.0];\n                    });\n            },\n            'Mat33', []);\n\n    mod.Vec3 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, x, y, z)\n                    {\n                        self.x = x;\n                        self.y = y;\n                        self.z = z;\n                    });\n                $loc.__sub__ = new Sk.builtin.func(function(self, other)\n                    {\n                        return Sk.misceval.callsim(mod.Vec3, self.x - other.x, self.y - other.y, self.z - other.z);\n                    });\n            },\n            'Vec3', []);\n    \n    mod.cross = new Sk.builtin.func(function(v1, v2)\n            {\n                goog.asserts.assert(v1 instanceof mod.Vec3 && v2 instanceof mod.Vec3);\n                return Sk.misceval.callsim(mod.Vec3,\n                    v1.y * v2.z - v1.z * v2.y,\n                    v1.z * v2.x - v1.x * v2.z,\n                    v1.x * v2.y - v1.y * v2.x);\n            });\n\n    return mod;\n};\n", "src/lib/webgl/matrix4.js": "// more from 'tdl'\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var temp0v3_ = new Float32Array(3);\n    var temp1v3_ = new Float32Array(3);\n    var temp2v3_ = new Float32Array(3);\n\n    var temp0v4_ = new Float32Array(4);\n    var temp1v4_ = new Float32Array(4);\n    var temp2v4_ = new Float32Array(4);\n\n    var temp0m4_ = new Float32Array(16);\n    var temp1m4_ = new Float32Array(16);\n    var temp2m4_ = new Float32Array(16);\n\n    var normalize = function(dst, a) {\n        var n = 0.0;\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            n += a[i] * a[i];\n        n = Math.sqrt(n);\n        if (n > 0.00001) {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = a[i] / n;\n        } else {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = 0;\n        }\n        return dst;\n    };\n\n    var cross = function(dst, a, b) {\n        dst[0] = a[1] * b[2] - a[2] * b[1];\n        dst[1] = a[2] * b[0] - a[0] * b[2];\n        dst[2] = a[0] * b[1] - a[1] * b[0];\n        return dst;\n    };\n\n    var subVector = function(dst, a, b) {\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            dst[i] = a[i] - b[i];\n        return dst;\n    };\n\n    var dot = function(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n    };\n\n    mod.lookAt = new Sk.builtin.func(function(view, eye, target, up)\n            {\n                var t0 = temp0v3_;\n                var t1 = temp1v3_;\n                var t2 = temp2v3_;\n\n                var vz = normalize(t0, subVector(t0, eye.v, target.v));\n                var vx = normalize(t1, cross(t1, up.v, vz));\n                var vy = cross(t2, vz, vx);\n\n                var dst = view.v;\n                dst[ 0] = vx[0];\n                dst[ 1] = vy[0];\n                dst[ 2] = vz[0];\n                dst[ 3] = 0;\n                dst[ 4] = vx[1];\n                dst[ 5] = vy[1];\n                dst[ 6] = vz[1];\n                dst[ 7] = 0;\n                dst[ 8] = vx[2];\n                dst[ 9] = vy[2];\n                dst[10] = vz[2];\n                dst[11] = 0;\n                dst[12] = -dot(vx, eye.v);\n                dst[13] = -dot(vy, eye.v);\n                dst[14] = -dot(vz, eye.v);\n                dst[15] = 1;\n\n                return view;\n            });\n\n    mod.perspective = new Sk.builtin.func(function(proj, angle, aspect, near, far)\n            {\n                var f = Math.tan(Math.PI * 0.5 - 0.5 * (angle * Math.PI / 180));\n                var rangeInv = 1.0 / (near - far);\n\n                var dst = proj.v;\n\n                dst[0]  = f / aspect;\n                dst[1]  = 0;\n                dst[2]  = 0;\n                dst[3]  = 0;\n\n                dst[4]  = 0;\n                dst[5]  = f;\n                dst[6]  = 0;\n                dst[7]  = 0;\n\n                dst[8]  = 0;\n                dst[9]  = 0;\n                dst[10] = (near + far) * rangeInv;\n                dst[11] = -1;\n\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = near * far * rangeInv * 2;\n                dst[15] = 0;\n\n                return proj;\n            });\n\n    // builds, not appending\n    mod.rotationY = new Sk.builtin.func(function(target, angle)\n            {\n                var dst = target.v;\n                var c = Math.cos(angle * Math.PI / 180);\n                var s = Math.sin(angle * Math.PI / 180);\n\n                dst[ 0] = c;\n                dst[ 1] = 0;\n                dst[ 2] = -s;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = s;\n                dst[ 9] = 0;\n                dst[10] = c;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n\n                return target;\n            });\n\n    mod.identity = new Sk.builtin.func(function(target)\n            {\n                var dst = target.v;\n                dst[ 0] = 1;\n                dst[ 1] = 0;\n                dst[ 2] = 0;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = 0;\n                dst[ 9] = 0;\n                dst[10] = 1;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n                return target;\n            });\n\n    // row major\n    mod.mul = new Sk.builtin.func(function(target, x, y)\n            {\n                var dst = target.v;\n                var a = x.v;\n                var b = y.v;\n                var a00 = a[0];\n                var a01 = a[1];\n                var a02 = a[2];\n                var a03 = a[3];\n                var a10 = a[ 4 + 0];\n                var a11 = a[ 4 + 1];\n                var a12 = a[ 4 + 2];\n                var a13 = a[ 4 + 3];\n                var a20 = a[ 8 + 0];\n                var a21 = a[ 8 + 1];\n                var a22 = a[ 8 + 2];\n                var a23 = a[ 8 + 3];\n                var a30 = a[12 + 0];\n                var a31 = a[12 + 1];\n                var a32 = a[12 + 2];\n                var a33 = a[12 + 3];\n                var b00 = b[0];\n                var b01 = b[1];\n                var b02 = b[2];\n                var b03 = b[3];\n                var b10 = b[ 4 + 0];\n                var b11 = b[ 4 + 1];\n                var b12 = b[ 4 + 2];\n                var b13 = b[ 4 + 3];\n                var b20 = b[ 8 + 0];\n                var b21 = b[ 8 + 1];\n                var b22 = b[ 8 + 2];\n                var b23 = b[ 8 + 3];\n                var b30 = b[12 + 0];\n                var b31 = b[12 + 1];\n                var b32 = b[12 + 2];\n                var b33 = b[12 + 3];\n                dst[ 0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n                dst[ 1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n                dst[ 2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n                dst[ 3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n                dst[ 4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\n                dst[ 5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\n                dst[ 6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\n                dst[ 7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\n                dst[ 8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\n                dst[ 9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\n                dst[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\n                dst[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\n                dst[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\n                dst[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\n                dst[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\n                dst[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\n                return target;\n            });\n\n    mod.invert = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                var m00 = m[0 * 4 + 0];\n                var m01 = m[0 * 4 + 1];\n                var m02 = m[0 * 4 + 2];\n                var m03 = m[0 * 4 + 3];\n                var m10 = m[1 * 4 + 0];\n                var m11 = m[1 * 4 + 1];\n                var m12 = m[1 * 4 + 2];\n                var m13 = m[1 * 4 + 3];\n                var m20 = m[2 * 4 + 0];\n                var m21 = m[2 * 4 + 1];\n                var m22 = m[2 * 4 + 2];\n                var m23 = m[2 * 4 + 3];\n                var m30 = m[3 * 4 + 0];\n                var m31 = m[3 * 4 + 1];\n                var m32 = m[3 * 4 + 2];\n                var m33 = m[3 * 4 + 3];\n                var tmp_0  = m22 * m33;\n                var tmp_1  = m32 * m23;\n                var tmp_2  = m12 * m33;\n                var tmp_3  = m32 * m13;\n                var tmp_4  = m12 * m23;\n                var tmp_5  = m22 * m13;\n                var tmp_6  = m02 * m33;\n                var tmp_7  = m32 * m03;\n                var tmp_8  = m02 * m23;\n                var tmp_9  = m22 * m03;\n                var tmp_10 = m02 * m13;\n                var tmp_11 = m12 * m03;\n                var tmp_12 = m20 * m31;\n                var tmp_13 = m30 * m21;\n                var tmp_14 = m10 * m31;\n                var tmp_15 = m30 * m11;\n                var tmp_16 = m10 * m21;\n                var tmp_17 = m20 * m11;\n                var tmp_18 = m00 * m31;\n                var tmp_19 = m30 * m01;\n                var tmp_20 = m00 * m21;\n                var tmp_21 = m20 * m01;\n                var tmp_22 = m00 * m11;\n                var tmp_23 = m10 * m01;\n\n                var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -\n                    (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\n                var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -\n                    (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\n                var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -\n                    (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\n                var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -\n                    (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\n\n                var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n\n                dst[ 0] = d * t0;\n                dst[ 1] = d * t1;\n                dst[ 2] = d * t2;\n                dst[ 3] = d * t3;\n                dst[ 4] = d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -\n                        (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\n                dst[ 5] = d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -\n                        (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\n                dst[ 6] = d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -\n                        (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\n                dst[ 7] = d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -\n                        (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\n                dst[ 8] = d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -\n                        (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\n                dst[ 9] = d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -\n                        (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\n                dst[10] = d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -\n                        (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\n                dst[11] = d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -\n                        (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\n                dst[12] = d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -\n                        (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\n                dst[13] = d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -\n                        (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\n                dst[14] = d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -\n                        (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\n                dst[15] = d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -\n                        (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\n                return target;\n            });\n\n    mod.transpose = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                for (var j = 0; j < 4; ++j) {\n                    for (var i = 0; i < 4; ++i)\n                    dst[j * 4 + i] = m[i * 4 + j];\n                }\n                return dst;\n            });\n\n    return mod;\n};\n", "src/lib/stocks/__init__.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n    \n    var STOCK_REPORTS = {\n        'FB':   [  1.1,   1.0,   0.7, 0.12,  -0.3, -0.34,  -0.1, -0.45, -0.74],\n        'AAPL': [ 0.47,  0.53,  0.42, 0.41,  0.30,  0.10, -0.46, -0.84, -1.13],\n        'MSFT': [ 0.75,  0.80,  0.71, 0.67,   0.5,  0.15,  0.09,  0.03,  0.31],\n        'GOOG': [-0.27, -0.15, -0.11, 0.12,   0.3,   0.1, -0.3,   -0.1, -0.09]};\n        \n    function normalize_ticker(ticker) {\n        switch (ticker.toLowerCase()) {\n            case \"facebook\": case \"fb\":\n                return \"FB\";\n            case \"apple\": case \"aapl\":\n                return \"AAPL\";\n            case \"microsoft\": case \"msft\":\n                return \"MSFT\";\n            case \"google\": case \"goog\":\n                return \"GOOG\";\n            default: return null;\n        }\n    }\n\n    mod.get_current = new Sk.builtin.func(function(ticker) {\n        Sk.builtin.pyCheckArgs(\"get_current\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"ticker\", \"string\", Sk.builtin.checkString(ticker));\n        ticker = normalize_ticker(ticker.v);\n        if (ticker === null) {\n            throw new Sk.builtin.ValueError(\"Stock data is only available for the following companies: Facebook, Apple, Microsoft, Google.\");\n        }\n        return Sk.ffi.remapToPy(STOCK_REPORTS[ticker][0]);\n    });\n    \n    mod.get_past = new Sk.builtin.func(function(ticker) {\n        Sk.builtin.pyCheckArgs(\"get_past\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"ticker\", \"string\", Sk.builtin.checkString(ticker));\n        ticker = normalize_ticker(ticker.v);\n        if (ticker === null) {\n            throw new Sk.builtin.ValueError(\"Stock data is only available for the following companies: Facebook, Apple, Microsoft, Google.\");\n        }\n        return Sk.ffi.remapToPy(STOCK_REPORTS[ticker]);\n    });\n\n    return mod;\n}", "src/lib/books/__init__.js": "/**\n * @fileoverview CORGIS Skulpt Book library for returning realistic, interesting data about Books.\n * @author acbart@vt.edu (Austin Cory Bart)\n */\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n    \n    var BOOKS = [\n        {'title': 'Harry Potter #1', 'author': \"J. K. Rowling\", \n        \"price\": 7.48, \"paperback\": true, \"page count\": 320},\n        {'title': 'Computational Thinking', 'author': \"Dennis Kafura\", \n        \"price\": 0.00, \"paperback\": false, \"page count\": 175},\n        {'title': 'Count of Monte Cristo', 'author': \"Alexander Dumas\", \n        \"price\": 8.75, \"paperback\": true, \"page count\": 1276},\n        {'title': 'Anatomy & Physiology', 'author': \"Michael Akins\", \n        \"price\": 90.99, \"paperback\": false, \"page count\": 680},\n        {'title': \"Ender's Game\", 'author': \"Orson Scott Card\", \n        \"price\": 5.99, \"paperback\": true, \"page count\": 251},\n        {'title': \"Chemistry 101\", 'author': \"Adam DeVoe\", \n        \"price\": 69.99, \"paperback\": false, \"page count\": 570},\n        {'title': \"1984\", 'author': \"George Orwell\", \n        \"price\": 12.25, \"paperback\": true, \"page count\": 328},\n        {'title': \"The Lord of the Rings\", 'author': \"J. R. R. Tolkien\", \n        \"price\": 11.79, \"paperback\": true, \"page count\": 1216}\n    ];\n\n    mod.get_all = new Sk.builtin.func(function(state) {\n        Sk.builtin.pyCheckArgs(\"get_all\", arguments, 0, 0);\n        return Sk.ffi.remapToPy(BOOKS);\n    });\n\n    return mod;\n};", "src/lib/numpy/__init__.js": "/**\n\tMade by Michael Ebert for https://github.com/skulpt/skulpt\n\tndarray implementation inspired by https://github.com/geometryzen/davinci-dev (not compatible with skulpt)\n\n\tSome methods are based on the original numpy implementation.\n\n\tSee http://waywaaard.github.io/skulpt/ for more information.\n**/\nvar numpy = function () {\n  if (typeof mathjs == 'function') {\n    // load mathjs instance\n    this.math = mathjs;\n  } else {\n    Sk.debugout(\"mathjs not included and callable\");\n  }\n};\n\nnumpy.prototype.wrapasfloats = function (values) {\n  var i;\n  for (i = 0; i < values.length; i++) {\n    values[i] = new Sk.builtin.nmber(values[i], Sk.builtin.nmber.float$);\n  }\n\n  return values;\n};\n\nnumpy.prototype.arange = function (start, stop, step) {\n  if (step === undefined)\n    step = 1.0;\n\n  start *= 1.0;\n  stop *= 1.0;\n  step *= 1.0;\n\n  var res = [];\n  for (var i = start; i < stop; i += step) {\n    res.push(i);\n  }\n\n  return res;\n};\n\nvar $builtinmodule = function (name) {\n  var np = new numpy();\n\n  var mod = {};\n\n  /**\n\t\tClass for numpy.ndarray\n\t**/\n  var CLASS_NDARRAY = \"numpy.ndarray\";\n\n  function remapToJs_shallow(obj, shallow) {\n    var _shallow = shallow || true;\n    if (obj instanceof Sk.builtin.list) {\n      if (!_shallow) {\n        var ret = [];\n        for (var i = 0; i < obj.v.length; ++i) {\n          ret.push(Sk.ffi.remapToJs(obj.v[i]));\n        }\n        return ret;\n      } else {\n        return obj.v;\n      }\n    } else if (obj instanceof Sk.builtin.float_) {\n      return Sk.builtin.asnum$nofloat(obj);\n    } else {\n      return Sk.ffi.remapToJs(obj);\n    }\n  }\n\n  /**\n\t\tUnpacks in any form fo nested Lists\n\t**/\n  function unpack(py_obj, buffer, state) {\n    if (py_obj instanceof Sk.builtin.list || py_obj instanceof Sk.builtin.tuple) {\n      var py_items = remapToJs_shallow(py_obj);\n      state.level += 1;\n\n      if (state.level > state.shape.length) {\n        state.shape.push(py_items.length);\n      }\n      var i;\n      var len = py_items.length;\n      for (i = 0; i < len; i++) {\n        unpack(py_items[i], buffer, state);\n      }\n      state.level -= 1;\n    } else {\n      buffer.push(py_obj);\n    }\n  }\n\n  /**\n   Computes the strides for columns and rows\n  **/\n  function computeStrides(shape) {\n    var strides = shape.slice(0);\n    strides.reverse();\n    var prod = 1;\n    var temp;\n    for (var i = 0, len = strides.length; i < len; i++) {\n      temp = strides[i];\n      strides[i] = prod;\n      prod *= temp;\n    }\n\n    return strides.reverse();\n  }\n\n  /**\n    Computes the offset for the ndarray for given index and strides\n    [1, ..., n]\n  **/\n  function computeOffset(strides, index) {\n    var offset = 0;\n    for (var k = 0, len = strides.length; k < len; k++) {\n      offset += strides[k] * index[k];\n    }\n    return offset;\n  }\n\n  /**\n    Calculates the size of the ndarray, dummy\n\t**/\n  function prod(numbers) {\n    var size = 1;\n    var i;\n    for (i = 0; i < numbers.length; i++) {\n      size *= numbers[i];\n    }\n    return size;\n  }\n\n  /**\n\t\tCreates a string representation for given buffer and shape\n\t\tbuffer is an ndarray\n\t**/\n  function stringify(buffer, shape, dtype) {\n    var emits = shape.map(function (x) {\n      return 0;\n    });\n    var uBound = shape.length - 1;\n    var idxLevel = 0;\n    var str = \"[\";\n    var i = 0;\n    while (idxLevel !== -1) {\n      if (emits[idxLevel] < shape[idxLevel]) {\n        if (emits[idxLevel] !== 0) {\n          str += \", \";\n        }\n\n        if (idxLevel < uBound) {\n          str += \"[\";\n          idxLevel += 1;\n        } else {\n          if (dtype === Sk.builtin.float_)\n            str += Sk.ffi.remapToJs(Sk.builtin.str(new Sk.builtin.float_(buffer[\n              i++])));\n          else\n            str += Sk.ffi.remapToJs(Sk.builtin.str(buffer[i++]));\n          emits[idxLevel] += 1;\n        }\n      } else {\n        emits[idxLevel] = 0;\n        str += \"]\";\n        idxLevel -= 1;\n        if (idxLevel >= 0) {\n          emits[idxLevel] += 1;\n        }\n      }\n    }\n    return str;\n  }\n\n  /*\n    http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tolist.html?highlight=tolist#numpy.ndarray.tolist\n  */\n  function tolistrecursive(buffer, shape, strides, startdim, dtype) {\n    var i, n, stride;\n    var arr, item;\n\n    /* Base case */\n    if (startdim >= shape.length) {\n      if (dtype && dtype === Sk.builtin.float_) {\n        return new Sk.builtin.float_(buffer[0]); // handle float special case\n      } else {\n        return Sk.ffi.remapToPy(buffer[0]);\n      }\n    }\n\n    n = shape[startdim];\n    stride = strides[startdim];\n\n    arr = [];\n\n    for (i = 0; i < n; i++) {\n      item = tolistrecursive(buffer, shape, strides, startdim + 1, dtype);\n      arr.push(item);\n\n      buffer = buffer.slice(stride);\n    }\n\n    return new Sk.builtin.list(arr);\n  }\n\n  /**\n\t internal tolist interface\n\t**/\n  function tolist(buffer, shape, strides, dtype) {\n    var buffer_copy = buffer.slice(0);\n    return tolistrecursive(buffer_copy, shape, strides, 0, dtype);\n  }\n\n  /**\n    Updates all attributes of the numpy.ndarray\n  **/\n  function updateAttributes(self, ndarrayJs) {\n    Sk.abstr.sattr(self, 'ndmin', new Sk.builtin.int_(ndarrayJs.shape.length));\n    Sk.abstr.sattr(self, 'dtype', ndarrayJs.dtype);\n    Sk.abstr.sattr(self, 'shape', new Sk.builtin.tuple(ndarrayJs.shape.map(\n      function (x) {\n        return new Sk.builtin.int_(x);\n      })));\n    Sk.abstr.sattr(self, 'strides', new Sk.builtin.tuple(ndarrayJs.strides.map(\n      function (x) {\n        return new Sk.builtin.int_(x);\n      })));\n    Sk.abstr.sattr(self, 'size', new Sk.builtin.int_(prod(ndarrayJs.shape)));\n    Sk.abstr.sattr(self, 'data', new Sk.ffi.remapToPy(ndarrayJs.buffer));\n  }\n\n  /**\n    An array object represents a multidimensional, homogeneous array of fixed-size items.\n    An associated data-type object describes the format of each element in the array\n    (its byte-order, how many bytes it occupies in memory, whether it is an integer, a\n    floating point number, or something else, etc.)\n\n    Arrays should be constructed using array, zeros or empty (refer to the See Also\n    section below). The parameters given here refer to a low-level method (ndarray(...)) for\n    instantiating an array.\n\n    For more information, refer to the numpy module and examine the the methods and\n    attributes of an array.\n  **/\n  var ndarray_f = function ($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function (self, shape, dtype, buffer,\n      offset, strides, order) {\n      var ndarrayJs = {}; // js object holding the actual array\n      ndarrayJs.shape = Sk.ffi.remapToJs(shape);\n\n      ndarrayJs.strides = computeStrides(ndarrayJs.shape);\n      ndarrayJs.dtype = dtype || Sk.builtin.none.none$;\n\n      if (buffer && buffer instanceof Sk.builtin.list) {\n        ndarrayJs.buffer = Sk.ffi.remapToJs(buffer);\n      }\n\n      self.v = ndarrayJs; // value holding the actual js object and array\n      self.tp$name = CLASS_NDARRAY; // set class name\n\n      updateAttributes(self, ndarrayJs);\n    });\n\n    $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n    // ToDo: setAttribute should be implemented, change of shape causes resize\n    // ndmin cannot be set, etc...\n    $loc.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\n\n    /*\n      Return the array as a (possibly nested) list.\n\n      Return a copy of the array data as a (nested) Python list. Data items are\n      converted to the nearest compatible Python type.\n    */\n    $loc.tolist = new Sk.builtin.func(function (self) {\n      var ndarrayJs = Sk.ffi.remapToJs(self);\n      var list = tolist(ndarrayJs.buffer, ndarrayJs.shape, ndarrayJs.strides,\n        ndarrayJs.dtype);\n\n      return list;\n    });\n\n    $loc.reshape = new Sk.builtin.func(function (self, shape, order) {\n      Sk.builtin.pyCheckArgs(\"reshape\", arguments, 2, 3);\n      var ndarrayJs = Sk.ffi.remapToJs(self);\n      return Sk.misceval.callsim(mod[CLASS_NDARRAY], shape, ndarrayJs.dtype,\n        new Sk.builtin.list(ndarrayJs.buffer));\n    });\n\n    $loc.copy = new Sk.builtin.func(function (self, order) {\n      Sk.builtin.pyCheckArgs(\"copy\", arguments, 1, 2);\n      var ndarrayJs = Sk.ffi.remapToJs(self);\n      var buffer = ndarrayJs.buffer.map(function (x) {\n        return x;\n      });\n      var shape = new Sk.builtin.tuplePy(ndarrayJs.shape.map(function (x) {\n        return new Sk.builtin.int_(x);\n      }));\n      return Sk.misceval.callsim(mod[CLASS_NDARRAY], shape, ndarrayJs.dtype,\n        new Sk.builtin.list(buffer));\n    });\n\n    /**\n      Fill the array with a scalar value.\n      Parameters: value: scalar\n                    All elements of a will be assigned this value\n    **/\n    $loc.fill = new Sk.builtin.func(function (self, value) {\n      Sk.builtin.pyCheckArgs(\"fill\", arguments, 2, 2);\n      var ndarrayJs = Sk.ffi.remapToJs(self);\n      var buffer = ndarrayJs.buffer.map(function (x) {\n        return x;\n      });\n      var i;\n      for (i = 0; i < ndarrayJs.buffer.length; i++) {\n        if (ndarrayJs.dtype) {\n          ndarrayJs.buffer[i] = Sk.misceval.callsim(ndarrayJs.dtype,\n            value);\n        }\n      }\n    });\n\n    $loc.__getitem__ = new Sk.builtin.func(function (self, index) {\n      Sk.builtin.pyCheckArgs(\"[]\", arguments, 2, 2);\n      var ndarrayJs = Sk.ffi.remapToJs(self);\n      var _index; // current index\n      var _buffer; // buffer as python type\n      var buffer_internal; // buffer als js array\n      var _stride; // stride\n      var _shape; // shape as js\n      var i;\n\n      // single index e.g. [3]\n      if (Sk.builtin.checkInt(index)) {\n        var offset = Sk.ffi.remapToJs(index);\n\n        if (ndarrayJs.shape.length > 1) {\n          _stride = ndarrayJs.strides[0];\n          buffer_internal = [];\n          _index = 0;\n\n          for (i = offset * _stride, ubound = (offset + 1) * _stride; i <\n            ubound; i++) {\n            buffer_internal[_index++] = ndarrayJs.buffer[i];\n          }\n\n          _buffer = new Sk.builtin.list(buffer_internal);\n          _shape = new Sk.builtin.tuple(Array.prototype.slice.call(\n              ndarrayJs.shape,\n              1)\n            .map(function (x) {\n              return new Sk.builtin.int_(x);\n            }));\n          return Sk.misceval.callsim(mod[CLASS_NDARRAY], _shape,\n            undefined,\n            _buffer);\n        } else {\n          if (offset >= 0 && offset < ndarrayJs.buffer.length) {\n            return ndarrayJs.buffer[offset];\n          } else {\n            throw new Sk.builtin.IndexError(\"array index out of range\");\n          }\n        }\n      } else if (index instanceof Sk.builtin.tuple) {\n        // index like [1,3]\n        var keyJs = Sk.ffi.remapToJs(index);\n        return ndarrayJs.buffer[computeOffset(ndarrayJs.strides, keyJs)];\n      } else if (index instanceof Sk.builtin.slice) {\n        // support for slices e.g. [1:4]\n        var indices = index.indices();\n        var start = typeof indices[0] !== 'undefined' ? indices[0] : 0;\n        var stop = typeof indices[1] !== 'undefined' ? indices[1] :\n          ndarrayJs\n          .buffer.length;\n        stop = stop > ndarrayJs.buffer.length ? ndarrayJs.buffer.length :\n          stop;\n        var step = typeof indices[2] !== 'undefined' ? indices[2] : 1;\n        buffer_internal = [];\n        _index = 0;\n        if (step > 0) {\n          for (i = start; i < stop; i += step) {\n            buffer_internal[_index++] = ndarrayJs.buffer[i];\n          }\n        }\n        _buffer = new Sk.builtin.list(buffer_internal);\n        _shape = new Sk.builtin.tuple([buffer_internal.length].map(\n          function (\n            x) {\n            return new Sk.builtin.int_(x);\n          }));\n        return Sk.misceval.callsim(mod[CLASS_NDARRAY], _shape, undefined,\n          _buffer);\n      } else {\n        throw new Sk.builtin.ValueError('Index \"' + index +\n          '\" must be int, slice or tuple');\n      }\n    });\n\n    $loc.__setitem__ = new Sk.builtin.func(function (self, index, value) {\n      var ndarrayJs = Sk.ffi.remapToJs(self);\n      Sk.builtin.pyCheckArgs(\"[]\", arguments, 3, 3);\n      if (index instanceof Sk.builtin.int_) {\n        var _offset = Sk.ffi.remapToJs(index);\n        if (ndarrayJs.shape.length > 1) {\n          var _value = Sk.ffi.remapToJs(value);\n          var _stride = ndarrayJs.strides[0];\n          var _index = 0;\n\n          var _ubound = (_offset + 1) * _stride;\n          var i;\n          for (i = _offset * _stride; i < _ubound; i++) {\n            ndarrayJs.buffer[i] = _value.buffer[_index++];\n          }\n        } else {\n          if (_offset >= 0 && _offset < ndarrayJs.buffer.length) {\n            ndarrayJs.buffer[_offset] = value;\n          } else {\n            throw new Sk.builtin.IndexError(\"array index out of range\");\n          }\n        }\n      } else if (index instanceof Sk.builtin.tuple) {\n        _key = Sk.ffi.remapToJs(index);\n        ndarrayJs.buffer[computeOffset(ndarrayJs.strides, _key)] = value;\n      } else {\n        throw new Sk.builtin.TypeError(\n          'argument \"index\" must be int or tuple');\n      }\n    });\n\n    $loc.__len__ = new Sk.builtin.func(function (self) {\n      var ndarrayJs = Sk.ffi.remapToJs(self);\n      return new Sk.builtin.int_(ndarrayJs.shape[0]);\n    });\n\n    $loc.__iter__ = new Sk.builtin.func(function (self) {\n      var ndarrayJs = Sk.ffi.remapToJs(self);\n      var ret = {\n        tp$iter: function () {\n          return ret;\n        },\n        $obj: ndarrayJs,\n        $index: 0,\n        tp$iternext: function () {\n          if (ret.$index >= ret.$obj.buffer.length) return undefined;\n          return ret.$obj.buffer[ret.$index++];\n        }\n      };\n      return ret;\n    });\n\n    $loc.__str__ = new Sk.builtin.func(function (self) {\n      var ndarrayJs = remapToJs_shallow(self, false);\n      return new Sk.builtin.str(stringify(ndarrayJs.buffer,\n        ndarrayJs.shape, ndarrayJs.dtype));\n    });\n\n    $loc.__repr__ = new Sk.builtin.func(function (self) {\n      var ndarrayJs = Sk.ffi.remapToJs(self);\n      return new Sk.builtin.str(\"array(\" + stringify(ndarrayJs.buffer,\n        ndarrayJs.shape, ndarrayJs.dtype) + \")\");\n    });\n\n    /**\n      Creates left hand side operations for given binary operator\n    **/\n    function makeNumericBinaryOpLhs(operation) {\n      return function (self, other) {\n        var lhs;\n        var rhs;\n        var buffer; // external\n        var _buffer; // internal use\n        var shape; // new shape of returned ndarray\n        var i;\n\n\n        var ndarrayJs = Sk.ffi.remapToJs(self);\n\n        if (Sk.abstr.typeName(other) === CLASS_NDARRAY) {\n          lhs = ndarrayJs.buffer;\n          rhs = Sk.ffi.remapToJs(other)\n            .buffer;\n          _buffer = [];\n          for (i = 0, len = lhs.length; i < len; i++) {\n            //_buffer[i] = operation(lhs[i], rhs[i]);\n            _buffer[i] = Sk.abstr.binary_op_(lhs[i], rhs[i], operation);\n          }\n        } else {\n          lhs = ndarrayJs.buffer;\n          _buffer = [];\n          for (i = 0, len = lhs.length; i < len; i++) {\n            _buffer[i] = Sk.abstr.numberBinOp(lhs[i], other, operation);\n          }\n        }\n\n        // create return ndarray\n        shape = new Sk.builtin.tuple(ndarrayJs.shape.map(function (x) {\n          return new Sk.builtin.int_(x);\n        }));\n        buffer = new Sk.builtin.list(_buffer);\n        return Sk.misceval.callsim(mod[CLASS_NDARRAY], shape, undefined,\n          buffer);\n      };\n    }\n\n    function makeNumericBinaryOpRhs(operation) {\n      return function (self, other) {\n        var ndarrayJs = Sk.ffi.remapToJs(self);\n        var rhsBuffer = ndarrayJs.buffer;\n        var _buffer = [];\n        for (var i = 0, len = rhsBuffer.length; i < len; i++) {\n          _buffer[i] = Sk.abstr.numberBinOp(other, rhsBuffer[i], operation);\n        }\n        var shape = new Sk.builtin.tuple(ndarrayJs.shape.map(function (x) {\n          return new Sk.builtin.int_(x);\n        }));\n        buffer = new Sk.builtin.list(_buffer);\n        return Sk.misceval.callsim(mod[CLASS_NDARRAY], shape, undefined, buffer);\n      };\n    }\n\n    /*\n      Applies given operation on each element of the ndarray.\n    */\n    function makeUnaryOp(operation) {\n      return function (self) {\n        var ndarrayJs = Sk.ffi.remapToJs(self);\n        var _buffer = ndarrayJs.buffer.map(function (value) {\n          return Sk.abstr.numberUnaryOp(Sk.ffi.remapToPy(value), operation);\n        });\n        var shape = new Sk.builtin.tuple(ndarrayJs.shape.map(function (x) {\n          return new Sk.builtin.int_(x);\n        }));\n        buffer = new Sk.builtin.list(_buffer);\n        return Sk.misceval.callsim(mod[CLASS_NDARRAY], shape, undefined, buffer);\n      };\n    }\n\n    $loc.__add__ = new Sk.builtin.func(makeNumericBinaryOpLhs(\"Add\"));\n    $loc.__radd__ = new Sk.builtin.func(makeNumericBinaryOpRhs(\"Add\"));\n\n    $loc.__sub__ = new Sk.builtin.func(makeNumericBinaryOpLhs(\"Sub\"));\n    $loc.__rsub__ = new Sk.builtin.func(makeNumericBinaryOpRhs(\"Sub\"));\n\n    $loc.__mul__ = new Sk.builtin.func(makeNumericBinaryOpLhs(\"Mult\"));\n    $loc.__rmul__ = new Sk.builtin.func(makeNumericBinaryOpRhs(\"Mult\"));\n\n    $loc.__div__ = new Sk.builtin.func(makeNumericBinaryOpLhs(\"Div\"));\n    $loc.__rdiv__ = new Sk.builtin.func(makeNumericBinaryOpRhs(\"Div\"));\n\n    $loc.__mod__ = new Sk.builtin.func(makeNumericBinaryOpLhs(\"Mod\"));\n    $loc.__rmod__ = new Sk.builtin.func(makeNumericBinaryOpRhs(\"Mod\"));\n\n    $loc.__xor__ = new Sk.builtin.func(makeNumericBinaryOpLhs(\"BitXor\"));\n    $loc.__rxor__ = new Sk.builtin.func(makeNumericBinaryOpRhs(\"BitXor\"));\n\n    $loc.__lshift__ = new Sk.builtin.func(makeNumericBinaryOpLhs(\"LShift\"));\n    $loc.__rlshift__ = new Sk.builtin.func(makeNumericBinaryOpRhs(\"LShift\"));\n\n    $loc.__rshift__ = new Sk.builtin.func(makeNumericBinaryOpLhs(\"RShift\"));\n    $loc.__rrshift__ = new Sk.builtin.func(makeNumericBinaryOpRhs(\"RShift\"));\n\n    $loc.__pos__ = new Sk.builtin.func(makeUnaryOp(\"UAdd\"));\n    $loc.__neg__ = new Sk.builtin.func(makeUnaryOp(\"USub\"));\n\n    /**\n     Simple pow implementation that faciliates the pow builtin\n    **/\n    $loc.__pow__ = new Sk.builtin.func(function (self, other) {\n      Sk.builtin.pyCheckArgs(\"__pow__\", arguments, 2, 2);\n      var ndarrayJs = Sk.ffi.remapToJs(self);\n      var _buffer = ndarrayJs.buffer.map(function (value) {\n        return Sk.builtin.pow(Sk.ffi.remapToPy(value), other);\n      });\n      var shape = new Sk.builtin.tuple(ndarrayJs.shape.map(function (x) {\n        return new Sk.builtin.int_(x);\n      }));\n      buffer = new Sk.builtin.list(_buffer);\n      return Sk.misceval.callsim(mod[CLASS_NDARRAY], shape, undefined, buffer);\n    });\n\n    // end of ndarray_f\n  };\n\n  mod[CLASS_NDARRAY] = Sk.misceval.buildClass(mod, ndarray_f,\n    CLASS_NDARRAY, []);\n\n  /**\n   Trigonometric functions, all element wise\n  **/\n  mod.pi = Sk.builtin.assk$(np.math ? np.math.PI : Math.PI, Sk.builtin.nmber.float$);\n  mod.e = Sk.builtin.assk$(np.math ? np.math.E : Math.E, Sk.builtin.nmber.float$);\n  /**\n  Trigonometric sine, element-wise.\n  **/\n\n  function callTrigonometricFunc(x, op) {\n    var res;\n    var num;\n    if (x instanceof Sk.builtin.list || x instanceof Sk.builtin.tuple) {\n      x = Sk.misceval.callsim(mod.array, x);\n    }\n\n    if (Sk.abstr.typeName(x) === CLASS_NDARRAY) {\n      var ndarrayJs = Sk.ffi.remapToJs(x);\n\n      var _buffer = ndarrayJs.buffer.map(function (value) {\n        num = Sk.builtin.asnum$(value);\n        res = op.call(null, num);\n        return new Sk.builtin.nmber(res, Sk.builtin.nmber\n          .float$);\n      });\n\n      var shape = new Sk.builtin.tuple(ndarrayJs.shape.map(function (x) {\n        return new Sk.builtin.int_(x);\n      }));\n\n      buffer = new Sk.builtin.list(_buffer);\n      return Sk.misceval.callsim(mod[CLASS_NDARRAY], shape, undefined, buffer);\n    } else if (Sk.builtin.checkNumber(x)) {\n      num = Sk.builtin.asnum$(x);\n      res = op.call(null, num);\n      return new Sk.builtin.nmber(res, Sk.builtin.nmber\n        .float$);\n    }\n\n    throw new Sk.builtin.TypeError('Unsupported argument type for \"x\"');\n  }\n\n  // Sine, element-wise.\n  var sin_f = function (x, out) {\n    Sk.builtin.pyCheckArgs(\"sin\", arguments, 1, 2);\n    return callTrigonometricFunc(x, np.math ? np.math.sin : Math.sin);\n  };\n  sin_f.co_varnames = ['x', 'out'];\n  sin_f.$defaults = [0, new Sk.builtin.list([])];\n  mod.sin = new Sk.builtin.func(sin_f);\n\n  // Hyperbolic sine, element-wise.\n  var sinh_f = function (x, out) {\n    Sk.builtin.pyCheckArgs(\"sinh\", arguments, 1, 2);\n    if (!np.math) throw new Sk.builtin.OperationError(\"sinh requires mathjs\");\n    return callTrigonometricFunc(x, np.math.sinh);\n  };\n  sinh_f.co_varnames = ['x', 'out'];\n  sinh_f.$defaults = [0, new Sk.builtin.list([])];\n  mod.sinh = new Sk.builtin.func(sinh_f);\n\n  // Inverse sine, element-wise.\n  var arcsin_f = function (x, out) {\n    Sk.builtin.pyCheckArgs(\"arcsin\", arguments, 1, 2);\n    return callTrigonometricFunc(x, np.math ? np.math.asin : Math.asin);\n  };\n  arcsin_f.co_varnames = ['x', 'out'];\n  arcsin_f.$defaults = [0, new Sk.builtin.list([])];\n  mod.arcsin = new Sk.builtin.func(arcsin_f);\n\n  // Cosine, element-wise.\n  var cos_f = function (x, out) {\n    Sk.builtin.pyCheckArgs(\"cos\", arguments, 1, 2);\n    return callTrigonometricFunc(x, np.math ? np.math.cos : Math.cos);\n  };\n  cos_f.co_varnames = ['x', 'out'];\n  cos_f.$defaults = [0, new Sk.builtin.list([])];\n  mod.cos = new Sk.builtin.func(cos_f);\n\n  // Hyperbolic cosine, element-wise.\n  var cosh_f = function (x, out) {\n    Sk.builtin.pyCheckArgs(\"cosh\", arguments, 1, 2);\n    if (!np.math) throw new Sk.builtin.OperationError(\"cosh requires mathjs\");\n    return callTrigonometricFunc(x, np.math.cosh);\n  };\n  cosh_f.co_varnames = ['x', 'out'];\n  cosh_f.$defaults = [0, new Sk.builtin.list([])];\n  mod.cosh = new Sk.builtin.func(cosh_f);\n\n  // Inverse cosine, element-wise.\n  var arccos_f = function (x, out) {\n    Sk.builtin.pyCheckArgs(\"arccos\", arguments, 1, 2);\n    return callTrigonometricFunc(x, np.math ? np.math.acos : Math.acos);\n  };\n  arccos_f.co_varnames = ['x', 'out'];\n  arccos_f.$defaults = [0, new Sk.builtin.list([])];\n  mod.arccos = new Sk.builtin.func(arccos_f);\n\n  // Inverse tangens, element-wise.\n  var arctan_f = function (x, out) {\n    Sk.builtin.pyCheckArgs(\"arctan\", arguments, 1, 2);\n    return callTrigonometricFunc(x, np.math ? np.math.atan : Math.atan);\n  };\n  arctan_f.co_varnames = ['x', 'out'];\n  arctan_f.$defaults = [0, new Sk.builtin.list([])];\n  mod.arctan = new Sk.builtin.func(arctan_f);\n\n  // Tangens, element-wise.\n  var tan_f = function (x, out) {\n    Sk.builtin.pyCheckArgs(\"tan\", arguments, 1, 2);\n    return callTrigonometricFunc(x, np.math ? np.math.tan : Math.tan);\n  };\n  tan_f.co_varnames = ['x', 'out'];\n  tan_f.$defaults = [0, new Sk.builtin.list([])];\n  mod.tan = new Sk.builtin.func(tan_f);\n\n  // Hyperbolic cosine, element-wise.\n  var tanh_f = function (x, out) {\n    Sk.builtin.pyCheckArgs(\"tanh\", arguments, 1, 2);\n    if (!np.math) throw new Sk.builtin.OperationError(\"tanh requires mathjs\");\n    return callTrigonometricFunc(x, np.math.tanh);\n  };\n  tanh_f.co_varnames = ['x', 'out'];\n  tanh_f.$defaults = [0, new Sk.builtin.list([])];\n  mod.tanh = new Sk.builtin.func(tanh_f);\n\n  /* Simple reimplementation of the linspace function\n   * http://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html\n   */\n  var linspace_f = function (start, stop, num, endpoint, retstep) {\n    Sk.builtin.pyCheckArgs(\"linspace\", arguments, 3, 5);\n    Sk.builtin.pyCheckType(\"start\", \"number\", Sk.builtin.checkNumber(\n      start));\n    Sk.builtin.pyCheckType(\"stop\", \"number\", Sk.builtin.checkNumber(\n      stop));\n    if (num === undefined) {\n      num = 50;\n    }\n    var num_num = Sk.builtin.asnum$(num);\n    var endpoint_bool;\n\n    if (endpoint === undefined) {\n      endpoint_bool = true;\n    } else if (endpoint.constructor === Sk.builtin.bool) {\n      endpoint_bool = endpoint.v;\n    }\n\n    var retstep_bool;\n    if (retstep === undefined) {\n      retstep_bool = false;\n    } else if (retstep.constructor === Sk.builtin.bool) {\n      retstep_bool = retstep.v;\n    }\n\n    var samples;\n    var step;\n\n    start_num = Sk.builtin.asnum$(start) * 1.0;\n    stop_num = Sk.builtin.asnum$(stop) * 1.0;\n\n    if (num_num <= 0) {\n      samples = [];\n    } else {\n\n      var samples_array;\n      if (endpoint_bool) {\n        if (num_num == 1) {\n          samples = [start_num];\n        } else {\n          step = (stop_num - start_num) / (num_num - 1);\n          samples_array = np.arange(0, num_num);\n          samples = samples_array.map(function (v) {\n            return v * step + start_num;\n          });\n          samples[samples.length - 1] = stop_num;\n        }\n      } else {\n        step = (stop_num - start_num) / num_num;\n        samples_array = np.arange(0, num_num);\n        samples = samples_array.map(function (v) {\n          return v * step + start_num;\n        });\n      }\n    }\n\n    //return as ndarray! dtype:float\n    var dtype = Sk.builtin.float_;\n    for (i = 0; i < samples.length; i++) {\n      samples[i] = Sk.misceval.callsim(dtype, samples[i]);\n    }\n\n    var buffer = Sk.builtin.list(samples);\n    var shape = new Sk.builtin.tuple([samples.length]);\n    var ndarray = Sk.misceval.callsim(mod[CLASS_NDARRAY], shape, dtype,\n      buffer);\n\n    if (retstep_bool === true)\n      return new Sk.builtin.tuple([ndarray, step]);\n    else\n      return ndarray;\n  };\n\n  // this should allow for named parameters\n  linspace_f.co_varnames = ['start', 'stop', 'num', 'endpoint',\n    'retstep'\n  ];\n  linspace_f.$defaults = [0, 0, 50, true, false];\n  mod.linspace =\n    new Sk.builtin.func(linspace_f);\n\n  /* Simple reimplementation of the arange function\n   * http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html#numpy.arange\n   */\n  var arange_f = function (start, stop, step, dtype) {\n    Sk.builtin.pyCheckArgs(\"arange\", arguments, 1, 4);\n    Sk.builtin.pyCheckType(\"start\", \"number\", Sk.builtin.checkNumber(\n      start));\n    var start_num;\n    var stop_num;\n    var step_num;\n\n    if (stop === undefined && step === undefined) {\n      start_num = Sk.builtin.asnum$(0);\n      stop_num = Sk.builtin.asnum$(start);\n      step_num = Sk.builtin.asnum$(1);\n    } else if (step === undefined) {\n      start_num = Sk.builtin.asnum$(start);\n      stop_num = Sk.builtin.asnum$(stop);\n      step_num = Sk.builtin.asnum$(1);\n    } else {\n      start_num = Sk.builtin.asnum$(start);\n      stop_num = Sk.builtin.asnum$(stop);\n      step_num = Sk.builtin.asnum$(step);\n    }\n\n    // set to float\n    if (!dtype || dtype == Sk.builtin.none.none$) {\n      if (Sk.builtin.checkInt(start))\n        dtype = Sk.builtin.int_;\n      else\n        dtype = Sk.builtin.float_;\n    }\n\n    // return ndarray\n    var arange_buffer = np.arange(start_num, stop_num, step_num);\n    // apply dtype casting function, if it has been provided\n    if (dtype && Sk.builtin.checkClass(dtype)) {\n      for (i = 0; i < arange_buffer.length; i++) {\n        arange_buffer[i] = Sk.misceval.callsim(dtype, arange_buffer[i]);\n      }\n    }\n\n    buffer = Sk.builtin.list(arange_buffer);\n    var shape = new Sk.builtin.tuple([arange_buffer.length]);\n    return Sk.misceval.callsim(mod[CLASS_NDARRAY], shape, dtype,\n      buffer);\n  };\n\n  arange_f.co_varnames = ['start', 'stop', 'step', 'dtype'];\n  arange_f\n    .$defaults = [0, 1, 1, Sk.builtin.none.none$];\n  mod.arange = new Sk.builtin\n    .func(arange_f);\n\n  /* implementation for numpy.array\n\t------------------------------------------------------------------------------------------------\n\t\thttp://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html#numpy.array\n\n\t\tobject : array_like\n\t\tAn array, any object exposing the array interface, an object whose __array__ method returns an array, or any (nested) sequence.\n\n\t\tdtype : data-type, optional\n\t\tThe desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence. This argument can only be used to \u2018upcast\u2019 the array. For downcasting, use the .astype(t) method.\n\n\t\tcopy : bool, optional\n\t\tIf true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (dtype, order, etc.).\n\n\t\torder : {\u2018C\u2019, \u2018F\u2019, \u2018A\u2019}, optional\n\t\tSpecify the order of the array. If order is \u2018C\u2019 (default), then the array will be in C-contiguous order (last-index varies the fastest). If order is \u2018F\u2019, then the returned array will be in Fortran-contiguous order (first-index varies the fastest). If order is \u2018A\u2019, then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous).\n\n\t\tsubok : bool, optional\n\t\tIf True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).\n\n\t\tndmin : int, optional\n\t\tSpecifies the minimum number of dimensions that the resulting array should have. Ones will be pre-pended to the shape as needed to meet this requirement.\n\n\t\tReturns :\n\t\tout : ndarray\n\t\tAn array object satisfying the specified requirements\n\t*/\n  // https://github.com/geometryzen/davinci-dev/blob/master/src/stdlib/numpy.js\n  // https://github.com/geometryzen/davinci-dev/blob/master/src/ffh.js\n  // http://docs.scipy.org/doc/numpy/reference/arrays.html\n  var array_f = function (object, dtype, copy, order, subok, ndmin) {\n    Sk.builtin.pyCheckArgs(\"array\", arguments, 1, 6);\n\n    if (object === undefined)\n      throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(object) +\n        \"' object is undefined\");\n\n    var elements = [];\n    var state = {};\n    state.level = 0;\n    state.shape = [];\n\n    unpack(object, elements, state);\n\n    var i;\n    // apply dtype casting function, if it has been provided\n    if (dtype && Sk.builtin.checkClass(dtype)) {\n      for (i = 0; i < elements.length; i++) {\n        elements[i] = Sk.misceval.callsim(dtype, elements[i]);\n      }\n    } else {\n      // check elements and find first usable type\n      // should be refactored\n      for (i = 0; i < elements.length; i++) {\n        if (elements[i] && isNaN(elements[i])) {\n          dtype = Sk.builtin.float_;\n          break;\n        } else if (typeof elements[i] == 'string') {\n          dtype = Sk.builtin.str;\n        } else {\n          dtype = Sk.builtin.float_;\n        }\n      }\n    }\n\n    // check for ndmin param\n    if (ndmin) {\n      if (Sk.builtin.checkNumber(ndmin)) {\n        var _ndmin = Sk.builtin.asnum$(ndmin);\n        if (_ndmin >= 0 && _ndmin > state.shape.length) {\n          var _ndmin_array = [];\n          for (i = 0; i < _ndmin - state.shape.length; i++) {\n            _ndmin_array.push(1);\n          }\n          state.shape = _ndmin_array.concat(state.shape);\n        }\n      } else {\n        throw new Sk.builtin.TypeError(\n          'Parameter \"ndmin\" must be of type \"int\"');\n      }\n    }\n\n    var _shape = new Sk.builtin.tuple(state.shape.map(function (x) {\n      return new Sk.builtin.int_(x);\n    }));\n\n    var _buffer = new Sk.builtin.list(elements);\n    // create new ndarray instance\n    return Sk.misceval.callsim(mod[CLASS_NDARRAY], _shape, dtype,\n      _buffer);\n  };\n\n  array_f.co_varnames = ['object', 'dtype', 'copy', 'order',\n    'subok', 'ndmin'\n  ];\n  array_f.$defaults = [null, Sk.builtin.none.none$, true, new Sk.builtin.str(\n    'C'), false, new Sk.builtin.int_(0)];\n  mod.array = new Sk.builtin.func(array_f);\n\n  /**\n    Return a new array of given shape and type, filled with zeros.\n  **/\n  var zeros_f = function (shape, dtype, order) {\n    Sk.builtin.pyCheckArgs(\"zeros\", arguments, 1, 3);\n    Sk.builtin.pyCheckType(\"shape\", \"tuple\", shape instanceof Sk.builtin.tuple);\n    if (dtype instanceof Sk.builtin.list) {\n      throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(dtype) +\n        \"' is not supported for dtype.\");\n    }\n\n    var _zero = new Sk.builtin.float_(0.0);\n\n    return Sk.misceval.callsim(mod.full, shape, _zero, dtype, order);\n  };\n  zeros_f.co_varnames = ['shape', 'dtype', 'order'];\n  zeros_f.$defaults = [\n    new Sk.builtin.tuple([]), Sk.builtin.none.none$, new Sk.builtin.str('C')\n  ];\n  mod.zeros = new Sk.builtin.func(zeros_f);\n\n  /**\n    Return a new array of given shape and type, filled with `fill_value`.\n  **/\n  var full_f = function (shape, fill_value, dtype, order) {\n    Sk.builtin.pyCheckArgs(\"full\", arguments, 2, 4);\n    Sk.builtin.pyCheckType(\"shape\", \"tuple\", shape instanceof Sk.builtin.tuple);\n    if (dtype instanceof Sk.builtin.list) {\n      throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(dtype) +\n        \"' is currently not supported for dtype.\");\n    }\n\n    // generate an array of the dimensions for the generic array method\n    var _shape = Sk.ffi.remapToJs(shape);\n    var _size = prod(_shape);\n    var _buffer = [];\n    var _fill_value = fill_value;\n    var i;\n\n    for (i = 0; i < _size; i++) {\n      _buffer[i] = _fill_value;\n    }\n\n    // if no dtype given and type of fill_value is numeric, assume float\n    if (!dtype && Sk.builtin.checkNumber(fill_value)) {\n      dtype = Sk.builtin.float_;\n    }\n\n    // apply dtype casting function, if it has been provided\n    if (Sk.builtin.checkClass(dtype)) {\n      for (i = 0; i < _buffer.length; i++) {\n        _buffer[i] = Sk.misceval.callsim(dtype, _buffer[i]);\n      }\n    }\n\n    return Sk.misceval.callsim(mod[CLASS_NDARRAY], shape, dtype, new Sk.builtin\n      .list(\n        _buffer));\n  };\n  full_f.co_varnames = ['shape', 'fill_value', 'dtype', 'order'];\n  full_f.$defaults = [\n    new Sk.builtin.tuple([]), Sk.builtin.none.none$, Sk.builtin.none.none$, new Sk\n    .builtin\n    .str('C')\n  ];\n  mod.full = new Sk.builtin.func(full_f);\n\n\n  /**\n    Return a new array of given shape and type, filled with ones.\n  **/\n  var ones_f = function (shape, dtype, order) {\n    Sk.builtin.pyCheckArgs(\"ones\", arguments, 1, 3);\n    Sk.builtin.pyCheckType(\"shape\", \"tuple\", shape instanceof Sk.builtin.tuple);\n    if (dtype instanceof Sk.builtin.list) {\n      throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(dtype) +\n        \"' is not supported for dtype.\");\n    }\n\n    var _one = new Sk.builtin.float_(1.0);\n    return Sk.misceval.callsim(mod.full, shape, _one, dtype, order);\n  };\n  ones_f.co_varnames = ['shape', 'dtype', 'order'];\n  ones_f.$defaults = [\n    new Sk.builtin.tuple([]), Sk.builtin.none.none$, new Sk.builtin.str('C')\n  ];\n  mod.ones = new Sk.builtin.func(ones_f);\n\n\n  /**\n    Dot product\n  **/\n  var dot_f = function (a, b) {\n    Sk.builtin.pyCheckArgs(\"dot\", arguments, 2, 2);\n\n    // ToDo: add support for ndarray args\n\n    if (!(a instanceof Sk.builtin.list) && !Sk.builtin.checkNumber(\n      a) && (Sk.abstr.typeName(a) !== CLASS_NDARRAY)) {\n      throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(a) +\n        \"' is not supported for a.\");\n    }\n\n    if (!(b instanceof Sk.builtin.list) && !Sk.builtin.checkNumber(\n      b) && (Sk.abstr.typeName(b) !== CLASS_NDARRAY)) {\n      throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(b) +\n        \"' is not supported for b.\");\n    }\n\n    var res;\n\n    var b_matrix;\n    var a_matrix;\n\n    if (Sk.abstr.typeName(a) === CLASS_NDARRAY) {\n      a_matrix = a.v.buffer;\n\t\t\ta_matrix = a_matrix.map(function (x) {\n\t\t\t\treturn Sk.ffi.remapToJs(x);\n\t\t\t});\n    } else {\n      a_matrix = Sk.ffi.remapToJs(a);\n    }\n\n    if (Sk.abstr.typeName(b) === CLASS_NDARRAY) {\n      b_matrix = b.v.buffer;\n\t\t\tb_matrix = b_matrix.map(function (x) {\n\t\t\t\treturn Sk.ffi.remapToJs(x);\n\t\t\t});\n    } else {\n      b_matrix = Sk.ffi.remapToJs(b);\n    }\n\n    var a_size = np.math.size(a_matrix);\n    var b_size = np.math.size(b_matrix);\n\n\n    if (a_size.length >= 1 && b_size.length > 1) {\n      if (a_size[a_size.length - 1] != b_size[b_size - 2]) {\n        throw new Sk.builtin.ValueError(\n          \"The last dimension of a is not the same size as the second-to-last dimension of b.\"\n        );\n      }\n    }\n\n    res = np.math.multiply(a_matrix, b_matrix);\n\t\t\n\t\tif (!Array.isArray(res)) { // if result\n\t\t\treturn Sk.ffi.remapToPy(res);\n\t\t}\n\t\t\n    // return ndarray\n    buffer = new Sk.builtin.list(res);\n    return Sk.misceval.callsim(mod.array, buffer, Sk.builtin.float_);\n  };\n  dot_f.co_varnames = ['a', 'b'];\n  dot_f.$defaults = [Sk.builtin.none.none$,\n    Sk.builtin.none.none$\n  ];\n  mod.dot = new Sk.builtin.func(dot_f);\n\n  /* not implemented methods */\n  mod.ones_like = new Sk.builtin.func(function () {\n    throw new Sk.builtin.NotImplementedError(\n      \"ones_like is not yet implemented\");\n  });\n  mod.empty_like = new Sk.builtin.func(function () {\n    throw new Sk.builtin.NotImplementedError(\n      \"empty_like is not yet implemented\");\n  });\n  mod.ones_like = new Sk.builtin.func(function () {\n    throw new Sk.builtin.NotImplementedError(\n      \"ones_like is not yet implemented\");\n  });\n  mod.empty = new Sk.builtin.func(function () {\n    throw new Sk.builtin.NotImplementedError(\n      \"empty is not yet implemented\");\n  });\n  mod.arctan2 = new Sk.builtin.func(function () {\n    throw new Sk.builtin.NotImplementedError(\n      \"arctan2 is not yet implemented\");\n  });\n  mod.asarray = new Sk.builtin.func(array_f);\n  return mod;\n};\n", "src/lib/image/__init__.js": "var $builtinmodule = function(name) {\n  var mod, Canvas2Image, importAllSubmodules, DrawUtils, mediaPath;\n\n  mod = {};\n\n  DrawUtils = {\n    drawInto : function(picture, callback) {\n      var canvas, ctx;\n\n      canvas = document.createElement('canvas');\n      canvas.width = picture._width;\n      canvas.height = picture._height;\n      ctx = canvas.getContext('2d');\n      ctx.putImageData(picture._imageData, 0, 0);\n      \n      callback(ctx, canvas);\n\n      picture._imageData = ctx.getImageData(0, 0, picture._width, picture._height);\n    },\n  }\n\n  // The Canvas2Image library is used to convert a canvas into an image that\n  // can be saved to the media library. Credit for the original goes to\n  // https://github.com/hongru/canvas2image.\n  Canvas2Image = {\n    $support : (function () {\n      var canvas, ctx;\n\n      canvas = document.createElement('canvas');\n      ctx = canvas.getContext('2d');\n\n      return {\n        canvas: !!ctx,\n        imageData: !!ctx.getImageData,\n        dataURL: !!canvas.toDataURL,\n        btoa: !!window.btoa\n      };\n    }()),\n\n    _scaleCanvas : function (canvas, width, height) {\n      var w, h, retCanvas, retCtx;\n\n      w = canvas.width;\n      h = canvas.height;\n\n      if (!width) { width = w; }\n      if (!height) { height = h; }\n\n      retCanvas = document.createElement('canvas');\n      retCanvas.width = width;\n      retCanvas.height = height;\n\n      retCtx = retCanvas.getContext('2d');\n      retCtx.drawImage(canvas, 0, 0, w, h, 0, 0, width, height);\n\n      return retCanvas;\n    },\n\n    _getDataURL : function (canvas, type, width, height) {\n      return this._scaleCanvas(canvas, width, height).toDataURL(type);\n    },\n\n    _fixType : function (type) {\n      var r;\n\n      type = type.toLowerCase().replace(/jpg/i, 'jpeg');\n      r = type.match(/png|jpeg|bmp|gif/)[0];\n\n      return 'image/' + r;\n    },\n\n    _encodeData : function (data) {\n      var str;\n\n      if (!window.btoa) { throw new Error('btoa undefined'); }\n\n      str = '';\n\n      if (typeof(data) === 'string') {\n        str = data;\n      } else {\n        for (var i = 0; i < data.length; i++) {\n          str += String.fromCharCode(data[i]);\n        }\n      }\n\n      return btoa(str);\n    },\n\n    _getImageData : function (canvas) {\n      return canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);\n    },\n\n    _makeURI : function (strData, type) {\n      return 'data:' + type + ';base64,' + strData;\n    },\n\n    _genBitmapImage : function (data) {\n      var imgHeader, imgInfoHeader, width, height, fsize, _width, _height;\n      var dataSize, padding, imgData, strPixelData, y, offsetX, offsetY, strPixelRow;\n\n      imgHeader = [];\n      imgInfoHeader = [];\n\n      width = data.width;\n      height = data.height;\n      fsize = width * height * 3 + 54; // header size:54 bytes\n\n      imgHeader.push(0x42); // 66 -> B\n      imgHeader.push(0x4d); // 77 -> M\n      imgHeader.push(fsize % 256); // r\n\n      fsize = Math.floor(fsize / 256);\n      imgHeader.push(fsize % 256); // g\n\n      fsize = Math.floor(fsize / 256);\n      imgHeader.push(fsize % 256); // b\n\n      fsize = Math.floor(fsize / 256);\n      imgHeader.push(fsize % 256); // a\n\n      imgHeader.push(0);\n      imgHeader.push(0);\n      imgHeader.push(0);\n      imgHeader.push(0);\n\n      imgHeader.push(54); // offset -> 6\n      imgHeader.push(0);\n      imgHeader.push(0);\n      imgHeader.push(0);\n\n      // info header\n      imgInfoHeader.push(40); // info header size\n      imgInfoHeader.push(0);\n      imgInfoHeader.push(0);\n      imgInfoHeader.push(0);\n\n      // width info\n      _width = width;\n\n      imgInfoHeader.push(_width % 256);\n      _width = Math.floor(_width / 256);\n\n      imgInfoHeader.push(_width % 256);\n      _width = Math.floor(_width / 256);\n\n      imgInfoHeader.push(_width % 256);\n      _width = Math.floor(_width / 256);\n\n      imgInfoHeader.push(_width % 256);\n\n      // height info\n      _height = height;\n\n      imgInfoHeader.push(_height % 256);\n      _height = Math.floor(_height / 256);\n\n      imgInfoHeader.push(_height % 256);\n      _height = Math.floor(_height / 256);\n\n      imgInfoHeader.push(_height % 256);\n      _height = Math.floor(_height / 256);\n\n      imgInfoHeader.push(_height % 256);\n\n      imgInfoHeader.push(1);\n      imgInfoHeader.push(0);\n      imgInfoHeader.push(24); // 24-bit bitmap\n      imgInfoHeader.push(0);\n\n      // no compression\n      imgInfoHeader.push(0);\n      imgInfoHeader.push(0);\n      imgInfoHeader.push(0);\n      imgInfoHeader.push(0);\n\n      // pixel data\n      dataSize = width * height * 3;\n\n      imgInfoHeader.push(dataSize % 256);\n      dataSize = Math.floor(dataSize / 256);\n\n      imgInfoHeader.push(dataSize % 256);\n      dataSize = Math.floor(dataSize / 256);\n\n      imgInfoHeader.push(dataSize % 256);\n      dataSize = Math.floor(dataSize / 256);\n\n      imgInfoHeader.push(dataSize % 256);\n\n      // blank space\n      for (var i = 0; i < 16; i ++) { imgInfoHeader.push(0); }\n\n      padding = (4 - ((width * 3) % 4)) % 4;\n      imgData = data.data;\n      strPixelData = '';\n      y = height;\n\n      do {\n        offsetY = width * (y - 1) * 4;\n        strPixelRow = '';\n        for (var x = 0; x < width; x ++) {\n          offsetX = 4 * x;\n          strPixelRow += String.fromCharCode(imgData[offsetY + offsetX + 2]);\n          strPixelRow += String.fromCharCode(imgData[offsetY + offsetX + 1]);\n          strPixelRow += String.fromCharCode(imgData[offsetY + offsetX]);\n        }\n        for (var n = 0; n < padding; n ++) {\n          strPixelRow += String.fromCharCode(0);\n        }\n\n        strPixelData += strPixelRow;\n      } while(-- y);\n\n      return (this._encodeData(imgHeader.concat(imgInfoHeader)) + this._encodeData(strPixelData));\n    },\n\n    convertToURI : function (canvas, width, height, type) {\n      var data, strData;\n\n      if (this.$support.canvas && this.$support.dataURL) {\n        if (!type) { type = 'png'; }\n        type = this._fixType(type);\n\n        if (/bmp/.test(type)) {\n          data = this._getImageData(this._scaleCanvas(canvas, width, height));\n          strData = this._genBitmapImage(data);\n          return _makeURI(strData, 'image/bmp');\n        } else {\n          strData = this._getDataURL(canvas, type, width, height);\n          return strData;\n        }\n      } else {\n        //TODO throw error\n      }\n    }\n  };\n\n  goog.object.extend(mod, {\n    pickAFile : new Sk.builtin.func(function () {\n      Sk.ffi.checkArgs('pickAFile', arguments, 0);\n\n      return Sk.future(function (continueWith) {\n        window.pythy.showMediaModal({\n          mediaLinkClicked: function (link) {\n            var clientHost, url;\n\n            clientHost = window.location.protocol + '//' + window.location.host;\n            url = $(link).attr('href');\n            if(url[0] === '/') { url = clientHost + url; }\n\n            $('#media_library_modal').modal('hide');\n\n            continueWith(new Sk.builtin.str(url));\n          },\n          cancelled: function () {\n            continueWith(null);\n          }\n        });\n      });\n    }),\n\n    setMediaPath : new Sk.builtin.func(function (path) {\n      Sk.ffi.checkArgs('setMediaPath', arguments, 1);\n      mediaPath = Sk.ffi.unwrapo(path);\n      if(mediaPath[mediaPath.length - 1] === '/') {\n        mediaPath = mediaPath.substring(0, mediaPath.length - 1);\n      }\n    }),\n\n    getMediaPath : new Sk.builtin.func(function (url) {\n      Sk.ffi.checkArgs('getMediaPath', arguments, [0, 1]);\n\n      if(url) {\n        url = Sk.ffi.unwrapo(url);\n      } else {\n        url = '';\n      }\n      if(!mediaPath) {\n        return new Sk.builtin.str(window.mediaffi.customizeMediaURL(url));\n      } else {\n        return new Sk.builtin.str(mediaPath + '/' + url);\n      }\n    }),\n\n    writePictureTo : new Sk.builtin.func(function(picture, path) {\n      var type;\n\n      Sk.ffi.checkArgs('writePictureTo', arguments, 2);\n\n      // Extract the file extension. It looks bizarre at first; source is\n      // http://stackoverflow.com/a/12900504/307266.\n      path = Sk.ffi.unwrapo(path);\n      type = path.substr((Math.max(0, path.lastIndexOf(\".\")) || Infinity) + 1);\n\n      result = Sk.future(function(continueWith) {\n        DrawUtils.drawInto(picture, function(ctx, canvas) {\n          var dataUrl;\n\n          dataUrl = Canvas2Image.convertToURI(\n              canvas, picture.width, picture.height, type);\n\n          window.mediaffi.writePictureTo(dataUrl, path, continueWith);\n        });\n      });\n      if(result && result.errors && result.errors.length) {\n        throw new Sk.builtin.ValueError(result.errors[0].file[0]);\n      }\n    }),\n\n    openPictureTool : new Sk.builtin.func(function(picture) {\n      Sk.ffi.checkArgs('openPictureTool', arguments, 1);\n      window.pythy.pictureTool.show(picture._url);\n    }),\n  });\n\n  return mod;\n};\n", "src/lib/image/picture.js": "// Do not include this module directly as has dependencies \nvar $builtinmodule = function(name) {\n  var mod, pictureWrapper, DrawUtils, Pixel, Color;\n\n  mod = {};\n\n  // Get a reference to the dependencies \n  // TODO Find a better way to do this?\n  Pixel = Sk.sysmodules.mp$subscript('image.pixel').$d.Pixel;\n  Color = Sk.sysmodules.mp$subscript('image.color').$d;\n\n  DrawUtils = {\n    drawEllipticalArc : function(ctx, x, y, w, h, startAngle, endAngle, reversed, fill) {\n      var ratio, xr, cx, cy;\n\n      ratio = h / w;\n      xr = w / 2;\n      cx = x + xr;\n      cy = (y + h / 2) / ratio;\n\n      ctx.save();\n      ctx.scale(1, ratio);\n      ctx.beginPath();\n      if (fill) { ctx.moveTo(cx, cy); }\n      ctx.arc(cx, cy, xr, startAngle, endAngle, reversed);\n      if (fill) { ctx.moveTo(cx, cy); }\n      ctx.restore();\n\n      if (fill){ ctx.fill(); } else { ctx.stroke(); }\n    },\n\n    degToRad : function(degrees) {\n      return degrees * Math.PI / 180;\n    },\n\n    drawEllipse : function(ctx, x, y, w, h, fill) {\n      var ratio = h / w;\n      var xr = w / 2;\n      var yr = h / 2;\n\n      ctx.save();\n      ctx.scale(1, h / w);\n      ctx.beginPath();\n      ctx.arc(x + xr, (y + yr) / ratio, xr, 0, 2 * Math.PI);\n      ctx.restore();\n\n      if (fill) { ctx.fill(); } else { ctx.stroke(); }\n    },\n\n    styleFromColor : function(color) {\n      return 'rgb(' + color._red + ',' + color._green + ',' + color._blue + ')';\n    },\n\n    /**\n     * Creates a canvas, copies the specified picture onto it, then invokes the\n     * callback so that additional drawing can be performed on the context. Once\n     * the callback is complete, the canvas contents are copied back into the\n     * original picture.\n     *\n     * @param picture\n     * @param callback\n     */\n    drawInto : function(picture, callback) {\n      var canvas, ctx;\n\n      canvas = document.createElement('canvas');\n      canvas.width = picture._width;\n      canvas.height = picture._height;\n      ctx = canvas.getContext('2d');\n      ctx.putImageData(picture._imageData, 0, 0);\n      \n      callback(ctx, canvas);\n\n      picture._imageData = ctx.getImageData(0, 0, picture._width, picture._height);\n    },\n\n    /**\n     * Returns an object with width and height properties that describe the\n     * pixel dimensions of a string of text.\n     *\n     * @param text the string to measure\n     * @param font the CSS 'font' style for the text\n     */\n    measureText : function(text, font) {\n      var div, size;\n\n      div = $('<div>').text(text).css({\n        position: 'absolute',\n        'top': '-1000px',\n        left: '-1000px',\n        font: font\n      });\n\n      $('body').append(div);\n      \n      size = { width: div.width(), height: div.height() };\n\n      div.remove();\n\n      return size;\n    },\n  };\n\n  pictureWrapper = {\n    show : new Sk.builtin.func(function (self) {\n      var canvas, ctx;\n\n      Sk.ffi.checkArgs('show', arguments, 1);\n\n      canvas = document.createElement('canvas');\n      canvas.width = self._width;\n      canvas.height = self._height;\n\n      ctx = canvas.getContext('2d');\n      ctx.putImageData(self._imageData, 0, 0);\n\n      window.pythy.pictureTool.show(canvas);\n    }),\n\n    repaint : new Sk.builtin.func(function (self) {\n      var canvas, ctx;\n\n      Sk.ffi.checkArgs('repaint', arguments, 1);\n\n      canvas = document.createElement('canvas');\n      canvas.width = self._width;\n      canvas.height = self._height;\n\n      ctx = canvas.getContext('2d');\n      ctx.putImageData(self._imageData, 0, 0);\n\n      window.pythy.pictureTool.show(canvas);\n    }),\n\n    addArc : new Sk.builtin.func(function(self, x, y, width, height,\n          startAngle, arcAngle, color) {\n      Sk.ffi.checkArgs('addArc', arguments, [7, 8]);\n\n      DrawUtils.drawInto(self, function(ctx) {\n        var startRads, angleRads, endRads, reversed;\n\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = DrawUtils.styleFromColor(color || Color.black);\n\n        startRads = -DrawUtils.degToRad(Sk.ffi.unwrapo(startAngle));\n        angleRads = DrawUtils.degToRad(Sk.ffi.unwrapo(arcAngle));\n        endRads = startRads - angleRads;\n        reversed = (angleRads >= 0);\n\n        DrawUtils.drawEllipticalArc(ctx, Sk.ffi.unwrapo(x), Sk.ffi.unwrapo(y),\n            Sk.ffi.unwrapo(width), Sk.ffi.unwrapo(height), startRads, endRads,\n            reversed, false);\n      });\n    }),\n\n    addArcFilled : new Sk.builtin.func(function(self, x, y, width, height,\n          startAngle, arcAngle, color) {\n      Sk.ffi.checkArgs('addArcFilled', arguments, [7, 8]);\n\n      DrawUtils.drawInto(self, function(ctx) {\n        var startRads, angleRads, endRads, reversed;\n\n        ctx.lineWidth = 1;\n        ctx.fillStyle = DrawUtils.styleFromColor(color || Color.black);\n\n        startRads = -DrawUtils.degToRad(Sk.ffi.unwrapo(startAngle));\n        angleRads = DrawUtils.degToRad(Sk.ffi.unwrapo(arcAngle));\n        endRads = startRads - angleRads;\n        reversed = (angleRads >= 0);\n\n        DrawUtils.drawEllipticalArc(ctx, Sk.ffi.unwrapo(x), Sk.ffi.unwrapo(y),\n            Sk.ffi.unwrapo(width), Sk.ffi.unwrapo(height), startRads, endRads,\n            reversed, true);\n      });\n    }),\n\n    addLine : new Sk.builtin.func(function(self, x1, y1, x2, y2, color) {\n      Sk.ffi.checkArgs('addLine', arguments, [5, 6]);\n\n      DrawUtils.drawInto(self, function(ctx) {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = DrawUtils.styleFromColor(color || Color.black);\n\n        ctx.beginPath();\n        ctx.moveTo(Sk.ffi.unwrapo(x1), Sk.ffi.unwrapo(y1));\n        ctx.lineTo(Sk.ffi.unwrapo(x2), Sk.ffi.unwrapo(y2));\n        ctx.stroke();\n      });\n    }),\n\n    addOval : new Sk.builtin.func(function(self, x, y, width, height, color) {\n      Sk.ffi.checkArgs('addOval', arguments, [5, 6]);\n\n      DrawUtils.drawInto(self, function(ctx) {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = DrawUtils.styleFromColor(color || Color.black);\n        DrawUtils.drawEllipse(ctx, Sk.ffi.unwrapo(x), Sk.ffi.unwrapo(y),\n            Sk.ffi.unwrapo(width), Sk.ffi.unwrapo(height), false);\n      });\n    }),\n\n    addOvalFilled : new Sk.builtin.func(function(self, x, y, width, height, color) {\n      Sk.ffi.checkArgs('addOvalFilled', arguments, [5, 6]);\n\n      DrawUtils.drawInto(self, function(ctx) {\n        ctx.lineWidth = 1;\n        ctx.fillStyle = DrawUtils.styleFromColor(color || Color.black);\n        DrawUtils.drawEllipse(ctx, Sk.ffi.unwrapo(x), Sk.ffi.unwrapo(y),\n            Sk.ffi.unwrapo(width), Sk.ffi.unwrapo(height), true);\n      });\n    }),\n\n    addRect : new Sk.builtin.func(function(self, x, y, width, height, color) {\n      Sk.ffi.checkArgs('addRect', arguments, [5, 6]);\n\n      DrawUtils.drawInto(self, function(ctx) {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = DrawUtils.styleFromColor(color || Color.black);\n        ctx.strokeRect(Sk.ffi.unwrapo(x), Sk.ffi.unwrapo(y),\n            Sk.ffi.unwrapo(width), Sk.ffi.unwrapo(height));\n      });\n    }),\n\n    addRectFilled : new Sk.builtin.func(function(self, x, y, width, height, color) {\n      Sk.ffi.checkArgs('addRectFilled', arguments, [5, 6]);\n\n      DrawUtils.drawInto(self, function(ctx) {\n        ctx.lineWidth = 1;\n        ctx.fillStyle = DrawUtils.styleFromColor(color || Color.black);\n        ctx.fillRect(Sk.ffi.unwrapo(x), Sk.ffi.unwrapo(y),\n            Sk.ffi.unwrapo(width), Sk.ffi.unwrapo(height));\n      });\n    }),\n\n    addText : new Sk.builtin.func(function(self, x, y, string, color) {\n      Sk.ffi.checkArgs('addText', arguments, [4, 5]);\n\n      DrawUtils.drawInto(self, function(ctx) {\n        var height, text;\n\n        text = Sk.ffi.unwrapo(string);\n        ctx.fillStyle = DrawUtils.styleFromColor(color || Color.black);\n        height = DrawUtils.measureText(text, ctx.font).height;\n        ctx.fillText(text, Sk.ffi.unwrapo(x), Sk.ffi.unwrapo(y) + height);\n      });\n    }),\n\n    addTextWithStyle : new Sk.builtin.func(function(self, x, y, text, style, color) {\n      Sk.ffi.checkArgs('addTextWithStyle', arguments, [5, 6]);\n\n      DrawUtils.drawInto(self, function(ctx) {\n        var height;\n\n        text = Sk.ffi.unwrapo(text);\n        ctx.fillStyle = DrawUtils.styleFromColor(color || Color.black);\n        ctx.font = Sk.misceval.callsim(style._toJSString, style);\n        height = DrawUtils.measureText(text, ctx.font).height;\n        ctx.fillText(text, Sk.ffi.unwrapo(x), Sk.ffi.unwrapo(y) + height);\n      });\n    }),\n\n    getHeight : new Sk.builtin.func(function (self) {\n      Sk.ffi.checkArgs('getHeight', arguments, 1);\n      return new Sk.builtin.int_(self._height);\n    }),\n\n    getWidth : new Sk.builtin.func(function (self) {\n      Sk.ffi.checkArgs('getWidth', arguments, 1);\n      return new Sk.builtin.int_(self._width);\n    }),\n\n    getPixel : new Sk.builtin.func(function (picture, x, y) {\n      Sk.ffi.checkArgs('getPixel', arguments, 3);\n      return Sk.misceval.callsim(Pixel, picture, x, y);\n    }),\n\n    getPixelAt : new Sk.builtin.func(function (picture, x, y) {\n      Sk.ffi.checkArgs('getPixelAt', arguments, 3);\n      return Sk.misceval.callsim(Pixel, picture, x, y);\n    }),\n\n    getPixels : new Sk.builtin.func(function (picture) {\n      var pixels;\n\n      Sk.ffi.checkArgs('getPixels', arguments, 1);\n\n      pixels = [];\n      for(var r = 0; r < picture._height; r++) {\n        for(var c = 0; c < picture._width; c++) {\n          pixels.push(Sk.misceval.callsim(Pixel, picture, c, r));\n        }\n      }\n\n      return new Sk.builtin.list(pixels);\n    }),\n\n    getAllPixels : new Sk.builtin.func(function (picture) {\n      var pixels;\n\n      Sk.ffi.checkArgs('getAllPixels', arguments, 1);\n\n      pixels = [];\n      for(var r = 0; r < picture._height; r++) {\n        for(var c = 0; c < picture._width; c++) {\n          pixels.push(Sk.misceval.callsim(Pixel, picture, c, r));\n        }\n      }\n\n      return new Sk.builtin.list(pixels);\n    }),\n\n    copyInto: new Sk.builtin.func(function (smallPic, bigPic, startX, startY) {\n      Sk.ffi.checkArgs('copyInto', arguments, 4);\n\n      DrawUtils.drawInto(bigPic, function (ctx) {\n        ctx.putImageData(smallPic._imageData, Sk.ffi.unwrapo(startX), Sk.ffi.unwrapo(startY));\n      });\n    }),\n\n    setAllPixelsToAColor: new Sk.builtin.func(function (picture, color) {\n      Sk.ffi.checkArgs('setAllPixelsToAColor', arguments, 2);\n\n      DrawUtils.drawInto(picture, function (ctx) {\n        ctx.fillStyle = DrawUtils.styleFromColor(color);\n        ctx.fillRect(0, 0, picture._width, picture._height);\n      });\n    })\n  };\n\n  mod.Picture = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function (self, imageUrl) {\n      var url, res, origUrl;\n\n      Sk.ffi.checkArgs('__init__', arguments, 2);\n\n      origUrl = window.mediaffi.customizeMediaURL(Sk.ffi.unwrapo(imageUrl));\n\n      url = Sk.transformUrl(origUrl);\n\n      res = Sk.future(function (continueWith) {\n        $('<img>').load(function() {\n          var canvas, ctx;\n\n          self._url = origUrl;\n          self._width = this.width;\n          self._height = this.height;\n\n          canvas = document.createElement('canvas');\n          canvas.width = self._width;\n          canvas.height = self._height;\n          ctx = canvas.getContext('2d');\n          ctx.drawImage(this, 0, 0);\n\n          self._ctx = ctx;\n          self._imageData = ctx.getImageData(0, 0, self._width, self._height);\n          continueWith(null);\n        }).error(function() {\n          continueWith(new Sk.builtin.ValueError('The picture could not be ' +\n                'loaded. Is the URL incorrect?'));\n        }).attr('src', url);\n      });\n      if (res) { throw res; };\n    });\n\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      Sk.ffi.checkArgs('__str__', arguments, 1);\n      return new Sk.builtin.str('Picture'   +\n                                ', url '    + self._url +\n                                ', height ' + self._height +\n                                ', width '  + self._width);\n    });\n\n    $loc.duplicate = new Sk.builtin.func(function (picture) {\n      var newPic;\n\n      Sk.ffi.checkArgs('duplicate', arguments, 1);\n\n      newPic = Sk.misceval.callsim(mod.EmptyPicture, picture._width, picture._height);\n      Sk.misceval.callsim(mod.copyInto, picture, newPic, 0, 0);\n      return newPic;\n    });\n\n    goog.object.extend($loc, pictureWrapper);\n\n  }, 'Picture', []);\n\n  mod.EmptyPicture = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function (self, width, height) {\n      var canvas, ctx;\n\n      Sk.ffi.checkArgs('__init__', arguments, 3);\n\n      self._width = Sk.builtin.asnum$(width);\n      self._height = Sk.builtin.asnum$(height);\n      canvas = document.createElement(\"canvas\");\n      ctx = canvas.getContext('2d');\n      canvas.height = self.height;\n      canvas.width = self.width;\n      self._imageData = ctx.getImageData(0, 0, self._width, self._height);\n    });\n\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      Sk.ffi.checkArgs('__str__', arguments, 1);\n      return new Sk.builtin.str('Picture'   +\n                                ', height ' + self._height +\n                                ', width '  + self._width);\n    });\n  }, 'EmptyPicture', [mod.Picture]);\n\n  goog.object.extend(mod, pictureWrapper);\n\n  goog.object.extend(mod, {\n    makePicture : new Sk.builtin.func(function (imageUrl) {\n      Sk.ffi.checkArgs('makePicture', arguments, 1);\n      return Sk.misceval.callsim(mod.Picture, imageUrl);\n    }),\n\n    makeEmptyPicture : new Sk.builtin.func(function(width, height, color) {\n      var picture;\n\n      Sk.ffi.checkArgs('makeEmptyPicture', arguments, [2, 3]);\n      color = color || Color.white\n      picture = Sk.misceval.callsim(mod.EmptyPicture, width, height);\n\n      DrawUtils.drawInto(picture, function (ctx) {\n        ctx.fillStyle = DrawUtils.styleFromColor(color);\n        ctx.fillRect(0, 0, picture._width, picture._height);\n      });\n\n      return picture;\n    }),\n\n    duplicatePicture: new Sk.builtin.func(function (picture) {\n      var newPic;\n\n      Sk.ffi.checkArgs('duplicatePicture', arguments, 1);\n      newPic = Sk.misceval.callsim(mod.EmptyPicture, picture._width, picture._height);\n      Sk.misceval.callsim(mod.copyInto, picture, newPic, 0, 0);\n      return newPic;\n    })\n  });\n\n  return mod;\n};\n", "src/lib/image/style.js": "var $builtinmodule = function(name) {\n  var mod, styleWrapper;\n\n  mod = {};\n\n  mod.Style = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function (self, family, emph, size) {\n      Sk.ffi.checkArgs('__init__', arguments, 4);\n      self._family = family;\n      self._emph = emph;\n      self._size = Sk.ffi.unwrapo(size);\n    }); \n\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      Sk.ffi.checkArgs('__str__', arguments, 1);\n      return new Sk.builtin.str('Style'   +\n                                ', family ' + self._family +\n                                ', emph '   + self._emph +\n                                ', size '   + self._size);\n    });\n\n    $loc._toJSString = new Sk.builtin.func(function(self) {\n      var styleString;\n\n      switch(self._emph) {\n        case 1:\n          styleString = 'bold';\n          break;\n        case 2:\n          styleString = 'italic';\n          break;\n        case 3:\n          styleString = 'bold italic';\n          break;\n        default:\n          styleString = '';\n      }\n\n      styleString += ' ' + self._size + 'pt';\n      styleString += ' ' + self._family;\n\n      return styleString;\n    });\n  }, 'Style', []);\n\n  goog.object.extend(mod, {\n    makeStyle : new Sk.builtin.func(function(family, emph, size) {\n      Sk.ffi.checkArgs('makeStyle', arguments, 3);\n      return Sk.misceval.callsim(mod.Style, family, emph, size);\n    }),\n    PLAIN     : 0,\n    BOLD      : 1,\n    ITALIC    : 2,\n    sansSerif : 'Sans Serif',\n    serif     : 'Serif',\n    mono      : 'Monospaced',\n    comicSans : 'Comic Sans MS',\n  });\n\n  return mod;\n};\n", "src/lib/image/color.js": "var $builtinmodule = function(name) {\n  var mod, colorWrapper, COLOR_FACTOR, noWrapColor, wrapColor;\n\n  mod = {};\n\n  COLOR_FACTOR = 0.70;\n\n  noWrapColor = function (value) {\n    var v;\n\n    v = Sk.builtin.asnum$(value);\n    if(v < 0) { v = 0; } else if (v > 255) { v = 255; } \n    return v;\n  };\n\n  wrapColor = function (value) {\n    var v;\n\n    v = (Sk.builtin.asnum$(value) % 256);\n    if(value < 0) { v += 256; } \n\n    return v;\n  };\n\n  mod._validateColor = noWrapColor;\n\n  mod._colorWrapAround = 0;\n\n  colorWrapper = {\n    makeDarker : new Sk.builtin.func(function(self) {\n      Sk.ffi.checkArgs('makeDarker', arguments, 1);\n\n      // This is from java.awt.Color\n      return Sk.misceval.callsim(mod.Color, self._red * COLOR_FACTOR,\n          self._green * COLOR_FACTOR, self._blue * COLOR_FACTOR);\n    }),\n\n    makeLighter : new Sk.builtin.func(function(self) {\n      var r, g, b, factor;\n      \n      Sk.ffi.checkArgs('makeLighter', arguments, 1);\n\n      r = self._red;\n      g = self._green;\n      b = self._blue;\n      factor = 1.0 / (1.0 - COLOR_FACTOR);\n\n      // This is from java.awt.Color\n      if(r === 0 && b === 0 && g === 0) {\n        return Sk.misceval.callsim(mod.Color, factor, factor, factor);\n      }\n\n      if(r > 0 && r < factor) { r = factor; }\n      if(g > 0 && g < factor) { g = factor; }\n      if(b > 0 && b < factor) { b = factor; }\n\n      return Sk.misceval.callsim(mod.Color, r / COLOR_FACTOR, g / COLOR_FACTOR, b / COLOR_FACTOR);\n    }),\n\n    makeBrighter : new Sk.builtin.func(function(self) {\n      var r, g, b, factor;\n      \n      Sk.ffi.checkArgs('makeBrighter', arguments, 1);\n\n      r = self._red;\n      g = self._green;\n      b = self._blue;\n      factor = 1.0 / (1.0 - COLOR_FACTOR);\n\n      // This is from java.awt.Color\n      if(r === 0 && b === 0 && g === 0) {\n        return Sk.misceval.callsim(mod.Color, factor, factor, factor);\n      }\n\n      if(r > 0 && r < factor) { r = factor; }\n      if(g > 0 && g < factor) { g = factor; }\n      if(b > 0 && b < factor) { b = factor; }\n\n      return Sk.misceval.callsim(mod.Color, r / COLOR_FACTOR, g / COLOR_FACTOR, b / COLOR_FACTOR);\n    }),\n\n    distance : new Sk.builtin.func(function(self, other) {\n      Sk.ffi.checkArgs('distance', arguments, 2);\n\n      return new Sk.builtin.float_(Math.sqrt(\n        Math.pow(self._red - other._red, 2) +\n        Math.pow(self._green - other._green, 2) +\n        Math.pow(self._blue - other._blue, 2)));\n    })\n  };\n\n  mod.Color = Sk.misceval.buildClass(mod, function ($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, red, green, blue) {\n      Sk.ffi.checkArgs('__init__', arguments, [2, 4]);\n\n      if(red.tp$name === 'Color') {\n        self._red = mod._validateColor(parseInt(Sk.builtin.asnum$(red._red)));\n        self._green = mod._validateColor(parseInt(Sk.builtin.asnum$(red._green)));\n        self._blue = mod._validateColor(parseInt(Sk.builtin.asnum$(red._blue)));\n      } else {\n        self._red = mod._validateColor(parseInt(Sk.builtin.asnum$(red))); \n        self._green = mod._validateColor(parseInt(Sk.builtin.asnum$(green)));\n        self._green = self._green >= 0 ? self._green : self._red;\n        self._blue = mod._validateColor(parseInt(Sk.builtin.asnum$(blue)));\n        self._blue = self._blue >= 0 ? self._blue : self._red;\n      }\n\n    });\n\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      Sk.ffi.checkArgs('__str__', arguments, 1);\n      return new Sk.builtin.str('Color' + \n                                ', r='  + self._red +\n                                ', g='  + self._green +\n                                ', b='  + self._blue);\n    });\n\n    goog.object.extend($loc, colorWrapper);\n  }, 'Color', []); \n\n  goog.object.extend(mod, colorWrapper);\n\n  goog.object.extend(mod, {\n    makeColor : new Sk.builtin.func(function(red, green, blue) {\n      Sk.ffi.checkArgs('makeColor', arguments, [1, 3]);\n      return Sk.misceval.callsim(mod.Color, red, green, blue);\n    }),\n\n    pickAColor : new Sk.builtin.func(function() {\n      Sk.ffi.checkArgs('pickAColor', arguments, 0);\n      \n      return Sk.future(function(continueWith) {\n        window.pythy.colorPicker.show(function (r, g, b) {\n          continueWith(Sk.misceval.callsim(mod.Color, r, g, b));\n        });\n      });\n    }),\n\n    setColorWrapAround: new Sk.builtin.func(function (flag) {\n      Sk.ffi.checkArgs('setColorWrapAround', arguments, 1);\n\n      mod._colorWrapAround = Sk.builtin.asnum$(flag);\n\n      switch(mod._colorWrapAround) {\n        case 0:\n          mod._validateColor = noWrapColor;\n          break;\n        case 1:\n          mod._validateColor = wrapColor;\n          break;\n        default:\n          throw new Sk.builtin.TypeError('The flag must be a boolean value');\n      }\n    }),\n\n    getColorWrapAround: new Sk.builtin.func(function () {\n      Sk.ffi.checkArgs('getColorWrapAround', arguments, 0);\n      return new Sk.builtin.bool(mod._colorWrapAround);\n    }),\n\n    black     : Sk.misceval.callsim(mod.Color, 0, 0, 0),\n    blue      : Sk.misceval.callsim(mod.Color, 0, 0, 255),\n    cyan      : Sk.misceval.callsim(mod.Color, 0, 255, 255),\n    darkGray  : Sk.misceval.callsim(mod.Color, 64, 64, 64),\n    gray      : Sk.misceval.callsim(mod.Color, 128, 128, 128),\n    green     : Sk.misceval.callsim(mod.Color, 0, 255, 0),\n    lightGray : Sk.misceval.callsim(mod.Color, 192, 192, 192),\n    magenta   : Sk.misceval.callsim(mod.Color, 255, 0, 255),\n    orange    : Sk.misceval.callsim(mod.Color, 255, 200, 0),\n    pink      : Sk.misceval.callsim(mod.Color, 255, 175, 175),\n    red       : Sk.misceval.callsim(mod.Color, 255, 0, 0),\n    white     : Sk.misceval.callsim(mod.Color, 255, 255, 255),\n    yellow    : Sk.misceval.callsim(mod.Color, 255, 255, 0)\n  });\n\n  return mod;\n};\n", "src/lib/image/pixel.js": "// Do not include this module directly as it has dependencies \nvar $builtinmodule = function(name) {\n  var mod, pixelWrapper, Color, colorMod;\n\n  mod = {};\n  colorMod = Sk.sysmodules.mp$subscript('image.color').$d;\n  Color = colorMod.Color;\n\n  pixelWrapper = {\n    setColor : new Sk.builtin.func(function (self, color) {\n      var data, index;\n\n      Sk.ffi.checkArgs('setColor', arguments, 2);\n\n      data = self._picture._imageData.data;\n\n      index = self._y * 4 * self._picture._width  + self._x * 4;\n\n      data[index] = color._red;\n      data[index+1] = color._green;\n      data[index+2] = color._blue;\n      // Note: We have to set the alpha to 255 because the rgb values are\n      // multiplied by the alpha before being set. So if alpha = 0, the rgb\n      // values will become 0\n      data[index+3] = 255;\n    }),\n\n    getColor : new Sk.builtin.func(function (self) {\n      var red, green, blue;\n\n      Sk.ffi.checkArgs('getColor', arguments, 1);\n\n      red = Sk.misceval.callsim(self.getRed, self); \n      green = Sk.misceval.callsim(self.getGreen, self); \n      blue = Sk.misceval.callsim(self.getBlue, self);\n\n      return Sk.misceval.callsim(Color, red, green, blue);\n    }),\n\n    getX : new Sk.builtin.func(function (self) {\n      Sk.ffi.checkArgs('getX', arguments, 1);\n      return new Sk.builtin.int_(self._x);\n    }),\n\n    getY : new Sk.builtin.func(function (self) {\n      Sk.ffi.checkArgs('getY', arguments, 1);\n      return new Sk.builtin.int_(self._y);\n    }),\n\n    getRed : new Sk.builtin.func(function (self) {\n      var index;\n\n      Sk.ffi.checkArgs('getRed', arguments, 1);\n\n      index = (self._y * 4) * self._picture._width + (self._x * 4);\n\n      return new Sk.builtin.int_(self._picture._imageData.data[index]);\n    }),\n\n    getGreen : new Sk.builtin.func(function (self) {\n      var index;\n\n      Sk.ffi.checkArgs('getGreen', arguments, 1);\n\n      index = (self._y * 4) * self._picture._width + (self._x * 4);\n\n      return new Sk.builtin.int_(self._picture._imageData.data[index + 1]);\n    }),\n\n    getBlue : new Sk.builtin.func(function (self) {\n      var index;\n\n      Sk.ffi.checkArgs('getBlue', arguments, 1);\n\n      index = (self._y * 4) * self._picture._width + (self._x * 4);\n\n      return new Sk.builtin.int_(self._picture._imageData.data[index + 2]);\n    }),\n\n    setRed : new Sk.builtin.func(function (self, red) {\n      var index;\n\n      Sk.ffi.checkArgs('setRed', arguments, 2);\n\n      index = self._y * 4 * self._picture._width  + self._x * 4;\n\n      self._picture._imageData.data[index] = colorMod._validateColor(Sk.ffi.unwrapo(red));\n      // Note: We have to set the alpha to 255 because the rgb values are\n      // multiplied by the alpha before being set. So if alpha = 0, the rgb\n      // values will become 0\n      self._picture._imageData.data[index + 3] = 255;\n    }),\n\n    setGreen : new Sk.builtin.func(function (self, green) {\n      var index;\n\n      Sk.ffi.checkArgs('setGreen', arguments, 2);\n\n      index = self._y * 4 * self._picture._width  + self._x * 4;\n\n      self._picture._imageData.data[index + 1] = colorMod._validateColor(Sk.ffi.unwrapo(green));\n      // Note: We have to set the alpha to 255 because the rgb values are\n      // multiplied by the alpha before being set. So if alpha = 0, the rgb\n      // values will become 0\n      self._picture._imageData.data[index + 3] = 255;\n    }),\n\n    setBlue : new Sk.builtin.func(function (self, blue) {\n      var index;\n\n      Sk.ffi.checkArgs('setBlue', arguments, 2);\n\n      index = self._y * 4 * self._picture._width  + self._x * 4;\n\n      self._picture._imageData.data[index + 2] = colorMod._validateColor(Sk.ffi.unwrapo(blue));\n      // Note: We have to set the alpha to 255 because the rgb values are\n      // multiplied by the alpha before being set. So if alpha = 0, the rgb\n      // values will become 0\n      self._picture._imageData.data[index + 3] = 255;\n    })\n  };\n\n  mod.Pixel = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, picture, x, y) {\n      Sk.ffi.checkArgs('__init__', arguments, 4);\n\n      self._x = Sk.builtin.asnum$(x);\n      self._y = Sk.builtin.asnum$(y);\n      self._picture = picture;\n    });\n\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var red, green, blue;\n\n      Sk.ffi.checkArgs('__str__', arguments, 1);\n\n      red = Sk.builtin.asnum$(Sk.misceval.callsim(self.getRed, self)); \n      green = Sk.builtin.asnum$(Sk.misceval.callsim(self.getGreen, self)); \n      blue = Sk.builtin.asnum$(Sk.misceval.callsim(self.getBlue, self));\n\n      return new Sk.builtin.str('Pixel'  + \n                                ', red='   + red +\n                                ', green=' + green +\n                                ', blue='  + blue);\n    });\n\n    goog.object.extend($loc, pixelWrapper);\n  }, 'Pixel', []);\n\n  goog.object.extend(mod, pixelWrapper);\n\n  return mod;\n};\n", "src/lib/xml/__init__.py": "raise NotImplementedError(\"xml is not yet implemented in Skulpt\")\n", "src/lib/xml/parsers/__init__.py": "raise NotImplementedError(\"parsers is not yet implemented in Skulpt\")\n", "src/lib/xml/sax/__init__.py": "raise NotImplementedError(\"sax is not yet implemented in Skulpt\")\n", "src/lib/xml/dom/__init__.py": "raise NotImplementedError(\"dom is not yet implemented in Skulpt\")\n", "src/lib/xml/etree/__init__.py": "raise NotImplementedError(\"etree is not yet implemented in Skulpt\")\n", "src/lib/requests/__init__.js": "var $builtinmodule = function (name) {\n    var request = {};\n\n\n    //~ Classes .................................................................\n\n    // Response class\n    //\n    // Response objects are returned by the request, get, post, etc.\n    // methods, allowing the user to access the response text, status\n    // code, and other information.\n\n    // ------------------------------------------------------------\n    var response = function ($gbl, $loc) {\n\n        // ------------------------------------------------------------\n        $loc.__init__ = new Sk.builtin.func(function (self, data) {\n            self.data$ = data;\n            self.lineList = self.data$.split(\"\\n\");\n            self.lineList = self.lineList.slice(0, -1);\n            for (var i = 0; i < self.lineList.length; i++) {\n                self.lineList[i] = self.lineList[i] + '\\n';\n            }\n            self.currentLine = 0;\n            self.pos$ = 0;\n            Sk.abstr.sattr(self, 'text', Sk.ffi.remapToPy(self.data$), true);\n        });\n\n\n        // ------------------------------------------------------------\n        $loc.__str__ = new Sk.builtin.func(function (self) {\n            return Sk.ffi.remapToPy('<Response>');\n        });\n        \n        $loc.__repr__ = $loc.__str__;\n\n        // ------------------------------------------------------------\n        $loc.__iter__ = new Sk.builtin.func(function (self) {\n            var allLines = self.lineList;\n\n            return Sk.builtin.makeGenerator(function () {\n                if (this.$index >= this.$lines.length) {\n                    return undefined;\n                }\n                return new Sk.builtin.str(this.$lines[this.$index++]);\n            }, {\n                $obj  : self,\n                $index: 0,\n                $lines: allLines\n            });\n        });\n\n\n        // ------------------------------------------------------------\n        $loc.read = new Sk.builtin.func(function (self, size) {\n            if (self.closed) {\n                throw new Sk.builtin.ValueError(\"I/O operation on closed file\");\n            }\n            var len = self.data$.length;\n            if (size === undefined) {\n                size = len;\n            }\n            var ret = new Sk.builtin.str(self.data$.substr(self.pos$, size));\n            self.pos$ += size;\n            if (self.pos$ >= len) {\n                self.pos$ = len;\n            }\n            return ret;\n        });\n\n\n        // ------------------------------------------------------------\n        $loc.readline = new Sk.builtin.func(function (self, size) {\n            var line = \"\";\n            if (self.currentLine < self.lineList.length) {\n                line = self.lineList[self.currentLine];\n                self.currentLine++;\n            }\n            return new Sk.builtin.str(line);\n        });\n\n\n        // ------------------------------------------------------------\n        $loc.readlines = new Sk.builtin.func(function (self, sizehint) {\n            var arr = [];\n            for (var i = self.currentLine; i < self.lineList.length; i++) {\n                arr.push(new Sk.builtin.str(self.lineList[i]));\n            }\n            return new Sk.builtin.list(arr);\n        });\n        \n        // ------------------------------------------------------------\n        $loc.json = new Sk.builtin.func(function (self) {\n            return Sk.ffi.remapToPy(JSON.parse(self.data$));\n        });\n\n    };\n\n    request.Response =\n        Sk.misceval.buildClass(request, response, 'Response', []);\n\n\n    //~ Module functions ........................................................\n\n    // ------------------------------------------------------------\n    /**\n     * Constructs and sends a Request. Returns Response object.\n     *\n     * http://docs.python-requests.org/en/latest/api/#requests.request\n     *\n     * For now, this implementation doesn't actually construct a Request\n     * object; it just makes the request through jQuery.ajax and then\n     * constructs a Response.\n     */\n    request.get = new Sk.builtin.func(function (url, data, timeout) {\n        var prom = new Promise(function(resolve, reject) {\n            if (Sk.requestsGet) {\n                Sk.requestsGet(Sk.ffi.remapToJs(url), data, timeout).then(function(result) {\n                    resolve(Sk.misceval.callsim(request.Response, result));\n                }, function(err) {\n                    reject(err);\n                    //resolve(Sk.misceval.callsim(request.Response, err));\n                });\n            } else {\n                var xmlhttp = new XMLHttpRequest();\n                \n                xmlhttp.addEventListener(\"loadend\", function (e) {\n                    resolve(Sk.misceval.callsim(request.Response, xmlhttp.responseText));\n                });\n\n                if (!data) {\n                    xmlhttp.open(\"GET\", url.v);\n                    xmlhttp.send(null);\n                } else {\n                    xmlhttp.open(\"POST\", url.v);\n                    xmlhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n                    xmlhttp.setRequestHeader(\"Content-length\", data.v.length);\n                    xmlhttp.send(data.v);\n                }\n            }\n        });\n\n        var susp = new Sk.misceval.Suspension();\n\n        susp.resume = function() {\n            if (susp.data[\"error\"]) {\n                //throw new Sk.builtin.IOError(susp.data[\"error\"].message);\n                throw susp.data[\"error\"];\n            } else {\n                return resolution;\n            }\n        };\n        \n        susp.data = {\n            type: \"Sk.promise\",\n            promise: prom.then(function(value) {\n                resolution = value;\n                return value;\n            }, function(err) {\n                resolution = \"\";\n                throw err;\n                //return err;\n            })\n        };\n\n        return susp;\n    });\n\n\n    return request;\n};", "src/lib/wsgiref/__init__.py": "raise NotImplementedError(\"wsgiref is not yet implemented in Skulpt\")\n", "src/lib/json/__init__.js": "var $builtinmodule = function(name) {\n  \"use strict\";\n  var mod = {};\n\n  // skipkeys=False,\n  // ensure_ascii=True,\n  // check_circular=True,\n  // allow_nan=True,\n  // cls=None,\n  // indent=None,\n  // separators=None,\n  // encoding=\"utf-8\",\n  // default=None,\n  // sort_keys=False,\n  // **kw\n\n  var dumps_f = function(kwa) {\n    Sk.builtin.pyCheckArgs(\"dumps\", arguments, 1, Infinity, true, false);\n\n    var args      = Array.prototype.slice.call(arguments, 1),\n        kwargs    = new Sk.builtins.dict(kwa),\n        sort_keys = false,\n        stringify_opts, default_, jsobj, str;\n\n    // default stringify options\n    stringify_opts = {\n      ascii      : true,\n      separators : {\n        item_separator : ', ',\n        key_separator  : ': '\n      }\n    };\n\n    kwargs = Sk.ffi.remapToJs(kwargs);\n    jsobj  = Sk.ffi.remapToJs(args[0]);\n\n    // TODO: likely need to go through character by character to enable this\n    if (typeof(kwargs.ensure_ascii) === \"boolean\" && kwargs.ensure_ascii === false) {\n      stringify_opts.ascii = false;\n    }\n\n    // TODO: javascript sort isn't entirely compatible with python's\n    if (typeof(kwargs.sort_keys) === \"boolean\" && kwargs.sort_keys) {\n      sort_keys = true;\n    }\n\n    if (!sort_keys) {\n      // don't do any sorting unless sort_keys is true\n      // if sort_keys use stringify's default sort, which is alphabetical\n      stringify_opts.cmp = function(a, b) {\n        return 0;\n      };\n    }\n\n    // item_separator, key_separator) tuple. The default is (', ', ': ').\n    if (typeof(kwargs.separators) === \"object\" && kwargs.separators.length == 2) {\n      stringify_opts.separators.item_separator = kwargs.separators[0];\n      stringify_opts.separators.key_separator  = kwargs.separators[1];\n    }\n\n    // TODO: if indent is 0 it should add newlines\n    if (kwargs.indent) {\n      stringify_opts.space = kwargs.indent;\n    }\n\n    // Sk.ffi.remapToJs doesn't map functions\n    if (kwargs.default) {\n    }\n\n    // may need to create a clone of this to have more control/options\n    str = JSON.stringify(jsobj, stringify_opts, kwargs.indent || 1);\n\n    return new Sk.builtin.str(str);\n  };\n\n  dumps_f.co_kwargs = true;\n  mod.dumps = new Sk.builtin.func(dumps_f);\n\n  // encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]\n  var loads_f = function(kwa) {\n    Sk.builtin.pyCheckArgs(\"loads\", arguments, 1, Infinity, true, false);\n\n    var args   = Array.prototype.slice.call(arguments, 1),\n        kwargs = new Sk.builtins.dict(kwa),\n        str, obj;\n\n    kwargs = Sk.ffi.remapToJs(kwargs);\n    str    = args[0].v;\n    obj    = JSON.parse(str);\n\n    return Sk.ffi.remapToPy(obj);\n  };\n\n  loads_f.co_kwargs = true;\n  mod.loads = new Sk.builtin.func(loads_f);\n  \n  var load_f = function(kwa) {\n      Sk.builtin.pyCheckArgs(\"load\", arguments, 1, Infinity, true, false);\n      \n      var args   = Array.prototype.slice.call(arguments, 1),\n        kwargs = new Sk.builtins.dict(kwa),\n        str, obj, file;\n    \n      kwargs = Sk.ffi.remapToJs(kwargs);\n      file   = args[0];\n      str    = Sk.misceval.callsim(Sk.builtin.file.prototype['read'], file).v;\n      obj    = JSON.parse(str);\n      \n      return Sk.ffi.remapToPy(obj);\n  }\n  \n  load_f.co_kwargs = true;\n  mod.load = new Sk.builtin.func(load_f);\n\n  return mod;\n};", "src/lib/json/tests/__init__.py": "raise NotImplementedError(\"tests is not yet implemented in Skulpt\")\n", "src/lib/sqlite3/__init__.js": "var $builtinmodule = function (name) {\n    var mod = {};\n    if (typeof SQL != 'object') {\n        Sk.debugout(\"sql.js not included and callable\");\n    }\n    \n    mod.version = '1';\n    mod.connect = new Sk.builtin.func(function(database) {\n        Sk.builtin.pyCheckArgs(\"connect\", arguments, 1, 7);\n        \n        console.log(SQL);\n    });\n    \n    return mod;\n}", "src/lib/bsddb/__init__.py": "raise NotImplementedError(\"bsddb is not yet implemented in Skulpt\")\n", "src/lib/matplotlib/__init__.js": "var $builtinmodule = function(name)\n{\n  var matplotlib = {};\n\n  return matplotlib;\n};\n", "src/lib/matplotlib/pyplot/__init__.js": "var jsplotlib = {};\n\n// Skulpt translation\nvar $builtinmodule = function(name) {\n    var mod = {};\n    \n    // Unique ID generator for charts\n    var chartCounter = 0;\n    \n    var chart; // The aggregate object to hold multiple plots\n    var labels; // Title, X-axis title, Y-axis title\n    var plots; // All the plots to end up drawing\n    var extents; // The highest and lowest values across each axis\n    var colorCycle;\n    \n    function resetChart() {\n        chart = null;\n        colorCycle = 0;\n        labels = {\n            'title': '',\n            'x-axis': '',\n            'y-axis': ''\n        };\n        plots = [];\n        extents = {\n            'xMin': null, \n            'yMin': null, \n            'xMax': null, \n            'yMax': null\n        };\n    }\n    resetChart();\n    \n    // Keep track of any plotted values for later checks\n    mod.values = [];\n\n    // Creates the aggregate chart object that will hold 1 or more plots\n    var createChart = function(type) {\n        if (Sk.console === undefined) {\n            throw new Sk.builtin.NameError(\n                \"Can not resolve drawing area. Sk.console is undefined!\");\n        }\n\n        if (!chart) {\n            // Create a new chart\n            chartCounter += 1;\n            chart = {};\n            \n            chart.margin = {'top': 20, 'right': 30, 'bottom': 50, 'left': 40};\n            chart.width = Sk.console.width - chart.margin.left - chart.margin.right;\n            chart.height = Sk.console.height - chart.margin.top - chart.margin.bottom;\n            chart.id = 'chart' + chartCounter;\n            chart.type = type;\n            \n            if (Sk.console.skipDrawing) {\n                return chart;\n            }\n            \n            return chart;\n        }\n    };\n    \n    function updateMinMax(attr, array) {\n        if (extents[attr+\"Min\"] === null) {\n            extents[attr+\"Min\"] = d3.min(array);\n        } else {\n            extents[attr+\"Min\"] = Math.min(d3.min(array), extents[attr+\"Min\"])\n        }\n        if (extents[attr+\"Max\"] === null) {\n            extents[attr+\"Max\"] = d3.max(array);\n        } else {\n            extents[attr+\"Max\"] = Math.max(d3.max(array), extents[attr+\"Max\"])\n        }\n    }\n    \n    function getRandomSubarray(arr, size) {\n        var shuffled = arr.slice(0), i = arr.length, temp, index;\n        while (i--) {\n            index = Math.floor((i + 1) * Math.random());\n            temp = shuffled[index];\n            shuffled[index] = shuffled[i];\n            shuffled[i] = temp;\n        }\n        return shuffled.slice(0, size);\n    }\n\n    // Main plotting function\n    var plot_f = function(kwa) {\n        // Parse arguments\n        Sk.builtin.pyCheckArgs(\"plotk\", arguments, 1, Infinity, true, false);\n        args = Array.prototype.slice.call(arguments, 1);\n        kwargs = new Sk.builtins.dict(kwa); // is pretty useless for handling kwargs\n        kwargs = Sk.ffi.remapToJs(kwargs); // create a proper dict\n        \n        // Keep a backup of the arguments for checker\n        mod.values.push(args);\n        \n        // Parse different argument combinations\n        var xdata = null;\n        var ydata = null;\n        var stylestring = null;\n        if (args.length == 1) {\n            // ydata\n            ydata = Sk.ffi.remapToJs(args[0]);\n        } else if (args.length == 2) {\n            if (Sk.builtin.checkString(args[1])) {\n                // ydata, style\n                ydata = Sk.ffi.remapToJs(args[0]);\n                stylestring = Sk.ffi.remapToJs(args[1]);\n            } else {\n                // xdata, ydata\n                xdata = Sk.ffi.remapToJs(args[0]);\n                ydata = Sk.ffi.remapToJs(args[1]);\n            }\n        } else if (args.length == 3) {\n            // xdata, ydata, style\n            xdata = Sk.ffi.remapToJs(args[0]);\n            ydata = Sk.ffi.remapToJs(args[1]);\n            stylestring = Sk.ffi.remapToJs(args[2]);\n        }\n        if (xdata === null) {\n            xdata = [];\n            for (var i = 0; i < ydata.length; i++) {\n               xdata.push(i);\n            }\n        }\n        \n        // empty canvas from previous plots\n        createChart('line');\n\n        // Zip up the data\n        var actualData = d3.zip(xdata, ydata).map(function(e) {\n            return {'x': e[0], 'y': e[1]}\n        });\n        // Parse formatting, also keep ColorCycler updated\n        var cycle = jsplotlib.rc[\"axes.color_cycle\"];\n        var linestyle = '-', marker= '', \n            color = cycle[colorCycle % cycle.length];\n        if (stylestring !== null) {\n            var ftm_tuple = jsplotlib._process_plot_format(stylestring);\n            linestyle = ftm_tuple.linestyle;\n            marker = jsplotlib.parse_marker(ftm_tuple.marker);\n            color = ftm_tuple.color;\n        } else {\n            colorCycle += 1;\n        }\n        // Save\n        plots.push({\n            \"data\": actualData, \n            \"type\": 'line',\n            'style': {\n                'linestyle': linestyle,\n                'marker': marker,\n                'color': jsplotlib.color_to_hex(color)\n            }\n        });\n        // Update min/max\n        updateMinMax(\"x\", xdata)\n        updateMinMax(\"y\", ydata)\n        \n        if (Sk.console.skipDrawing) {\n            return;\n        }\n    };\n    plot_f.co_kwargs = true;\n    mod.plot = new Sk.builtin.func(plot_f);\n\n    var show_f = function() {\n        /*if (Sk.console.skipDrawing) {\n            Sk.console.printHtml([0], plots);\n            return;\n        }*/\n        \n        if (!chart) {\n            createChart('line');\n        }\n        if (chart.type == 'hist' && plots.length < 1) {\n            resetChart();\n            return;\n        }\n        if (plots.length == 0) {\n            return;\n        }\n        if (extents['xMin'] === undefined || extents['yMin'] === undefined) {\n            return;\n        }\n        \n        var yAxisBuffer;\n        \n        // Establish x/y scalers and axes\n        if (chart.type == 'scatter' || chart.type == 'line') {\n            yAxisBuffer = 5*Math.max(extents['yMin'].toLocaleString().length, \n                                   extents['yMax'].toLocaleString().length);\n            chart.xScale = d3.scale.linear()\n                                   .domain([extents['xMin'], extents['xMax']])\n                                   .range([0, chart.width-yAxisBuffer]);\n            chart.xAxis = d3.svg.axis()\n                                .scale(chart.xScale)\n                                .orient(\"bottom\");\n        } else if (chart.type == 'hist') {\n            yAxisBuffer = 5*Math.max(extents['xMin'].toLocaleString().length, \n                                   extents['xMax'].toLocaleString().length);\n            chart.xScale = d3.scale.linear()\n                                   .domain([extents['xMin'], extents['xMax']])\n                                   .range([0, chart.width-yAxisBuffer]);\n            chart.xAxis = d3.svg.axis()\n                                .scale(chart.xScale)\n                                .orient(\"bottom\");\n            var bins = plots[0]['bins'];\n            var tempScale = d3.scale.linear()\n                                    .domain([\n                                        0, bins\n                                    ])\n                                    .range([extents['xMin'], extents['xMax']]);\n            var tickArray = d3.range(bins+1)\n                              .map(tempScale).map(function(e) {\n                                return e;\n                              });\n            // TODO: support multiple histograms\n            var histMapper = d3.layout.histogram().bins(\n            tickArray\n            //chart.xScale.ticks(bins)\n            )(plots[0]['data']);\n        } else if (chart.type == 'bar') {\n            yAxisBuffer = 5*Math.max(extents['yMin'].toLocaleString().length, \n                                   extents['yMax'].toLocaleString().length);\n            chart.xScale = d3.scale.ordinal()\n                                   .domain([extents['xMin'], extents['xMax']])\n                                   .rangeBands([0, chart.width-yAxisBuffer]);\n            chart.xAxis = d3.svg.axis()\n                                .scale(chart.xScale)\n                                .tickFormat(function(d) { return d.index })\n                                .orient(\"bottom\");\n        }\n        if (chart.type !== 'hist') {\n            chart.yScale = d3.scale.linear()\n                                   .domain([extents['yMin'], extents['yMax']])\n                                   .range([chart.height, 0]);\n        } else {\n            chart.yScale = d3.scale.linear()\n                                   .domain([0, d3.max(histMapper, function(d) { return d.y; })])\n                                   .range([chart.height, 0]);\n        }\n        chart.yAxis = d3.svg.axis()\n                            .scale(chart.yScale)\n                            .orient(\"left\");\n        \n        chart.mapX = function(d) {return chart.xScale(d.x)};\n        chart.mapY = function(d) {return chart.yScale(d.y)};\n        chart.mapLine = d3.svg.line()\n                              .x(function(d) { return chart.xScale(d.x); })\n                              .y(function(d) { return chart.yScale(d.y); })\n                              .interpolate(\"linear\");\n                            \n        // set css classes\n        chart.svg = d3.select(Sk.console.container).append('div').append('svg');\n        //$(chart.svg.node()).parent().hide();\n        chart.svg.attr('class', 'chart');\n        chart.svg.attr('width', Sk.console.width);\n        chart.svg.attr('height', Sk.console.height);\n        chart.svg.attr('chartCount', chartCounter);\n        \n        var translation = \"translate(\" + (chart.margin.left + yAxisBuffer) + \",\" + chart.margin.top + \")\";\n        chart.canvas = chart.svg.append(\"g\")\n                                .attr(\"transform\", translation);\n        \n        chart.canvas.append(\"g\")\n                    .attr(\"class\", \"x axis\")\n                    .attr(\"transform\", \"translate(0,\" + chart.height + \")\")\n                    .call(chart.xAxis);\n        chart.canvas.append(\"g\")\n                    .attr(\"class\", \"y axis\")\n                    .call(chart.yAxis);\n        chart.canvas.select(\".x.axis\")\n                    .selectAll(\"text\")\n                    .style(\"font-size\",\"12px\");\n        chart.canvas.select(\".y.axis\")\n                    .selectAll(\"text\")\n                    .style(\"font-size\",\"12px\");\n        translation = \"translate(\" + ( (chart.width-yAxisBuffer) / 2) + \" ,\" + (chart.height + chart.margin.bottom-14) + \")\";\n        chart.canvas.append(\"text\")      // text label for the x axis\n                    .attr(\"transform\", translation)\n                    .attr(\"class\", \"x-axis-label\")\n                    .style(\"font-size\", \"14px\") \n                    .text(labels['x-axis'])\n                    .style(\"text-anchor\", \"middle\");\n        chart.canvas.append(\"text\")\n                    .attr(\"transform\", \"rotate(-90)\")\n                    .attr(\"class\", \"y-axis-label\")\n                    .attr(\"y\", 0 - chart.margin.left-yAxisBuffer)\n                    .attr(\"x\", 0 - (chart.height / 2))\n                    .attr(\"dy\", \"1em\")\n                    .text(labels['y-axis'])\n                    .style(\"font-size\", \"14px\") \n                    .style(\"text-anchor\", \"middle\");\n        chart.canvas.append(\"text\")\n                    .attr(\"x\", ( (chart.width-yAxisBuffer) / 2))\n                    .attr(\"y\", 0 - (chart.margin.top / 2))\n                    .attr(\"class\", \"title-text\")\n                    .text(labels['title'])\n                    .attr(\"text-anchor\", \"middle\")  \n                    .style(\"font-size\", \"14px\") \n                    .style(\"text-decoration\", \"underline\");\n        chart.canvas.append(\"text\")\n                    .attr(\"x\", 0)\n                    .attr(\"y\", 0)\n                    .text(\"BlockPy\")\n                    .style(\"stroke\", \"#FDFDFD\")\n                    .style(\"font-size\", \"8px\");\n        chart.svg.insert('defs', \":first-child\")\n                    .append('style')\n                    .attr(\"type\", \"text/css\")\n                    .text(\"svg { background-color: white; }\\n\"+\n                          \".axis path,.axis line { fill: none; stroke: black; shape-rendering: crispEdges;}\\n\"+\n                          \".line { fill: none; stroke-width: 1px;}\\n\"+\n                          \".circle { r: 3; shape-rendering: crispEdges; }\\n\"+\n                          \".bar { shape-rendering: crispEdges;}\\n\")\n        \n        // Actually draw the chart objects\n        for (var i = 0; i < plots.length; i += 1) {\n            var plot = plots[i];\n            if (plot['type'] == 'line') {\n                chart.canvas.append(\"path\")\n                            .style('stroke', plot['style']['color'])\n                            .attr('class', \"line\")\n                            .data(plot['data'])\n                            .attr(\"d\", chart.mapLine(plot['data']));\n            } else if (plot['type'] == 'scatter') {\n                chart.canvas.append(\"g\")\n                            .attr(\"class\", \"series\")\n                            .selectAll(\".point\")\n                            .data(plot['data'])\n                            .enter()\n                            .append('circle')\n                            .style('fill', plot['style']['color'])\n                            .attr(\"class\", \"circle\")\n                            .attr(\"cx\", chart.mapX)\n                            .attr(\"cy\", chart.mapY)\n                            .attr('r', 2);\n            } else if (plot['type'] == 'hist') {\n                chart.canvas.selectAll('.bar')\n                            .data(histMapper)\n                            .enter().append(\"rect\")\n                            .attr(\"class\", \"bar\")\n                            .style('fill', plot['style']['color'])\n                            .style('stroke', 'black')\n                            .attr(\"x\", function(d) { return chart.xScale(d.x); })\n                            .attr(\"width\", (chart.width-yAxisBuffer)/(1+histMapper.length))\n                            .attr(\"y\", function(d) { return chart.yScale(d.y); })\n                            .attr(\"height\", function(d) { return chart.height - chart.yScale(d.y); });\n            }\n        }\n        if (Sk.console.pngMode) {\n            var doctype = '<?xml version=\"1.0\" standalone=\"no\"?>' + '<' + '!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">';\n            var xml = new XMLSerializer().serializeToString(chart.svg[0][0]);\n            var blob = new Blob([ doctype + xml], { type: 'image/svg+xml' });\n            var url = window.URL.createObjectURL(blob);\n            //var data = \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(xml)));\n            var img  = document.createElement(\"img\");\n            img.style.display = 'block';\n            var oldChart = chart;\n            var oldPlots = plots;\n            Sk.console.printHtml(img, oldPlots);\n            resetChart();\n            oldChart.svg[0][0].parentNode.replaceChild(img, oldChart.svg[0][0])\n            img.onload = function() {\n                img.onload = null;\n                //TODO: Make this capture a class descendant. Cross the D3/Jquery barrier!\n                var canvas = document.createElement('canvas');\n                canvas.width = Sk.console.width;\n                canvas.height = Sk.console.height;\n                var ctx = canvas.getContext('2d');\n                ctx.drawImage(img, 0, 0);\n                var canvasUrl = canvas.toDataURL(\"image/png\");\n                img.setAttribute('src', canvasUrl);\n                // Snip off this chart, we can now start a new one.\n            }\n            img.onerror = function() {\n                \n            }\n            img.setAttribute('src', url);\n        } else {\n            Sk.console.printHtml(chart.svg, plots);\n            // Snip off this chart, we can now start a new one.\n            resetChart();\n        }\n    };\n    mod.show = new Sk.builtin.func(show_f);\n\n    var title_f = function(s) {\n        Sk.builtin.pyCheckArgs(\"title\", arguments, 1, 1);\n\n        if (!Sk.builtin.checkString(s)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(s) +\n                \"' is not supported for title; should be a string.\");\n        }\n        \n        labels['title']= Sk.ffi.remapToJs(s);\n    };\n    mod.title = new Sk.builtin.func(title_f);\n\n    var xlabel_f = function(s) {\n        Sk.builtin.pyCheckArgs(\"xlabel\", arguments, 1, 1);\n\n        if (!Sk.builtin.checkString(s)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(s) +\n                \"' is not supported for xlabel; should be a string.\");\n        }\n        \n        labels['x-axis']= Sk.ffi.remapToJs(s);\n    };\n    mod.xlabel = new Sk.builtin.func(xlabel_f);\n\n    var ylabel_f = function(s) {\n        Sk.builtin.pyCheckArgs(\"ylabel\", arguments, 1, 1);\n\n        if (!Sk.builtin.checkString(s)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(s) +\n                \"' is not supported for ylabel; should be a string.\");\n        }\n        \n        labels['y-axis']= Sk.ffi.remapToJs(s);\n    };\n    mod.ylabel = new Sk.builtin.func(ylabel_f);\n\n    // Clear the current figure\n    var clf_f = function() {\n        chart = null;\n        resetChart();\n    };\n    mod.clf = new Sk.builtin.func(clf_f);\n\n    UNSUPPORTED = [\"semilogx\", \"semilogy\", \"specgram\", \"stackplot\", \"stem\", \"step\", \"streamplot\", \"tricontour\", \"tricontourf\", \"tripcolor\", \"triplot\", \"vlines\", \"xcorr\", \"barbs\", \"cla\", \"grid\", \"table\", \"text\", \"annotate\", \"ticklabel_format\", \"locator_params\", \"tick_params\", \"margins\", \"autoscale\", \"autumn\", \"cool\", \"copper\", \"flag\", \"gray\", \"hot\", \"hsv\", \"jet\", \"pink\", \"prism\", \"spring\", \"summer\", \"winter\", \"spectral\", \"hlines\", \"loglog\", \"magnitude_spectrum\", \"pcolor\", \"pcolormesh\", \"phase_spectrum\", \"pie\", \"plot_date\", \"psd\", \"quiver\", \"quiverkey\", \"findobj\", \"switch_backend\", \"isinteractive\", \"ioff\", \"ion\", \"pause\", \"rc\", \"rc_context\", \"rcdefaults\", \"gci\", \"sci\", \"xkcd\", \"figure\", \"gcf\", \"get_fignums\", \"get_figlabels\", \"get_current_fig_manager\", \"connect\", \"disconnect\", \"close\", \"savefig\", \"ginput\", \"waitforbuttonpress\", \"figtext\", \"suptitle\", \"figimage\", \"figlegend\", \"hold\", \"ishold\", \"over\", \"delaxes\", \"sca\", \"gca\", \"subplot\", \"subplots\", \"subplot2grid\", \"twinx\", \"twiny\", \"subplots_adjust\", \"subplot_tool\", \"tight_layout\", \"box\", \"xlim\", \"ylim\", \"xscale\", \"yscale\", \"xticks\", \"yticks\", \"minorticks_on\", \"minorticks_off\", \"rgrids\", \"thetagrids\", \"plotting\", \"get_plot_commands\", \"colors\", \"colormaps\", \"_setup_pyplot_info_docstrings\", \"colorbar\", \"clim\", \"set_cmap\", \"imread\", \"imsave\", \"matshow\", \"polar\", \"plotfile\", \"_autogen_docstring\", \"acorr\", \"arrow\", \"axhline\", \"axhspan\", \"axvline\", \"axvspan\", \"bar\", \"barh\", \"broken_barh\", \"boxplot\", \"cohere\", \"clabel\", \"contour\", \"contourf\", \"csd\", \"errorbar\", \"eventplot\", \"fill\", \"fill_between\", \"fill_betweenx\", \"hexbin\", \"hist2d\", 'axis']\n    for (var i = 0; i < UNSUPPORTED.length; i+= 1) {\n        mod[UNSUPPORTED[i]] = new Sk.builtin.func(function() {\n            throw new Sk.builtin.NotImplementedError(UNSUPPORTED[i]+\" is not yet implemented\");\n        });\n    }\n    \n    var legend_f = function() {\n        return Sk.builtin.none.none$;\n    }\n    mod.legend = new Sk.builtin.func(legend_f);\n    \n    var hist_f = function(kwa) {\n        // Parse arguments\n        Sk.builtin.pyCheckArgs(\"hist\", arguments, 1, Infinity, true, false);\n        args = Array.prototype.slice.call(arguments, 1);        \n        kwargs = new Sk.builtins.dict(kwa); // is pretty useless for handling kwargs\n        kwargs = Sk.ffi.remapToJs(kwargs); // create a proper dict\n        \n        var bins = 10;\n        if (\"bins\" in kwargs) {\n            bins = kwargs[\"bins\"];\n        }\n        \n        // Keep a backup of the arguments for checker\n        mod.values.push(args);\n        \n        // Parse different argument combinations\n        var data = null;\n        var stylestring = null;\n        if (args.length == 1) {\n            // xdata\n            data = Sk.ffi.remapToJs(args[0]);\n        } else if (args.length == 2) {\n            // xdata, style\n            data = Sk.ffi.remapToJs(args[0]);\n            stylestring = Sk.ffi.remapToJs(args[1]);\n        }\n        \n        // empty canvas from previous plots\n        createChart('hist');\n\n        // Parse formatting, also keep ColorCycler updated\n        var cycle = jsplotlib.rc[\"axes.color_cycle\"];\n        var linestyle = ' ', marker= 'o', \n            color = cycle[colorCycle % cycle.length];\n        if (stylestring !== null) {\n            var ftm_tuple = jsplotlib._process_plot_format(stylestring);\n            linestyle = ftm_tuple.linestyle;\n            marker = jsplotlib.parse_marker(ftm_tuple.marker);\n            color = ftm_tuple.color;\n        } else {\n            colorCycle += 1;\n        }\n        // Save\n        plots.push({\n            \"data\": data, \n            \"type\": 'hist',\n            \"bins\": bins,\n            'style': {\n                'linestyle': linestyle,\n                'marker': marker,\n                'color': jsplotlib.color_to_hex(color)\n            }\n        });\n        updateMinMax(\"x\", data);\n        \n        if (Sk.console.skipDrawing) {\n            return;\n        }\n    }\n    hist_f.co_kwargs = true;\n    mod.hist = new Sk.builtin.func(hist_f);\n    \n    var scatter_f = function(kwa) {\n        // Parse arguments\n        Sk.builtin.pyCheckArgs(\"scatter\", arguments, 1, Infinity, true, false);\n        args = Array.prototype.slice.call(arguments, 1);        \n        kwargs = new Sk.builtins.dict(kwa); // is pretty useless for handling kwargs\n        kwargs = Sk.ffi.remapToJs(kwargs); // create a proper dict\n        \n        var dot_limit = 256;\n        if (\"dot_limit\" in kwargs) {\n            dot_limit = kwargs[\"dot_limit\"];\n        }\n        \n        // Keep a backup of the arguments for checker\n        mod.values.push(args);\n        \n        // Parse different argument combinations\n        var xdata = null;\n        var ydata = null;\n        var stylestring = null;\n        if (args.length == 2) {\n            // xdata, ydata\n            xdata = Sk.ffi.remapToJs(args[0]);\n            ydata = Sk.ffi.remapToJs(args[1]);\n        } else if (args.length == 3) {\n            // xdata, ydata, style\n            xdata = Sk.ffi.remapToJs(args[0]);\n            ydata = Sk.ffi.remapToJs(args[1]);\n            stylestring = Sk.ffi.remapToJs(args[2]);\n        }\n        \n        if (xdata.length > dot_limit) {\n            var xdataSampled = [], ydataSampled = [];\n            var LENGTH = xdata.length, RATE = LENGTH / dot_limit;\n            for (var i = 0; i < dot_limit; i+= 1) {\n                var index = Math.floor((i+Math.random())*RATE);\n                xdataSampled.push(xdata[index])\n                ydataSampled.push(ydata[index]);\n            }\n            xdata = xdataSampled;\n            ydata = ydataSampled;\n        }\n        \n        // empty canvas from previous plots\n        createChart('scatter');\n\n        // Zip up the data\n        var actualData = d3.zip(xdata, ydata).map(function(e) {\n            return {'x': e[0], 'y': e[1]}\n        });\n        // Parse formatting, also keep ColorCycler updated\n        var cycle = jsplotlib.rc[\"axes.color_cycle\"];\n        var linestyle = ' ', marker= 'o', \n            color = cycle[colorCycle % cycle.length];\n        if (stylestring !== null) {\n            var ftm_tuple = jsplotlib._process_plot_format(stylestring);\n            linestyle = ftm_tuple.linestyle;\n            marker = jsplotlib.parse_marker(ftm_tuple.marker);\n            color = ftm_tuple.color;\n        } else {\n            colorCycle += 1;\n        }\n        // Save\n        plots.push({\n            \"data\": actualData, \n            \"type\": 'scatter',\n            'style': {\n                'linestyle': linestyle,\n                'marker': marker,\n                'color': jsplotlib.color_to_hex(color)\n            }\n        });\n        // Update min/max\n        updateMinMax(\"x\", xdata)\n        updateMinMax(\"y\", ydata)\n        if (Sk.console.skipDrawing) {\n            return;\n        }\n    };\n    scatter_f.co_kwargs = true;\n    mod.scatter = new Sk.builtin.func(scatter_f);\n    \n\n    return mod;\n};\n\n\njsplotlib.rc = {\n    \"lines.linewidth\": 1.0,\n    \"lines.linestyle\": \"-\",\n    \"lines.color\": \"blue\",\n    \"lines.marker\": \"None\",\n    \"lines.markeredgewidth\": 0.5,\n    \"lines.markersize\": 6,\n    \"lines.dash_joinstyle\": \"miter\",\n    \"lines.dash_capstyle\": \"butt\",\n    \"lines.solid_jointyle\": \"miter\",\n    \"lines.solid_capstyle\": \"projecting\",\n    \"lines.antialiased\": true,\n    \"patch.linewidth\": 1.0,\n    \"patch.facecolor\": \"blue\",\n    \"patch.edgecolor\": \"black\",\n    \"patch.antialiased\": true,\n    \"text.color\": \"black\",\n    \"axes.hold\": true, // whether to clear the axes by default on\n    \"axes.facecolor\": \"white\", // axes background color\n    \"axes.edgecolor\": \"black\", // axes edge color\n    \"axes.grid\": false,\n    \"axes.titlesize\": \"large\",\n    \"axes.labelsize\": \"medium\",\n    \"axes.labelweigth\": \"normal\",\n    \"axes.labelcolor\": \"black\",\n    \"axes.axisbelow\": false,\n    \"axes.color_cycle\": [\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"]\n};\n\nvar chart_counter = 0; // for creating unique ids\njsplotlib._line_counter = 0;\n\n/** List of all supported line styles **/\njsplotlib.lineStyles = {\n    '-': '_draw_solid',\n    '--': '_draw_dashed',\n    '-.': '_draw_dash_dot',\n    ':': '_draw_dotted',\n    'None': '_draw_nothing',\n    ' ': '_draw_nothing',\n    '': '_draw_nothing',\n};\n\njsplotlib.lineMarkers = {\n    '.': 'point',\n    ',': 'pixel',\n    'o': 'circle',\n    'v': 'triangle_down',\n    '^': 'triangle_up',\n    '<': 'triangle_left',\n    '>': 'triangle_right',\n    '1': 'tri_down',\n    '2': 'tri_up',\n    '3': 'tri_left',\n    '4': 'tri_right',\n    '8': 'octagon',\n    's': 'square',\n    'p': 'pentagon',\n    '*': 'star',\n    'h': 'hexagon1',\n    'H': 'hexagon2',\n    '+': 'plus',\n    'x': 'x',\n    'D': 'diamond',\n    'd': 'thin_diamond',\n    '|': 'vline',\n    '_': 'hline',\n    //TICKLEFT: 'tickleft',\n    //TICKRIGHT: 'tickright',\n    //TICKUP: 'tickup',\n    //TICKDOWN: 'tickdown',\n    //CARETLEFT: 'caretleft',\n    //CARETRIGHT: 'caretright',\n    //CARETUP: 'caretup',\n    //CARETDOWN: 'caretdown',\n    \"None\": 'nothing',\n    //Sk.builtin.none.none$: 'nothing',\n    ' ': 'nothing',\n    '': 'nothing'\n};\n\n/**\n Color short keys\n**/\njsplotlib.colors = {\n    'b': 'blue',\n    'g': 'green',\n    'r': 'red',\n    'c': 'cyan',\n    'm': 'magenta',\n    'y': 'yellow',\n    'k': 'black',\n    'w': 'white'\n};\n\n/**\n Mapping of all possible CSS colors, that are supported by matplotlib\n**/\njsplotlib.cnames = {\n    'aliceblue': '#F0F8FF',\n    'antiquewhite': '#FAEBD7',\n    'aqua': '#00FFFF',\n    'aquamarine': '#7FFFD4',\n    'azure': '#F0FFFF',\n    'beige': '#F5F5DC',\n    'bisque': '#FFE4C4',\n    'black': '#000000',\n    'blanchedalmond': '#FFEBCD',\n    'blue': '#0000FF',\n    'blueviolet': '#8A2BE2',\n    'brown': '#A52A2A',\n    'burlywood': '#DEB887',\n    'cadetblue': '#5F9EA0',\n    'chartreuse': '#7FFF00',\n    'chocolate': '#D2691E',\n    'coral': '#FF7F50',\n    'cornflowerblue': '#6495ED',\n    'cornsilk': '#FFF8DC',\n    'crimson': '#DC143C',\n    'cyan': '#00FFFF',\n    'darkblue': '#00008B',\n    'darkcyan': '#008B8B',\n    'darkgoldenrod': '#B8860B',\n    'darkgray': '#A9A9A9',\n    'darkgreen': '#006400',\n    'darkkhaki': '#BDB76B',\n    'darkmagenta': '#8B008B',\n    'darkolivegreen': '#556B2F',\n    'darkorange': '#FF8C00',\n    'darkorchid': '#9932CC',\n    'darkred': '#8B0000',\n    'darksage': '#598556',\n    'darksalmon': '#E9967A',\n    'darkseagreen': '#8FBC8F',\n    'darkslateblue': '#483D8B',\n    'darkslategray': '#2F4F4F',\n    'darkturquoise': '#00CED1',\n    'darkviolet': '#9400D3',\n    'deeppink': '#FF1493',\n    'deepskyblue': '#00BFFF',\n    'dimgray': '#696969',\n    'dodgerblue': '#1E90FF',\n    'firebrick': '#B22222',\n    'floralwhite': '#FFFAF0',\n    'forestgreen': '#228B22',\n    'fuchsia': '#FF00FF',\n    'gainsboro': '#DCDCDC',\n    'ghostwhite': '#F8F8FF',\n    'gold': '#FFD700',\n    'goldenrod': '#DAA520',\n    'gray': '#808080',\n    'green': '#008000',\n    'greenyellow': '#ADFF2F',\n    'honeydew': '#F0FFF0',\n    'hotpink': '#FF69B4',\n    'indianred': '#CD5C5C',\n    'indigo': '#4B0082',\n    'ivory': '#FFFFF0',\n    'khaki': '#F0E68C',\n    'lavender': '#E6E6FA',\n    'lavenderblush': '#FFF0F5',\n    'lawngreen': '#7CFC00',\n    'lemonchiffon': '#FFFACD',\n    'lightblue': '#ADD8E6',\n    'lightcoral': '#F08080',\n    'lightcyan': '#E0FFFF',\n    'lightgoldenrodyellow': '#FAFAD2',\n    'lightgreen': '#90EE90',\n    'lightgray': '#D3D3D3',\n    'lightpink': '#FFB6C1',\n    'lightsage': '#BCECAC',\n    'lightsalmon': '#FFA07A',\n    'lightseagreen': '#20B2AA',\n    'lightskyblue': '#87CEFA',\n    'lightslategray': '#778899',\n    'lightsteelblue': '#B0C4DE',\n    'lightyellow': '#FFFFE0',\n    'lime': '#00FF00',\n    'limegreen': '#32CD32',\n    'linen': '#FAF0E6',\n    'magenta': '#FF00FF',\n    'maroon': '#800000',\n    'mediumaquamarine': '#66CDAA',\n    'mediumblue': '#0000CD',\n    'mediumorchid': '#BA55D3',\n    'mediumpurple': '#9370DB',\n    'mediumseagreen': '#3CB371',\n    'mediumslateblue': '#7B68EE',\n    'mediumspringgreen': '#00FA9A',\n    'mediumturquoise': '#48D1CC',\n    'mediumvioletred': '#C71585',\n    'midnightblue': '#191970',\n    'mintcream': '#F5FFFA',\n    'mistyrose': '#FFE4E1',\n    'moccasin': '#FFE4B5',\n    'navajowhite': '#FFDEAD',\n    'navy': '#000080',\n    'oldlace': '#FDF5E6',\n    'olive': '#808000',\n    'olivedrab': '#6B8E23',\n    'orange': '#FFA500',\n    'orangered': '#FF4500',\n    'orchid': '#DA70D6',\n    'palegoldenrod': '#EEE8AA',\n    'palegreen': '#98FB98',\n    'paleturquoise': '#AFEEEE',\n    'palevioletred': '#DB7093',\n    'papayawhip': '#FFEFD5',\n    'peachpuff': '#FFDAB9',\n    'peru': '#CD853F',\n    'pink': '#FFC0CB',\n    'plum': '#DDA0DD',\n    'powderblue': '#B0E0E6',\n    'purple': '#800080',\n    'red': '#FF0000',\n    'rosybrown': '#BC8F8F',\n    'royalblue': '#4169E1',\n    'saddlebrown': '#8B4513',\n    'salmon': '#FA8072',\n    'sage': '#87AE73',\n    'sandybrown': '#FAA460',\n    'seagreen': '#2E8B57',\n    'seashell': '#FFF5EE',\n    'sienna': '#A0522D',\n    'silver': '#C0C0C0',\n    'skyblue': '#87CEEB',\n    'slateblue': '#6A5ACD',\n    'slategray': '#708090',\n    'snow': '#FFFAFA',\n    'springgreen': '#00FF7F',\n    'steelblue': '#4682B4',\n    'tan': '#D2B48C',\n    'teal': '#008080',\n    'thistle': '#D8BFD8',\n    'tomato': '#FF6347',\n    'turquoise': '#40E0D0',\n    'violet': '#EE82EE',\n    'wheat': '#F5DEB3',\n    'white': '#FFFFFF',\n    'whitesmoke': '#F5F5F5',\n    'yellow': '#FFFF00',\n    'yellowgreen': '#9ACD32'\n};\n\njsplotlib.color_to_hex = function(color) {\n    // is color a shortcut?\n    if (jsplotlib.colors[color])\n        color = jsplotlib.colors[color];\n\n    // is inside cnames array?\n    if (jsplotlib.cnames[color])\n        return jsplotlib.cnames[color];\n\n    // check if it is already a hex value\n    if (typeof color == \"string\") {\n        var match = color.match(/^#(?:[0-9a-fA-F]{3}){1,2}$/);\n        if (match && match.length === 1)\n            return match[0];\n    }\n\n    // add rgb colors here\n    if (Array.isArray(color) && color.length === 3) {\n        return jsplotlib.rgb2hex(color);\n    }\n\n    // back to default\n    return jsplotlib.cnames[jsplotlib.rc['lines.color']];\n};\n\njsplotlib.get_color = function(cs) {\n    return jsplotlib.colors[cs] ? jsplotlib.colors[cs] : jsplotlib.colors.b;\n};\n\njsplotlib.parse_marker = function(style) {\n    if (!style) return \"x\";\n    switch (style) {\n        case '.':\n            return \".\";\n        case ',':\n            return \"x\";\n        case 'o':\n            return \"o\";\n        case 'v':\n            return \"x\";\n        case '^':\n            return \"x\";\n        case '<':\n            return \"x\";\n        case '>':\n            return \"x\";\n        case '1':\n            return \"x\";\n        case '2':\n            return \"x\";\n        case '3':\n            return \"x\";\n        case '4':\n            return \"x\";\n        case 's':\n            return \"s\";\n        case 'p':\n            return \"x\";\n        case '*':\n            return \"x\";\n        case 'h':\n            return \"x\";\n        case 'H':\n            return \"x\";\n        case '+':\n            return \"x\";\n        case 'x':\n            return \"x\";\n        case 'D':\n            return \"x\";\n        case 'd':\n            return \"x\";\n        case '|':\n            return \"x\";\n        case '_':\n            return \"x\";\n        default:\n            return \"\";\n    }\n};\n\n/**\nProcess a MATLAB style color/line style format string.  Return a\n(*linestyle*, *color*) tuple as a result of the processing.  Default\nvalues are ('-', 'b').  Example format strings include:\n\n* 'ko': black circles\n* '.b': blue dots\n* 'r--': red dashed lines\n\n.. seealso::\n\n    :func:`~matplotlib.Line2D.lineStyles` and\n    :func:`~matplotlib.pyplot.colors`\n        for all possible styles and color format string.\n**/\njsplotlib._process_plot_format = function(fmt) {\n    var linestyle = null;\n    var marker = null;\n    var color = null;\n\n    // Is fmt just a colorspec\n    try {\n        color = jsplotlib.to_rgb(fmt);\n        if (color) {\n            return {\n                'linestyle': linestyle,\n                'marker': marker,\n                'color': color\n            };\n        }\n    } catch (e) {}\n\n    // handle the multi char special cases and strip them for the string\n    if (fmt.search(/--/) >= 0) {\n        linestyle = '--';\n        fmt = fmt.replace(/--/, '');\n    }\n    if (fmt.search(/-\\./) >= 0) {\n        linestyle = '-.';\n        fmt = fmt.replace(/-\\./, '');\n    }\n    if (fmt.search(/ /) >= 0) {\n        linestyle = '';\n        fmt = fmt.replace(/ /, '');\n    }\n\n    var i;\n    for (i = 0; i < fmt.length; i++) {\n        var c = fmt.charAt(i);\n        if (jsplotlib.lineStyles[c]) {\n            if (linestyle) {\n                throw new Sk.builtin.ValueError('Illegal format string \"' + fmt +\n                    '\"; two linestyle symbols');\n            }\n            linestyle = c;\n        } else if (jsplotlib.lineMarkers[c]) {\n            if (marker) {\n                throw new Sk.builtin.ValueError('Illegal format string \"' + fmt +\n                    '\"; two marker symbols');\n            }\n            marker = c;\n        } else if (jsplotlib.colors[c]) {\n            if (color) {\n                throw new Sk.builtin.ValueError('Illegal format string \"' + fmt +\n                    '\"; two color symbols');\n            }\n            color = c;\n        } else {\n            throw new Sk.builtin.ValueError('Unrecognized character ' + c +\n                ' in format string');\n        }\n    }\n\n    if (!linestyle && !marker) {\n        // use defaults --> rcParams['lines.linestyle']\n        linestyle = '-';\n    }\n    if (!linestyle) {\n        linestyle = ' ';\n    }\n    if (!marker) {\n        marker = '';\n    }\n\n    return {\n        'linestyle': linestyle,\n        'marker': marker,\n        'color': color\n    };\n};\n\n/**\n https://github.com/matplotlib/matplotlib/blob/master/lib/matplotlib/colors.py\n http://matplotlib.org/api/colors_api.html\n\n  Returns an *RGB* tuple of three floats from 0-1.\n\n  *arg* can be an *RGB* or *RGBA* sequence or a string in any of\n  several forms:\n\n      1) a letter from the set 'rgbcmykw'\n      2) a hex color string, like '#00FFFF'\n      3) a standard name, like 'aqua'\n      4) a string representation of a float, like '0.4',\n         indicating gray on a 0-1 scale\n\n  if *arg* is *RGBA*, the *A* will simply be discarded.\n**/\njsplotlib.to_rgb = function(fmt) {\n    if (!fmt) return null;\n\n    var color = null;\n\n    if (typeof fmt == \"string\") {\n        fmt_lower = fmt.toLowerCase();\n\n        if (jsplotlib.colors[fmt_lower])\n            return jsplotlib.hex2color(jsplotlib.cnames[jsplotlib.colors[fmt_lower]]);\n\n        // is inside cnames array?\n        if (jsplotlib.cnames[fmt_lower])\n            return jsplotlib.hex2color(jsplotlib.cnames[fmt_lower]);\n\n        if (fmt_lower.indexOf('#') === 0) {\n            return jsplotlib.hex2color(fmt_lower);\n        }\n\n        // is it simple grey shade?\n        var fl = parseFloat(fmt_lower);\n        if (isNaN(fl)) {\n            throw new Sk.builtin.ValueError('cannot convert argument to rgb sequence');\n        }\n\n        if (fl < 0 || fl > 1) {\n            throw new Sk.builtin.ValueError('gray (string) must be in range 0-1');\n        }\n\n        return [fl, fl, fl];\n    }\n\n    // check if its a color tuple [r,g,b, [a]] with values from [0-1]\n    if (Array.isArray(fmt)) {\n        if (fmt.length > 4 || fmt.length < 3)\n            throw new Sk.builtin.ValueError('sequence length is ' + fmt.length +\n                '; must be 3 or 4');\n\n        color = fmt.slice(0, 3);\n        var i;\n\n        for (i = 0; i < 3; i++) {\n            var fl_rgb = parseFloat(fmt);\n\n            if (fl_rgb < 0 || fl_rgb > 1)\n                throw new Sk.builtin.ValueError(\n                    'number in rbg sequence outside 0-1 range');\n        }\n    }\n\n    return color;\n};\n\n/**\n  Take a hex string *s* and return the corresponding rgb 3-tuple\n  Example: #efefef -> (0.93725, 0.93725, 0.93725)\n**/\njsplotlib.hex2color = function(s) {\n    if (!s || typeof s != \"string\") {\n        throw new Sk.builtin.TypeError(\"hex2color requires a string argument\");\n    }\n    // check if it is a hex value\n    var i;\n    var s_copy = s;\n    var hex_tuple = [];\n    for (i = 0; i < 3; i++) {\n        var match = s_copy.match(/(?:[0-9a-fA-F]){1,2}$/);\n        if (match && match.length === 1) {\n            hex_tuple.push(match[0]);\n            s_copy = s_copy.substring(0, match.index);\n        }\n    }\n    //var match = s.match(/^#(?:[0-9a-fA-F]{3}){1,2}$/);\n    if (hex_tuple.length === 3) {\n        // yeah positiv --> convert into right color spec\n        var color = [];\n        color[0] = parseInt(hex_tuple[0], 16) / 255.0;\n        color[1] = parseInt(hex_tuple[1], 16) / 255.0;\n        color[2] = parseInt(hex_tuple[2], 16) / 255.0;\n\n        return color.reverse();\n    } else {\n        throw new Sk.builtin.ValueError('invalid hex color string \"' + s + '\"');\n    }\n};\n\n/**\n  Expects and rgb tuple with values [0,1]\n**/\njsplotlib.rgb2hex = function(rgb) {\n    if (!rgb) return null;\n\n    if (rgb.length && rgb.length >= 3) {\n        var i;\n        // some hacky code to rebuild string format :(\n        var hex_str = '#';\n        for (i = 0; i < 3; i++) {\n            var val = Math.round(rgb[i] * 255).toString(16);\n            hex_str += val.length == 2 ? val : '0' + val;\n        }\n\n        return hex_str;\n    }\n};\n", "src/lib/weather/__init__.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n    if (typeof Sk.connectedServices === 'undefined') {\n        Sk.connectedServices = {};\n    }\n    \n    var CONNECTED = 'weather' in Sk.connectedServices;\n    var CONNECTED_URL = Sk.connectedServices['weather']\n    \n    var CACHE = function() {\n        var name = \"WEATHER_BLOCKPY_\";\n        this.set =  function(key, value) {\n            localStorage.setItem(name+key+\"_value\", value);\n            localStorage.setItem(name+key+\"_timestamp\", (new Date).getTime());\n        };\n        this.remove = function(key) {\n            localStorage.removeItem(name+key+\"_value\");\n            localStorage.removeItem(name+key+\"_timestamp\");\n        };\n        this.get = function(key) {\n            return localStorage.getItem(name+key+\"_value\");\n        };\n        this.has = function(key) {\n            if (this.is_old(key, 10)) {\n                this.remove(key);\n                return false;\n            } else {\n                return localStorage.getItem(name+key+\"_value\") !== null;\n            }\n        };\n        // Tests whether the server has the newer version\n        this.is_old = function(key, minutes) {\n            var stored_time = localStorage.getItem(name+key+\"_timestamp\");\n            current_time = (new Date).getTime();\n            return (current_time >= stored_time+(minutes*60000));\n        };\n    };\n    \n    var WEATHER_REPORTS = {\n    'BLACKSBURG':[{'temperature': 78, 'humidity':  20, 'wind':  7}, {'temperature': 61, 'humidity': 50, 'wind': 10},\n                  {'temperature': 81, 'humidity': 100, 'wind':  5}, {'temperature': 62, 'humidity': 90, 'wind': 15},\n                  {'temperature': 84, 'humidity':  30, 'wind': 19}, {'temperature': 66, 'humidity':  0, 'wind': 28},\n                  {'temperature': 87, 'humidity':   0, 'wind': 12}, {'temperature': 68, 'humidity':  0, 'wind': 14},\n                  {'temperature': 86, 'humidity':   0, 'wind':  4}, {'temperature': 68, 'humidity': 60, 'wind':  0}],\n    'SEATTLE':   [{'temperature': 56, 'humidity': 10, 'wind':  7}, {'temperature': 40, 'humidity': 0, 'wind': 9},\n                  {'temperature': 54, 'humidity': 0, 'wind':  9}, {'temperature': 38, 'humidity': 20, 'wind': 3},\n                  {'temperature': 57, 'humidity':  10, 'wind': 10}, {'temperature': 39, 'humidity':  30, 'wind': 6},\n                  {'temperature': 60, 'humidity':  20, 'wind':  7}, {'temperature': 42, 'humidity':  0, 'wind': 7},\n                  {'temperature': 65, 'humidity':  0, 'wind':  2}, {'temperature': 41, 'humidity': 0, 'wind': 2}],\n    'MIAMI':     [{'temperature': 79, 'humidity': 60, 'wind': 12}, {'temperature': 59, 'humidity': 60, 'wind': 14},\n                  {'temperature': 61, 'humidity': 60, 'wind': 15}, {'temperature': 68, 'humidity': 60, 'wind': 17},\n                  {'temperature': 70, 'humidity':  40, 'wind': 11}, {'temperature': 68, 'humidity': 40, 'wind':  9},\n                  {'temperature': 72, 'humidity':  30, 'wind':  8}, {'temperature': 68, 'humidity':  30, 'wind': 10},\n                  {'temperature': 71, 'humidity':  30, 'wind':  5}, {'temperature': 68, 'humidity':  30, 'wind':  3}],\n    'SANJOSE':   [{'temperature': 62, 'humidity': 0, 'wind': 10}, {'temperature': 41, 'humidity': 0, 'wind': 11},\n                  {'temperature': 63, 'humidity': 0, 'wind': 13}, {'temperature': 42, 'humidity': 0, 'wind':  6},\n                  {'temperature': 62, 'humidity': 0, 'wind':  7}, {'temperature': 42, 'humidity': 0, 'wind':  8},\n                  {'temperature': 59, 'humidity': 0, 'wind':  3}, {'temperature': 42, 'humidity': 0, 'wind':  4},\n                  {'temperature': 59, 'humidity': 0, 'wind':  2}, {'temperature': 42, 'humidity': 0, 'wind':  5}],\n    'NEWYORK':   [{'temperature': 59, 'humidity':   70, 'wind':  5}, {'temperature': 47, 'humidity':  40, 'wind': 10},\n                  {'temperature': 60, 'humidity':   0, 'wind': 27}, {'temperature': 31, 'humidity':  0, 'wind': 17},\n                  {'temperature': 49, 'humidity':   0, 'wind': 15}, {'temperature': 31, 'humidity': 0, 'wind': 4},\n                  {'temperature': 60, 'humidity':  30, 'wind': 17}, {'temperature': 44, 'humidity': 30, 'wind': 9},\n                  {'temperature': 63, 'humidity': 30, 'wind': 8}, {'temperature': 48, 'humidity': 30, 'wind': 4}]\n    };\n    function normalize_city(city) {\n        switch (city.toLowerCase()) {\n            case \"blacksburg, va\": case \"blacksburg va\": case \"blacksburg\":\n            case \"va\": case \"virginia\":\n                return \"BLACKSBURG\";\n            case \"seattle, wa\": case \"seattle wa\": case \"seattle\":\n            case \"wa\": case \"washington\":\n                return \"SEATTLE\";\n            case \"miami, fl\": case \"miami fl\": case \"miami\":\n            case \"fl\": case \"florida\":\n                return \"MIAMI\";\n            case \"san jose, ca\": case \"san jose ca\": case \"san jose\":\n            case \"ca\": case \"california\": case \"sanjose\":\n                return \"SANJOSE\";\n            case \"new york, ny\": case \"new york ny\": case \"new york\":\n            case \"ny\": case \"newyork\":\n                return \"NEWYORK\";\n            default: return null;\n        }\n    }\n    \n    var sanitizeInput = function(functionName, city) {\n        Sk.builtin.pyCheckType(\"city\", \"string\", Sk.builtin.checkString(city));\n        city = normalize_city(city.v);\n        if (city === null) {\n            throw new Sk.builtin.ValueError(\"Weather data is only available for the following cities: Blacksburg, Miami, San Jose, New York, Seattle.\");\n        }\n    };\n    \n    var getData = function(city) {\n        if (CONNECTED) {\n            if (CACHE.has(city)) {\n                return CACHE.get(city);\n            } else {\n                $.post(CONNECTED_URL, {'city': city}, function(data) {\n                    // Oh. This is actually going to be a thing.\n                    // Have to crack how Skulpt does it and replicate that.\n                    // Or figure \n                })\n            }\n        } else {\n            return WEATHER_REPORTS;\n        }\n    }\n\n    mod.get_temperature = new Sk.builtin.func(function(city) {\n        Sk.builtin.pyCheckArgs(\"get_temperature\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"city\", \"string\", Sk.builtin.checkString(city));\n        city = normalize_city(city.v);\n        if (city === null) {\n            throw new Sk.builtin.ValueError(\"Weather data is only available for the following cities: Blacksburg, Miami, San Jose, New York, Seattle.\");\n        }\n        \n        return Sk.ffi.remapToPy(WEATHER_REPORTS[city][0]['temperature']);\n    });\n    \n    mod.get_forecasts = new Sk.builtin.func(function(city) {\n        Sk.builtin.pyCheckArgs(\"get_forecasts\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"city\", \"string\", Sk.builtin.checkString(city));\n        city = normalize_city(city.v);\n        if (city === null) {\n            throw new Sk.builtin.ValueError(\"Weather data is only available for the following cities: Blacksburg, Miami, San Jose, New York, Seattle.\");\n        }\n        return Sk.ffi.remapToPy(WEATHER_REPORTS[city].map(function(elem){\n            return elem['temperature'];\n        }));\n    });\n    \n    mod.get_report = new Sk.builtin.func(function(city) {\n        Sk.builtin.pyCheckArgs(\"get_report\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"city\", \"string\", Sk.builtin.checkString(city));\n        city = normalize_city(city.v);\n        if (city === null) {\n            throw new Sk.builtin.ValueError(\"Weather data is only available for the following cities: Blacksburg, Miami, San Jose, New York, Seattle.\");\n        }\n        return Sk.ffi.remapToPy(WEATHER_REPORTS[city][0]);\n    });\n    \n    mod.get_forecasted_reports = new Sk.builtin.func(function(city) {\n        Sk.builtin.pyCheckArgs(\"get_forecasted_reports\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"city\", \"string\", Sk.builtin.checkString(city));\n        city = normalize_city(city.v);\n        if (city === null) {\n            throw new Sk.builtin.ValueError(\"Weather data is only available for the following cities: Blacksburg, Miami, San Jose, New York, Seattle.\");\n        }\n        return Sk.ffi.remapToPy(WEATHER_REPORTS[city]);\n    });\n    \n    mod.get_highs_lows = new Sk.builtin.func(function(city) {\n        Sk.builtin.pyCheckArgs(\"get_highs_lows\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"city\", \"string\", Sk.builtin.checkString(city));\n        city = normalize_city(city.v);\n        if (city === null) {\n            throw new Sk.builtin.ValueError(\"Weather data is only available for the following cities: Blacksburg, Miami, San Jose, New York, Seattle.\");\n        }\n        var highs = [], lows = [];\n        for (var i = 0; i < WEATHER_REPORTS[city].length; i+= 1) {\n            var temperature = WEATHER_REPORTS[city][i]['temperature'];\n            if (i % 2 == 0) {\n                highs.push(temperature);\n            } else {\n                lows.push(temperature);\n            }\n        }\n        return Sk.ffi.remapToPy({\"highs\": highs, \"lows\":  lows});\n    });\n    \n    var get_temperatures = function(city) {\n        return WEATHER_REPORTS[city].map(function(elem){\n            return elem['temperature'];\n        })\n    };\n    \n    mod.get_all_forecasted_temperatures = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"get_all_forecasted_temperatures\", arguments, 0, 0);\n        return Sk.ffi.remapToPy([\n            {\"city\": \"Blacksburg, VA\", \"forecasts\": get_temperatures(\"BLACKSBURG\")},\n            {\"city\": \"Seattle, WA\", \"forecasts\": get_temperatures(\"SEATTLE\")},\n            {\"city\": \"Miami, FL\", \"forecasts\": get_temperatures(\"MIAMI\")},\n            {\"city\": \"San Jose, CA\", \"forecasts\": get_temperatures(\"SANJOSE\")},\n            {\"city\": \"New York, NY\", \"forecasts\": get_temperatures(\"NEWYORK\")},\n        ]);\n    });\n    \n    mod.connect = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"connect\", arguments, 0, 0);\n        CONNECTED = true;\n    });\n    mod.disconnect = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"disconnect\", arguments, 0, 0);\n        CONNECTED = false;\n    });\n\n    return mod;\n};", "src/lib/crime/__init__.js": "/**\n * @fileoverview CORGIS Skulpt Crime library for returning realistic, interesting data about UCR crime reports in America.\n * @author acbart@vt.edu (Austin Cory Bart)\n */\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n    \n    if (_CRIME_DATA === undefined) {\n        throw new Sk.builtin.NameError(\n                \"Can not resolve _CRIME_DATA. Make sure the file is available!\");\n    }\n\n    mod.get_property_crimes = new Sk.builtin.func(function(state) {\n        Sk.builtin.pyCheckArgs(\"get_property_crimes\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"state\", \"string\", Sk.builtin.checkString(state));\n        state = state.v.toLowerCase();\n        if (! (state in _CRIME_DATA)) {\n            throw new Sk.builtin.Exception(\"State name not found: \"+state);\n        }\n        return Sk.ffi.remapToPy(_CRIME_DATA[state]['data'].map(function(elem) {\n            return elem['rates']['property']['all'];\n        }));\n    });\n    \n    mod.get_violent_crimes = new Sk.builtin.func(function(state) {\n        Sk.builtin.pyCheckArgs(\"get_violent_crimes\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"state\", \"string\", Sk.builtin.checkString(state));\n        state = state.v.toLowerCase();\n        if (! (state in _CRIME_DATA)) {\n            throw new Sk.builtin.Exception(\"State name not found: \"+state);\n        }\n        return Sk.ffi.remapToPy(_CRIME_DATA[state]['data'].map(function(elem) {\n            return elem['rates']['violent']['all'];\n        }));\n    });\n    \n    mod.get_by_year = new Sk.builtin.func(function(year) {\n        Sk.builtin.pyCheckArgs(\"get_by_year\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"year\", \"string\", Sk.builtin.checkString(year));\n        year = year.v.toLowerCase();\n        var year_data = Array();\n        for (var state in _CRIME_DATA) {\n            var data = _CRIME_DATA[state]['data'];\n            for (var i = 0; i < data.length; i+= 1) {\n                if (data[i]['year'] == year) {\n                    year_data.push({'state': _CRIME_DATA[state]['state'],\n                                    'violent': _CRIME_DATA[state]['data'][i]['rates']['violent']['all'],\n                                    'property': _CRIME_DATA[state]['data'][i]['rates']['property']['all'],\n                                    'population': _CRIME_DATA[state]['data'][i]['population']});\n                }\n            }\n        }\n        if (year_data.length == 0) {\n            throw new Sk.builtin.Exception(\"Year not valid: \"+year);\n        }\n        return Sk.ffi.remapToPy(year_data);\n    });\n    \n    mod.get_all = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"get_all\", arguments, 0, 0);\n        return [];\n        //return Sk.ffi.remapToPy(_CRIME_DATA);\n    });\n    \n\n    return mod;\n};", "src/lib/lib2to3/__init__.py": "raise NotImplementedError(\"lib2to3 is not yet implemented in Skulpt\")\n", "src/lib/lib2to3/fixes/__init__.py": "raise NotImplementedError(\"fixes is not yet implemented in Skulpt\")\n", "src/lib/lib2to3/tests/__init__.py": "raise NotImplementedError(\"tests is not yet implemented in Skulpt\")\n", "src/lib/lib2to3/pgen2/__init__.py": "raise NotImplementedError(\"pgen2 is not yet implemented in Skulpt\")\n", "src/lib/idlelib/__init__.py": "raise NotImplementedError(\"idlelib is not yet implemented in Skulpt\")\n", "src/lib/idlelib/Icons/__init__.py": "raise NotImplementedError(\"Icons is not yet implemented in Skulpt\")\n", "src/lib/pythonds/__init__.py": "", "src/lib/pythonds/trees/binaryTree.py": "# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\nclass BinaryTree:\n    \"\"\"\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n    \"\"\"    \n    def __init__(self,rootObj):\n        self.key = rootObj\n        self.leftChild = None\n        self.rightChild = None\n\n    def insertLeft(self,newNode):\n        if self.leftChild == None:\n            self.leftChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.left = self.leftChild\n            self.leftChild = t\n    \n    def insertRight(self,newNode):\n        if self.rightChild == None:\n            self.rightChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.right = self.rightChild\n            self.rightChild = t\n\n    def isLeaf(self):\n        return ((not self.leftChild) and (not self.rightChild))\n\n    def getRightChild(self):\n        return self.rightChild\n\n    def getLeftChild(self):\n        return self.leftChild\n\n    def setRootVal(self,obj):\n        self.key = obj\n\n    def getRootVal(self,):\n        return self.key\n\n    def inorder(self):\n        if self.leftChild:\n            self.leftChild.inorder()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.inorder()\n\n    def postorder(self):\n        if self.leftChild:\n            self.leftChild.postorder()\n        if self.rightChild:\n            self.rightChild.postorder()\n        print(self.key)\n\n\n    def preorder(self):\n        print(self.key)\n        if self.leftChild:\n            self.leftChild.preorder()\n        if self.rightChild:\n            self.rightChild.preorder()\n\n    def printexp(self):\n        if self.leftChild:\n            print('(')\n            self.leftChild.printexp()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.printexp()\n            print(')')\n\n    def postordereval(self):\n        opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.leftChild:\n            res1 = self.leftChild.postordereval()  #// \\label{peleft}\n        if self.rightChild:\n            res2 = self.rightChild.postordereval() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.key](res1,res2) #// \\label{peeval}\n        else:\n            return self.key\n\ndef inorder(tree):\n    if tree != None:\n        inorder(tree.getLeftChild())\n        print(tree.getRootVal())\n        inorder(tree.getRightChild())\n\ndef printexp(tree):\n    if tree.leftChild:\n        print('(')\n        printexp(tree.getLeftChild())\n    print(tree.getRootVal())\n    if tree.rightChild:\n        printexp(tree.getRightChild())\n        print(')') \n\ndef printexp(tree):\n    sVal = \"\"\n    if tree:\n        sVal = '(' + printexp(tree.getLeftChild())\n        sVal = sVal + str(tree.getRootVal())\n        sVal = sVal + printexp(tree.getRightChild()) + ')'\n    return sVal\n\ndef postordereval(tree):\n    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n    res1 = None\n    res2 = None\n    if tree:\n        res1 = postordereval(tree.getLeftChild())  #// \\label{peleft}\n        res2 = postordereval(tree.getRightChild()) #// \\label{peright}\n        if res1 and res2:\n            return opers[tree.getRootVal()](res1,res2) #// \\label{peeval}\n        else:\n            return tree.getRootVal()\n\ndef height(tree):\n    if tree == None:\n        return -1\n    else:\n        return 1 + max(height(tree.leftChild),height(tree.rightChild))\n\n# t = BinaryTree(7)\n# t.insertLeft(3)\n# t.insertRight(9)\n# inorder(t)\n# import operator\n# x = BinaryTree('*')\n# x.insertLeft('+')\n# l = x.getLeftChild()\n# l.insertLeft(4)\n# l.insertRight(5)\n# x.insertRight(7)\n# print(printexp(x))\n# print(postordereval(x))\n# print(height(x))\n", "src/lib/pythonds/trees/bst.py": "#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nclass BinarySearchTree:\n    '''\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n                  in\n                  del <==> \n    '''\n\n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def put(self,key,val):\n        if self.root:\n            self._put(key,val,self.root)\n        else:\n            self.root = TreeNode(key,val)\n        self.size = self.size + 1\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n            \n    def __setitem__(self,k,v):\n        self.put(k,v)\n\n    def get(self,key):\n        if self.root:\n            res = self._get(key,self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n        \n    def _get(self,key,currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key,currentNode.leftChild)\n        else:\n            return self._get(key,currentNode.rightChild)\n            \n        \n    def __getitem__(self,key):\n        res = self.get(key)\n        if res:\n            return res\n        else:\n            raise KeyError('Error, key not in tree')\n            \n\n    def __contains__(self,key):\n        if self._get(key,self.root):\n            return True\n        else:\n            return False\n        \n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n    \n    def delete(self,key):\n        if self.size > 1:\n            nodeToRemove = self._get(key,self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size = self.size-1\n            else:\n                raise KeyError('Error, key not in tree')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError('Error, key not in tree')\n\n    def __delitem__(self,key):\n        self.delete(key)\n    \n    def remove(self,currentNode):\n        if currentNode.isLeaf(): #leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren(): #interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n        else: # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                       currentNode.leftChild.payload,\n                                       currentNode.leftChild.leftChild,\n                                       currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                       currentNode.rightChild.payload,\n                                       currentNode.rightChild.leftChild,\n                                       currentNode.rightChild.rightChild)\n\n    def inorder(self):\n        self._inorder(self.root)\n\n    def _inorder(self,tree):\n        if tree != None:\n            self._inorder(tree.leftChild)\n            print(tree.key)\n            self._inorder(tree.rightChild)\n\n    def postorder(self):\n        self._postorder(self.root)\n\n    def _postorder(self, tree):\n        if tree:\n            self._postorder(tree.rightChild)\n            self._postorder(tree.leftChild)\n            print(tree.key)            \n\n    def preorder(self):\n        self._preorder(self,self.root)\n\n    def _preorder(self,tree):\n        if tree:\n            print(tree.key)            \n            self._preorder(tree.leftChild)\n            self._preorder(tree.rightChild)\n\n                \nclass TreeNode:\n    def __init__(self,key,val,left=None,right=None,parent=None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent = parent\n        self.balanceFactor = 0\n        \n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n    \n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n    \n    def replaceNodeData(self,key,value,lc,rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n        \n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def __iter__(self):\n        \"\"\"The standard inorder traversal of a binary tree.\"\"\"\n        if self:\n            if self.hasLeftChild():\n                for elem in self.leftChild:\n                    yield elem\n            yield self.key\n            if self.hasRightChild():\n                for elem in self.rightChild:\n                    yield elem\n\n            \n", "src/lib/pythonds/trees/__init__.py": "\n# from .binaryTree import BinaryTree\n# from .balance import AVLTree\n# from .bst import BinarySearchTree\n# from .binheap import BinHeap\n\n\n", "src/lib/pythonds/trees/binheap.py": "# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\n# this heap takes key value pairs, we will assume that the keys are integers\nclass BinHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n\n    def buildHeap(self,alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = [0] + alist[:]\n        print(len(self.heapList), i)\n        while (i > 0):\n            print(self.heapList, i)\n            self.percDown(i)\n            i = i - 1\n        print(self.heapList,i)\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapList[i] > self.heapList[mc]:\n                tmp = self.heapList[i]\n                self.heapList[i] = self.heapList[mc]\n                self.heapList[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        else:\n            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapList[i] < self.heapList[i//2]:\n               tmp = self.heapList[i // 2]\n               self.heapList[i // 2] = self.heapList[i]\n               self.heapList[i] = tmp\n            i = i // 2\n \n    def insert(self,k):\n        self.heapList.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapList[1]\n        self.heapList[1] = self.heapList[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapList.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if currentSize == 0:\n            return True\n        else:\n            return False\n", "src/lib/pythonds/trees/balance.py": "#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nfrom .bst import BinarySearchTree, TreeNode\n\nclass AVLTree(BinarySearchTree):\n    '''\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  has_key(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n    '''\n\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.leftChild)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.rightChild)                \n\n    def updateBalance(self,node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balanceFactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rebalance(self,node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                # Do an LR Rotation\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                # single left\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                # Do an RL Rotation\n                self.rotateLeft(node.leftChild)\n                self.rotateRight(node)\n            else:\n                # single right\n                self.rotateRight(node)\n\n    def rotateLeft(self,rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n\n    def rotateRight(self,rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot\n            else:\n                rotRoot.parent.leftChild = newRoot\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor - 1 - max(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor - 1 + min(rotRoot.balanceFactor, 0)\n        \n", "src/lib/pythonds/basic/queue.py": "# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#queue.py\n\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def enqueue(self, item):\n        self.items.insert(0,item)\n\n    def dequeue(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\n", "src/lib/pythonds/basic/deque.py": "# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#deque.py\n\n\nclass Deque:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def addFront(self, item):\n        self.items.append(item)\n\n    def addRear(self, item):\n        self.items.insert(0,item)\n\n    def removeFront(self):\n        return self.items.pop()\n\n    def removeRear(self):\n        return self.items.pop(0)\n\n    def size(self):\n        return len(self.items)\n", "src/lib/pythonds/basic/__init__.py": "\n#__all__ = [\"stack\"]\n\n\n#from .stack import Stack\n#from .queue import Queue\n\n\n\n", "src/lib/pythonds/basic/stack.py": "# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#stack.py\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def peek(self):\n        return self.items[len(self.items)-1]\n\n    def size(self):\n        return len(self.items)\n\n", "src/lib/pythonds/graphs/adjGraph.py": "#\n#  adjGraph\n#\n#  Created by Brad Miller on 2005-02-24.\n#  Copyright (c) 2005 Brad Miller, David Ranum, Luther College. All rights reserved.\n#\n\nimport sys\nimport os\nimport unittest\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.numVertices = 0\n        \n    def addVertex(self,key):\n        self.numVertices = self.numVertices + 1\n        newVertex = Vertex(key)\n        self.vertices[key] = newVertex\n        return newVertex\n    \n    def getVertex(self,n):\n        if n in self.vertices:\n            return self.vertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.vertices\n    \n    def addEdge(self,f,t,cost=0):\n            if f not in self.vertices:\n                nv = self.addVertex(f)\n            if t not in self.vertices:\n                nv = self.addVertex(t)\n            self.vertices[f].addNeighbor(self.vertices[t],cost)\n    \n    def getVertices(self):\n        return list(self.vertices.keys())\n        \n    def __iter__(self):\n        return iter(self.vertices.values())\n                \nclass Vertex:\n    def __init__(self,num):\n        self.id = num\n        self.connectedTo = {}\n        self.color = 'white'\n        self.dist = sys.maxsize\n        self.pred = None\n        self.disc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def addNeighbor(self,nbr,weight=0):\n        self.connectedTo[nbr] = weight\n        \n    def setColor(self,color):\n        self.color = color\n        \n    def setDistance(self,d):\n        self.dist = d\n\n    def setPred(self,p):\n        self.pred = p\n\n    def setDiscovery(self,dtime):\n        self.disc = dtime\n        \n    def setFinish(self,ftime):\n        self.fin = ftime\n        \n    def getFinish(self):\n        return self.fin\n        \n    def getDiscovery(self):\n        return self.disc\n        \n    def getPred(self):\n        return self.pred\n        \n    def getDistance(self):\n        return self.dist\n        \n    def getColor(self):\n        return self.color\n    \n    def getConnections(self):\n        return self.connectedTo.keys()\n        \n    def getWeight(self,nbr):\n        return self.connectedTo[nbr]\n                \n    def __str__(self):\n        return str(self.id) + \":color \" + self.color + \":disc \" + str(self.disc) + \":fin \" + str(self.fin) + \":dist \" + str(self.dist) + \":pred \\n\\t[\" + str(self.pred)+ \"]\\n\"\n    \n    def getId(self):\n        return self.id\n\nclass adjGraphTests(unittest.TestCase):\n    def setUp(self):\n        self.tGraph = Graph()\n        \n    def testMakeGraph(self):\n        gFile = open(\"test.dat\")\n        for line in gFile:\n            fVertex, tVertex = line.split('|')\n            fVertex = int(fVertex)\n            tVertex = int(tVertex)\n            self.tGraph.addEdge(fVertex,tVertex)\n        for i in self.tGraph:\n            adj = i.getAdj()\n            for k in adj:\n                print(i, k)\n\n        \nif __name__ == '__main__':\n    unittest.main()\n              \n", "src/lib/pythonds/graphs/__init__.py": "\n\nfrom .adjGraph import Graph\nfrom .adjGraph import Vertex\nfrom .priorityQueue import PriorityQueue\n", "src/lib/pythonds/graphs/priorityQueue.py": "# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \nimport unittest\n\n# this implementation of binary heap takes key value pairs,\n# we will assume that the keys are all comparable\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heapArray = [(0,0)]\n        self.currentSize = 0\n\n    def buildHeap(self,alist):\n        self.currentSize = len(alist)\n        self.heapArray = [(0,0)]\n        for i in alist:\n            self.heapArray.append(i)\n        i = len(alist) // 2            \n        while (i > 0):\n            self.percDown(i)\n            i = i - 1\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapArray[i][0] > self.heapArray[mc][0]:\n                tmp = self.heapArray[i]\n                self.heapArray[i] = self.heapArray[mc]\n                self.heapArray[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i*2 > self.currentSize:\n            return -1\n        else:\n            if i*2 + 1 > self.currentSize:\n                return i*2\n            else:\n                if self.heapArray[i*2][0] < self.heapArray[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapArray[i][0] < self.heapArray[i//2][0]:\n               tmp = self.heapArray[i//2]\n               self.heapArray[i//2] = self.heapArray[i]\n               self.heapArray[i] = tmp\n            i = i//2\n \n    def add(self,k):\n        self.heapArray.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapArray[1][1]\n        self.heapArray[1] = self.heapArray[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapArray.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if self.currentSize == 0:\n            return True\n        else:\n            return False\n\n    def decreaseKey(self,val,amt):\n        # this is a little wierd, but we need to find the heap thing to decrease by\n        # looking at its value\n        done = False\n        i = 1\n        myKey = 0\n        while not done and i <= self.currentSize:\n            if self.heapArray[i][1] == val:\n                done = True\n                myKey = i\n            else:\n                i = i + 1\n        if myKey > 0:\n            self.heapArray[myKey] = (amt,self.heapArray[myKey][1])\n            self.percUp(myKey)\n            \n    def __contains__(self,vtx):\n        for pair in self.heapArray:\n            if pair[1] == vtx:\n                return True\n        return False\n        \nclass TestBinHeap(unittest.TestCase):\n    def setUp(self):\n        self.theHeap = PriorityQueue()\n        self.theHeap.add((2,'x'))\n        self.theHeap.add((3,'y'))\n        self.theHeap.add((5,'z'))\n        self.theHeap.add((6,'a'))\n        self.theHeap.add((4,'d'))\n\n\n    def testInsert(self):\n        assert self.theHeap.currentSize == 5\n\n    def testDelmin(self):\n        assert self.theHeap.delMin() == 'x'\n        assert self.theHeap.delMin() == 'y'\n    \n    def testDecKey(self):\n        self.theHeap.decreaseKey('d',1)\n        assert self.theHeap.delMin() == 'd'\n        \nif __name__ == '__main__':\n    unittest.main()\n", "src/lib/parking/__init__.js": "var $builtinmodule = function(name)\n{\n    var WEEKDAYS = [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"];\n    var FULL_DAYS = {\n        \"mon\": \"Monday\", \"tue\": \"Tuesday\", \"wed\": \"Wednesday\",\n        \"thu\": \"Thursday\", \"fri\": \"Friday\", \"sat\": \"Saturday\",\n        \"sun\": \"Sunday\"\n    }\n    \n    var convert_day = function(day) {\n        return WEEKDAYS.indexOf(day.name.v);\n    }\n    var convert_day_string = function(day) {\n        return WEEKDAYS.indexOf(day.v.toLowerCase().slice(0, 3));\n    }\n    var convert_time = function(hour, minute, meridian) {\n        return hour*60 + minute + (meridian.toLowerCase() == \"pm\" ? 12*60 : 0);\n    }\n    \n    var mod = {};\n    \n    var time = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self, hour, minute, meridian) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 4, 4);\n            Sk.builtin.pyCheckType(\"hour\", \"int\", Sk.builtin.checkInt(hour));\n            Sk.builtin.pyCheckType(\"minute\", \"int\", Sk.builtin.checkInt(minute));\n            Sk.builtin.pyCheckType(\"meridian\", \"int\", Sk.builtin.checkString(meridian));\n            self.hour = hour;\n            self.minute = minute;\n            self.meridian = meridian;\n            self.meridian.v = self.meridian.v.toLowerCase();\n        });\n        $loc.__str__ = new Sk.builtin.func(function (self) {\n            return Sk.ffi.remapToPy('<'+(self.hour.v || 12) +':'+\n                                    (self.minute.v < 10 ? '0'+self.minute.v : self.minute.v)+\n                                    self.meridian.v+'>');\n        });\n        $loc.__repr__ = new Sk.builtin.func(function (self) {\n            return Sk.ffi.remapToPy('<'+(self.hour.v || 12)+':'+\n                                    (self.minute.v < 10 ? '0'+self.minute.v : self.minute.v)+\n                                    self.meridian.v+'>');\n        });\n        var comparison = function (operation, self, other) {\n            if (Sk.builtin.isinstance(other, mod.Time).v) {\n                if (operation(convert_time(self.hour.v % 12, self.minute.v, self.meridian.v), \n                              convert_time(other.hour.v % 12, other.minute.v, other.meridian.v))) {\n                    return Sk.ffi.remapToPy(true);\n                } else {\n                    return Sk.ffi.remapToPy(false);\n                }\n            } else {\n                return Sk.ffi.remapToPy(false);\n            }\n        }\n        $loc.__eq__ = new Sk.builtin.func(function (self, other) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            return comparison(function(l,r) {return l==r}, self, other);\n        })\n        \n        $loc.__ne__ = new Sk.builtin.func(function (self, other) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            if (!Sk.builtin.isinstance(other, mod.Time).v) {\n                return Sk.builtin.bool.true$;\n            }\n            return comparison(function(l,r) {return l!=r}, self, other);\n        });\n        \n        $loc.__lt__ = new Sk.builtin.func(function (self, other) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            return comparison(function(l,r) {return l < r}, self, other);\n        });\n        \n        $loc.__gt__ = new Sk.builtin.func(function (self, other) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            return comparison(function(l,r) {return l > r}, self, other);\n        });\n        \n        $loc.__le__ = new Sk.builtin.func(function (self, other) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            return comparison(function(l,r) {return l <= r}, self, other);\n        });\n        \n        $loc.__ge__ = new Sk.builtin.func(function (self, other) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            return comparison(function(l,r) {return l >= r}, self, other);\n        });\n    }\n    \n    var day = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function (self, name) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            Sk.builtin.pyCheckType(\"name\", \"string\", Sk.builtin.checkString(name));\n            self.name = name;\n            self.name.v = self.name.v.toLowerCase().slice(0,3)\n        });\n        $loc.__str__ = new Sk.builtin.func(function (self) {\n            return Sk.ffi.remapToPy('<'+FULL_DAYS[self.name.v]+'>');\n        });\n        $loc.__repr__ = new Sk.builtin.func(function (self) {\n            return Sk.ffi.remapToPy('<'+FULL_DAYS[self.name.v]+'>');\n        });\n        var comparison = function (operation, self, other) {\n            if (Sk.builtin.isinstance(other, mod.Day).v) {\n                if (operation(convert_day(self), convert_day(other))) {\n                    return Sk.ffi.remapToPy(true);\n                } else {\n                    return Sk.builtin.bool.false$;\n                }\n            } else {\n                return Sk.builtin.bool.false$;\n            }\n        }\n        $loc.__eq__ = new Sk.builtin.func(function (self, other) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            return comparison(function(l,r) {return l==r}, self, other);\n        })\n        \n        $loc.__ne__ = new Sk.builtin.func(function (self, other) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            if (!Sk.builtin.isinstance(other, mod.Day).v) {\n                return Sk.builtin.bool.true$;\n            }\n            return comparison(function(l,r) {return l!=r}, self, other);\n        });\n        \n        $loc.__lt__ = new Sk.builtin.func(function (self, other) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            return comparison(function(l,r) {return l < r}, self, other);\n        });\n        \n        $loc.__gt__ = new Sk.builtin.func(function (self, other) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            return comparison(function(l,r) {return l > r}, self, other);\n        });\n        \n        $loc.__le__ = new Sk.builtin.func(function (self, other) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            return comparison(function(l,r) {return l <= r}, self, other);\n        });\n        \n        $loc.__ge__ = new Sk.builtin.func(function (self, other) {\n            Sk.builtin.pyCheckArgs(\"__init__\", arguments, 2, 2);\n            return comparison(function(l,r) {return l >= r}, self, other);\n        });\n    }\n    \n    mod.Day = Sk.misceval.buildClass(mod, day, 'Day', []);\n    mod.Time = Sk.misceval.buildClass(mod, time, 'Time', []);\n    \n    mod._today = undefined;\n    mod._hour = undefined;\n    mod._minute = undefined;\n    mod._meridian = undefined;\n    \n    mod.today = new Sk.builtin.func(function() {\n        var t = ((new Date).getDay() + 6) % 7; // would be -1, but % is broken for negatives in JS\n        t = Sk.today || mod._today || Sk.ffi.remapToPy(WEEKDAYS[t]);\n        return Sk.misceval.callsim(mod.Day, t);\n    });\n    \n    mod.now = new Sk.builtin.func(function() {\n        var d = new Date();\n        var hour = d.getHours() % 12,\n            minute = d.getMinutes(),\n            meridian = d.getHours() < 12 ? 'am' : 'pm';\n        hour = Sk._hour || mod._hour || Sk.ffi.remapToPy(hour);\n        minute = Sk._minute || mod._minute || Sk.ffi.remapToPy(minute);\n        meridian = Sk._meridian || mod._meridian || Sk.ffi.remapToPy(meridian);\n        return Sk.misceval.callsim(mod.Time, hour, minute, meridian);\n    });\n    \n    mod.day_compare = new Sk.builtin.func(function(comparison, value, day) {\n        Sk.builtin.pyCheckArgs(\"day_compare\", arguments, 3, 3);\n        Sk.builtin.pyCheckType(\"comparison\", \"string\", Sk.builtin.checkString(comparison));\n        Sk.builtin.pyCheckType(\"value\", \"Day\", Sk.builtin.isinstance(value, mod.Day).v);\n        Sk.builtin.pyCheckType(\"day\", \"string\", Sk.builtin.checkString(day));\n        var day_n = convert_day_string(day),\n            value_n = convert_day(value);\n        switch (comparison.v) {\n            case 'IS': return Sk.ffi.remapToPy(value_n == day_n);\n            case \"BEFORE_EQUAL\": return Sk.ffi.remapToPy(value_n <= day_n);\n            case \"AFTER_EQUAL\": return Sk.ffi.remapToPy(value_n >= day_n);\n            case \"BEFORE\": return Sk.ffi.remapToPy(value_n < day_n);\n            case \"AFTER\": return Sk.ffi.remapToPy(value_n > day_n);\n            case \"IS_NOT\": return Sk.ffi.remapToPy(value_n != day_n);\n            default: throw new Sk.builtins.ValueError(\"Unknown comparison\")\n        }\n    });\n    \n    mod.time_compare = new Sk.builtin.func(function(comparison, left, hour, minute, meridian) {\n        Sk.builtin.pyCheckArgs(\"time_compare\", arguments, 5, 5);\n        Sk.builtin.pyCheckType(\"comparison\", \"string\", Sk.builtin.checkString(comparison));\n        Sk.builtin.pyCheckType(\"left\", \"Time\", Sk.builtin.isinstance(left, mod.Time).v);\n        Sk.builtin.pyCheckType(\"hour\", \"int\", Sk.builtin.checkInt(hour));\n        Sk.builtin.pyCheckType(\"minute\", \"int\", Sk.builtin.checkInt(hour));\n        Sk.builtin.pyCheckType(\"meridian\", \"string\", Sk.builtin.checkString(meridian));\n        var right_time = convert_time(hour.v % 12, minute.v, meridian.v),\n            left_time = convert_time(left.hour.v % 12, left.minute.v, left.meridian.v);\n        switch (comparison.v) {\n            case 'IS': return Sk.ffi.remapToPy(left_time == right_time);\n            case \"BEFORE_EQUAL\": return Sk.ffi.remapToPy(left_time <= right_time);\n            case \"AFTER_EQUAL\": return Sk.ffi.remapToPy(left_time >= right_time);\n            case \"BEFORE\": return Sk.ffi.remapToPy(left_time < right_time);\n            case \"AFTER\": return Sk.ffi.remapToPy(left_time > right_time);\n            case \"IS_NOT\": return Sk.ffi.remapToPy(left_time != right_time);\n            default: throw new Sk.builtins.ValueError(\"Unknown comparison\")\n        }\n    });\n\n    return mod;\n}", "src/lib/sound/__init__.js": "var $builtinmodule = function() {\n  return {};\n};\n", "src/lib/sound/sound.js": "// Do not include this module directly as it has dependencies \nvar $builtinmodule = function() {\n  var soundWrapper, mod, Sample;\n\n  mod = {};\n\n  // Dependency\n  Sample = Sk.sysmodules.mp$subscript('sound.sample').$d.Sample;\n\n  soundWrapper = {\n    stopPlaying: new Sk.builtin.func(function (sound) {\n      Sk.builtin.pyCheckArgs('stopPlaying', arguments, 1);\n      sound._sound.stop();\n    }),\n\n    play : new Sk.builtin.func(function(sound) {\n      Sk.builtin.pyCheckArgs('play', arguments, 1);\n      sound._sound.play();\n    }),\n\n    blockingPlay : new Sk.builtin.func(function(sound) {\n      Sk.builtin.pyCheckArgs('blockingPlay', arguments, 1);\n      Sk.future(function (continueWith) {\n        sound._sound.play(continueWith);\n      });\n    }),\n\n    getDuration : new Sk.builtin.func(function(sound) {\n      Sk.builtin.pyCheckArgs('getDuration', arguments, 1);\n      return new Sk.builtin.float_(sound._sound.getDuration());\n    }),\n\n    getNumSamples : new Sk.builtin.func(function(sound) {\n      Sk.builtin.pyCheckArgs('getNumSamples', arguments, 1);\n      return new Sk.builtin.int_(sound._sound.getLength());\n    }),\n\n    getLength : new Sk.builtin.func(function(sound) {\n      Sk.builtin.pyCheckArgs('getLength', arguments, 1);\n      return new Sk.builtin.int_(sound._sound.getLength());\n    }),\n\n    getSamplingRate : new Sk.builtin.func(function(sound) {\n      Sk.builtin.pyCheckArgs('getSamplingRate', arguments, 1);\n      return new Sk.builtin.int_(sound._sound.getSamplingRate());\n    }),\n\n    setSampleValueAt : new Sk.builtin.func(function(sound, index, value) {\n      var length;\n\n      Sk.builtin.pyCheckArgs('setSampleValueAt', arguments, 3);\n\n      length = sound._sound.getLength();\n\n      if(index < 0 || index >= length) {\n        throw new Sk.builtin.ValueError('Index must have a value between 0 and ' + length);\n      }\n\n      if(!(value instanceof Sk.builtin.int_)) {\n        throw new Sk.builtin.TypeError('Value must be an integer');\n      }\n\n      value = Sk.ffi.unwrapo(value);\n\n      if(value < -32768) { value = -32768; }\n      if(value > 32767) { value = 32767; }\n\n      sound._sound.setLeftSample(Sk.ffi.unwrapo(index), pythy.Sound.map16BitIntToFloat(value));\n    }),\n\n    setLeftSample : new Sk.builtin.func(function(sound, index, value) {\n      var length;\n\n      Sk.builtin.pyCheckArgs('setLeftSample', arguments, 3);\n\n      length = sound._sound.getLength();\n\n      if(index < 0 || index >= length) {\n        throw new Sk.builtin.ValueError('Index must have a value between 0 and ' + length);\n      }\n\n      if(!(value instanceof Sk.builtin.int_)) {\n        throw new Sk.builtin.TypeError('Value must be an integer');\n      }\n\n      value = Sk.ffi.unwrapo(value);\n\n      if(value < -32768) { value = -32768; }\n      if(value > 32767) { value = 32767; }\n\n      sound._sound.setLeftSample(Sk.ffi.unwrapo(index), pythy.Sound.map16BitIntToFloat(value));\n    }),\n\n    setRightSample : new Sk.builtin.func(function(sound, index, value) {\n      var length;\n\n      Sk.builtin.pyCheckArgs('setRightSample', arguments, 3);\n\n      length = sound._sound.getLength();\n\n      if(index < 0 || index >= length) {\n        throw new Sk.builtin.ValueError('Index must have a value between 0 and ' + length);\n      }\n\n      if(!(value instanceof Sk.builtin.int_)) {\n        throw new Sk.builtin.TypeError('Value must be an integer');\n      }\n\n      value = Sk.ffi.unwrapo(value);\n\n      if(value < -32768) { value = -32768; }\n      if(value > 32767) { value = 32767; }\n\n      sound._sound.setRightSample(Sk.ffi.unwrapo(index), pythy.Sound.map16BitIntToFloat(value));\n    }),\n\n    getSampleValueAt : new Sk.builtin.func(function(sound, index) {\n      var length;\n\n      Sk.builtin.pyCheckArgs('getSampleValueAt', arguments, 2);\n\n      length = sound._sound.getLength();\n\n      if(index < 0 || index >= length) {\n        throw new Sk.builtin.ValueError('Index must have a value between 0 and ' + length);\n      }\n\n      return new Sk.builtin.int_(pythy.Sound.mapFloatTo16BitInt(sound._sound.getLeftSample(Sk.ffi.unwrapo(index))));\n    }),\n\n    getLeftSample : new Sk.builtin.func(function(sound, index) {\n      var length;\n\n      Sk.builtin.pyCheckArgs('getLeftSample', arguments, 2);\n\n      length = sound._sound.getLength();\n\n      if(index < 0 || index >= length) {\n        throw new Sk.builtin.ValueError('Index must have a value between 0 and ' + length);\n      }\n\n      return new Sk.builtin.int_(pythy.Sound.mapFloatTo16BitInt(sound._sound.getLeftSample(Sk.ffi.unwrapo(index))));\n    }),\n\n    getRightSample : new Sk.builtin.func(function(sound, index) {\n      var length;\n\n      Sk.builtin.pyCheckArgs('getRightSample', arguments, 2);\n\n      length = sound._sound.getLength();\n\n      if(index < 0 || index >= length) {\n        throw new Sk.builtin.ValueError('Index must have a value between 0 and ' + length);\n      }\n\n      return new Sk.builtin.int_(pythy.Sound.mapFloatTo16BitInt(sound._sound.getRightSample(Sk.ffi.unwrapo(index))));\n    }),\n\n    getSampleObjectAt : new Sk.builtin.func(function (sound, index) {\n      var length;\n\n      Sk.builtin.pyCheckArgs('getSampleObjectAt', arguments, 2);\n\n      length = sound._sound.getLength();\n\n      if(index < 0 || index >= length) {\n        throw new Sk.builtin.ValueError('Index must have a value between 0 and ' + length);\n      }\n\n      return Sk.misceval.callsim(Sample, sound, index);\n    }),\n\n    getSamples : new Sk.builtin.func(function (sound) {\n      var samples, len;\n    \n      Sk.builtin.pyCheckArgs('getSamples', arguments, 1);\n\n      samples = [];\n      len = sound._sound.getLength();\n\n      for(var i = 0; i < len; i++) {\n        samples.push(Sk.misceval.callsim(Sample, sound, Sk.builtin.int_(i)));\n      }\n\n      return new Sk.builtin.list(samples);\n    })\n  };\n\n  mod.Sound = Sk.misceval.buildClass(mod, function ($gbl, $loc) {\n    var onError;\n\n    onError = function (continueWith) {\n      return function (errorMsg) {\n        if(errorMsg.indexOf('File') !== -1) {\n          continueWith(new Sk.builtin.ValueError(errorMsg + '. Is the URL incorrect?'));\n        } else {\n          continueWith(new Sk.builtin.ValueError(errorMsg));\n        }\n      }\n    };\n\n    $loc.__init__ = new Sk.builtin.func(function (sound) {\n      var arg0, res, arg1, arg2;\n\n      Sk.builtin.pyCheckArgs('__init__', arguments, [2, 3]);\n\n      arg0 = arguments[1];\n\n      if(arg0 instanceof Sk.builtin.str) {\n        arg0 = Sk.ffi.unwrapo(arg0); //url\n        res = Sk.future(function (continueWith) {\n          new window.pythy.Sound(continueWith, onError(continueWith), arg0);\n        }); \n      } else if(arg0.tp$name === 'Sound') {\n        res = Sk.future(function (continueWith) {\n          new window.pythy.Sound(continueWith, onError(continueWith), arg0._sound);\n        });\n      } else {\n        arg1 = Sk.ffi.unwrapo(arguments[1]); //numSamples\n        arg2 = Sk.ffi.unwrapo(arguments[2]); //samplingRate\n        res = Sk.future(function (continueWith) {\n          new window.pythy.Sound(continueWith, onError(continueWith), arg1, arg2);\n        });\n      }\n\n      if(res instanceof window.pythy.Sound) {\n        sound._sound = res;\n      } else if(res) {\n        throw res;\n      }\n    });\n\n    $loc.__str__ = new Sk.builtin.func(function(sound) {\n      var str;\n\n      Sk.builtin.pyCheckArgs('__str__', arguments, 1);\n\n      str = 'Sound, ';\n\n      if(sound._sound.url) {\n        str += 'File: ' + sound._sound.url + ', ';\n      }\n\n      return new Sk.builtin.str(str + 'Number of samples: ' + sound._sound.getLength());\n    });\n\n    $loc.__repr__ = new Sk.builtin.func(function(sound) {\n      var str;\n\n      Sk.builtin.pyCheckArgs('__repr__', arguments, 1);\n\n      str = 'Sound, ';\n\n      if(sound._sound.url) {\n        str += 'File: ' + sound._sound.url + ', ';\n      }\n\n      return new Sk.builtin.str(str + 'Number of samples: ' + sound._sound.getLength());\n    });\n\n    $loc.writeToFile = new Sk.builtin.func(function(sound, path) {\n      Sk.builtin.pyCheckArgs('writeToFile', arguments, 2);\n      sound._sound.save(Sk.ffi.unwrapo(path));\n    });\n\n    $loc.duplicate = new Sk.builtin.func(function (sound) {\n      Sk.builtin.pyCheckArgs('duplicate', arguments, 1);\n      return Sk.misceval.callsim(mod.Sound, sound); \n    });\n\n    goog.object.extend($loc, soundWrapper);\n\n  }, 'Sound', []);\n\n  goog.object.extend(mod, soundWrapper);\n\n  goog.object.extend(mod, {\n    duplicateSound: new Sk.builtin.func(function (sound) {\n      Sk.builtin.pyCheckArgs('duplicateSound', arguments, 1);\n      return Sk.misceval.callsim(mod.Sound, sound); \n    }),\n\n    makeSound: new Sk.builtin.func(function (url) {\n      Sk.builtin.pyCheckArgs('makeSound', arguments, 1);\n      return Sk.misceval.callsim(mod.Sound, url);\n    }),\n\n    makeEmptySound: new Sk.builtin.func(function (numSamples, samplingRate) {\n      Sk.builtin.pyCheckArgs('makeEmptySound', arguments, [1, 2]);\n      return Sk.misceval.callsim(mod.Sound, numSamples, samplingRate);\n    }),\n\n    makeEmptySoundBySeconds: new Sk.builtin.func(function (seconds, samplingRate) {\n      var numSamples;\n\n      Sk.builtin.pyCheckArgs('makeEmptySoundBySeconds', arguments, [1, 2]);\n\n      if(Sk.ffi.unwrapo(seconds) < 0) {\n        throw new Sk.builtin.ValueError('Duration can not be negative');\n      }\n      numSamples = Sk.ffi.unwrapo(seconds) * (Sk.ffi.unwrapo(samplingRate) || window.pythy.Sound.SAMPLE_RATE);\n      return Sk.misceval.callsim(mod.Sound, new Sk.builtin.int_(numSamples), samplingRate);\n    }),\n\n    openSoundTool: new Sk.builtin.func(function (sound) {\n      Sk.builtin.pyCheckArgs('openSoundTool', arguments, 1);\n      window.pythy.soundTool.start(sound._sound);\n    }),\n\n    writeSoundTo : new Sk.builtin.func(function(sound, path) {\n      Sk.builtin.pyCheckArgs('writeSoundTo', arguments, 2);\n      sound._sound.save(Sk.ffi.unwrapo(path));\n    })\n  });\n\n  return mod;\n};\n", "src/lib/sound/sample.js": "var $builtinmodule = function() {\n  var mod, sampleWrapper;\n\n  mod = {};\n\n  sampleWrapper = {\n    getSound : new Sk.builtin.func(function (sample) {\n      Sk.builtin.pyCheckArgs('getSound', arguments, 1);\n      return sample._sound;\n    }),\n\n    getSampleValue : new Sk.builtin.func(function (sample) {\n      Sk.builtin.pyCheckArgs('getSampleValue', arguments, 1);\n      return new Sk.builtin.float_(sample._internalSound.getLeftSample(sample._index));\n    }),\n\n    setSampleValue : new Sk.builtin.func(function (sample, value) {\n      Sk.builtin.pyCheckArgs('setSampleValue', arguments, 2);\n      sample._internalSound.setLeftSample(sample._index, Sk.ffi.unwrapo(value));\n    }),\n  };\n\n  mod.Sample = Sk.misceval.buildClass(mod, function ($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function (self, sound, index) {\n      Sk.builtin.pyCheckArgs('__init__', arguments, 3);\n      self._sound = sound;\n      self._internalSound = sound._sound;\n      self._index = Sk.ffi.unwrapo(index);\n    });\n\n    $loc.__str__ = new Sk.builtin.func(function (self) {\n      Sk.builtin.pyCheckArgs('__str__', arguments, 1);\n      return new Sk.builtin.str('Sample at ' + self._index + ' with value ' +\n                            self._internalSound.getLeftSample(self._index));\n    });\n\n    $loc.__repr__ = new Sk.builtin.func(function (self) {\n      Sk.builtin.pyCheckArgs('__repr__', arguments, 1);\n      return new Sk.builtin.str('Sample at ' + self._index + ' with value ' +\n                            self._internalSound.getLeftSample(self._index));\n    });\n\n    goog.object.extend($loc, sampleWrapper);\n  }, 'Sample', []);\n\n  goog.object.extend(mod, sampleWrapper);\n\n  return mod;\n};\n", "src/lib/compiler/__init__.py": "raise NotImplementedError(\"compiler is not yet implemented in Skulpt\")\n", "src/lib/logging/__init__.py": "raise NotImplementedError(\"logging is not yet implemented in Skulpt\")\n", "src/lib/email/__init__.py": "raise NotImplementedError(\"email is not yet implemented in Skulpt\")\n", "src/lib/email/test/data/__init__.py": "raise NotImplementedError(\"data is not yet implemented in Skulpt\")\n", "src/lib/email/mime/__init__.py": "raise NotImplementedError(\"mime is not yet implemented in Skulpt\")\n", "src/lib/earthquakes/__init__.js": "/**\n * @fileoverview CORGIS Skulpt Earthquake library for returning realistic, interesting data about earthquake events around the world.\n * @author acbart@vt.edu (Austin Cory Bart)\n */\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n    \n    var EARTHQUAKE_DATA = [ \n        { \"distance\" : 0.0029, \"gap\" : 91.0, \"id\" : \"nc72399435\", \"location\" : { \"depth\" : 2.48, \"latitude\" : 38.827, \"longitude\" : -122.853 }, \"location_description\" : \"10km WNW of The Geysers, California\", \"magnitude\" : 0.66, \"significance\" : 7, \"time\" : 1424577875110 },\n        { \"distance\" : 0.0717, \"gap\" : 129.0, \"id\" : \"nc72399425\", \"location\" : { \"depth\" : 8.1, \"latitude\" : 38.5776, \"longitude\" : -122.554 }, \"location_description\" : \"2km E of Calistoga, California\", \"magnitude\" : 1.62, \"significance\" : 40, \"time\" : 1424574975250},\n        { \"distance\" : 0.0780, \"gap\" : 150.0, \"id\" : \"nc72399420\", \"location\" : { \"depth\" : 4.48, \"latitude\" : 38.587, \"longitude\" : -122.557 }, \"location_description\" : \"2km ENE of Calistoga, California\", \"magnitude\" : 1.4, \"significance\" : 30, \"time\" : 1424574832330 },\n        { \"distance\" : 0.1238, \"gap\" : 147.0, \"id\" : \"nc72399415\", \"location\" : { \"depth\" : 9.17, \"latitude\" : 40.2758, \"longitude\" : -121.387 }, \"location_description\" : \"13km WSW of Chester, California\", \"magnitude\" : 1.93, \"significance\" : 57, \"time\" : 1424574753850 }, \n        { \"distance\" : 0.0054, \"gap\" : 49.0, \"id\" : \"nc72399410\", \"location\" : { \"depth\" : 2.61, \"latitude\" : 38.8373, \"longitude\" : -122.829 }, \"location_description\" : \"9km W of Cobb, California\", \"magnitude\" : 0.87, \"significance\" : 12, \"time\" : 1424574374130 }, \n        { \"distance\" : 1.2127, \"gap\" : 342.0, \"id\" : \"pr15053000\", \"location\" : { \"depth\" : 107.0, \"latitude\" : 18.6208, \"longitude\" : -68.2754 }, \"location_description\" : \"14km ENE of Punta Cana, Dominican Republic\", \"magnitude\" : 3.1000, \"significance\" : 148, \"time\" : 1424574304700 }, \n        { \"distance\" : 1.9430, \"gap\" : 95.0, \"id\" : \"usc000ts7u\", \"location\" : { \"depth\" : 10.0, \"latitude\" : 40.0871, \"longitude\" : 143.5009 }, \"location_description\" : \"141km ENE of Miyako, Japan\", \"magnitude\" : 5.0, \"significance\" : 385, \"time\" : 1424573622970 }, \n        { \"distance\" : 0.0500, \"gap\" : 45.0, \"id\" : \"ci37099639\", \"location\" : { \"depth\" : 13.8800, \"latitude\" : 33.6235, \"longitude\" : -116.681 }, \"location_description\" : \"8km N of Anza, California\", \"magnitude\" : 0.9399, \"significance\" : 14, \"time\" : 1424573419770 }, \n        { \"distance\" : 0.0063, \"gap\" : 111.0, \"id\" : \"nc72399375\", \"location\" : { \"depth\" : 2.25, \"latitude\" : 38.8230, \"longitude\" : -122.8431 }, \"location_description\" : \"9km NW of The Geysers, California\", \"magnitude\" : 0.2899, \"significance\" : 1, \"time\" : 1424569656300 }, \n        { \"distance\" : 0.161, \"gap\" : 171.75, \"id\" : \"nn00483998\", \"location\" : { \"depth\" : 14.7375, \"latitude\" : 37.1516, \"longitude\" : -117.2762 }, \"location_description\" : \"53km WNW of Beatty, Nevada\", \"magnitude\" : 0.9599, \"significance\" : 14, \"time\" : 1424568722388 }, \n        { \"distance\" : 0.0184, \"gap\" : 108.0, \"id\" : \"nc72399370\", \"location\" : { \"depth\" : 2.569, \"latitude\" : 38.8228, \"longitude\" : -122.8598 }, \"location_description\" : \"10km WNW of The Geysers, California\", \"magnitude\" : 0.5400, \"significance\" : 4, \"time\" : 1424568640760 }, \n        { \"distance\" : 0.0278, \"gap\" : 126.0, \"id\" : \"nc72399360\", \"location\" : { \"depth\" : 7.4699, \"latitude\" : 37.6376, \"longitude\" : -118.9359 }, \"location_description\" : \"3km ESE of Mammoth Lakes, California\", \"magnitude\" : 1.1000, \"significance\" : 19, \"time\" : 1424568510180 }]\n\n    mod.get = new Sk.builtin.func(function(property) {\n        Sk.builtin.pyCheckArgs(\"get\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"property\", \"string\", Sk.builtin.checkString(property));\n        switch (property.v.toLowerCase()) {\n            case \"magnitude\":\n                return Sk.ffi.remapToPy(EARTHQUAKE_DATA.map(function(elem) {\n                    return elem['magnitude'];\n                }));\n            case \"depth\":\n                return Sk.ffi.remapToPy(EARTHQUAKE_DATA.map(function(elem) {\n                    return elem['location']['depth'];\n                }));\n            default:\n                throw new Sk.builtin.ValueError(\"Only depth and magnitude are available through this function.\");\n        }\n    });\n    \n    mod.get_both = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"get_both\", arguments, 0, 0);\n        return Sk.ffi.remapToPy(EARTHQUAKE_DATA.map(function(elem) {\n                return {'magnitude': elem['magnitude'],\n                        'depth': elem['location']['depth']};\n            }));\n    });\n    \n    mod.get_all = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"get_all\", arguments, 0, 0);\n        return Sk.ffi.remapToPy(EARTHQUAKE_DATA);\n    });\n    \n\n    return mod;\n}", "src/lib/media/__init__.py": "# Order is important here\n\nfrom image.style import *\nfrom image.color import *\nfrom image.pixel import *\nfrom image.picture import *\nfrom image import *\n\nfrom sound import *\nfrom sound.sample import *\nfrom sound.sound import *\n"}}